/*
 * Copyright (c) 2023 Texas Instruments Incorporated
 * Copyright (c) 2023 Excelfore Corporation (https://excelfore.com)
 *
 * All rights reserved not granted herein.
 * Limited License.
 *
 * Texas Instruments Incorporated grants a world-wide, royalty-free,
 * non-exclusive license under copyrights and patents it now or hereafter
 * owns or controls to make, have made, use, import, offer to sell and sell ("Utilize")
 * this software subject to the terms herein. With respect to the foregoing patent
 * license, such license is granted solely to the extent that any such patent is necessary
 * to Utilize the software alone. The patent license shall not apply to any combinations which
 * include this software, other than combinations with devices manufactured by or for TI ("TI Devices").
 * No hardware patent is licensed hereunder.
 *
 * Redistributions must preserve existing copyright notices and reproduce this license (including the
 * above copyright notice and the disclaimer and (if applicable) source code license limitations below)
 * in the documentation and/or other materials provided with the distribution
 *
 * Redistribution and use in binary form, without modification, are permitted provided that the following
 * conditions are met:
 *
 * * No reverse engineering, decompilation, or disassembly of this software is permitted with respect to any
 * software provided in binary form.
 * * any redistribution and use are licensed by TI for use only with TI Devices.
 * * Nothing shall obligate TI to provide you with source code for the software licensed and provided to you in object code.
 *
 * If software source code is provided to you, modification and redistribution of the source code are permitted
 * provided that the following conditions are met:
 *
 * * any redistribution and use of the source code, including any resulting derivative works, are licensed by
 * TI for use only with TI Devices.
 * * any redistribution and use of any object code compiled from the source code and any resulting derivative
 * works, are licensed by TI for use only with TI Devices.
 *
 * Neither the name of Texas Instruments Incorporated nor the names of its suppliers may be used to endorse or
 * promote products derived from this software without specific prior written permission.
 *
 * DISCLAIMER.
 *
 * THIS SOFTWARE IS PROVIDED BY TI AND TI"S LICENSORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TI AND TI"S LICENSORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * Copyright (c) 2008 - 2012, Andy Bierman, All Rights Reserved.
 * Copyright (c) 2012 - 2022, YumaWorks, Inc., All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

/**
 * @file u_ieee802-dot1q-bridge.c
 * @brief User SIL-SA module for module ieee802-dot1q-bridge
 *

*** Generated by yangdump-sdk 21.10-12

<pre>

    User SIL-SA module
    bundle x4ucsilsa
    module ieee802-dot1q-bridge
    revision 2022-10-29
    prefix dot1q
    namespace urn:ieee:std:802.1Q:yang:ieee802-dot1q-bridge
    organization IEEE 802.1 Working Group
    Created: 2023-03-29T06:45:58Z

Online Developer Manual:
https://www.yumaworks.com/pub/21.10/dev/yumapro-dev-manual.html

    CLI parameters:
        defnames true
        deviation excelfore-interfaces
        deviation excelfore-gptp
        format uc
        indent 4
        module ietf-interfaces
        module ieee802-dot1q-bridge
        module ieee802-dot1q-tsn-config-uni
        module excelfore-interfaces
        module ieee1588-ptp
        module ieee802-dot1as-ptp
        module excelfore-gptp
        sil-bundle x4ucsilsa
        sil-edit2
        sil-get2
        sil-include tsn_uniconf/yangs/yang_db_access.h
        sil-include tsn_uniconf/yangs/yang_modules.h
        sil-sa
        unified true

  Short Name Mappings
    acceptable_frame = /interfaces/interface/bridge-port/acceptable-frame
    address = /interfaces/interface/bridge-port/address
    address_1 = /bridges/bridge/address
    address_2 = /bridges/bridge/component/address
    address_3 = /bridges/bridge/component/filtering-database/filtering-entry/address
    address_4 = /bridges/bridge/component/permanent-database/filtering-entry/address
    admin_point_to_point = /interfaces/interface/bridge-port/admin-point-to-point
    aging_time = /bridges/bridge/component/filtering-database/aging-time
    allocation_type = /bridges/bridge/component/bridge-vlan/vid-to-fid-allocation/allocation-type
    allocation_type_1 = /bridges/bridge/component/bridge-vlan/fid-to-vid-allocation/allocation-type
    available_traffic_class = /interfaces/interface/bridge-port/traffic-class/traffic-class-map/available-traffic-class
    bridge = /bridges/bridge
    bridge_mst = /bridges/bridge/component/bridge-mst
    bridge_port = /interfaces/interface/bridge-port
    bridge_port_1 = /bridges/bridge/component/bridge-port
    bridge_type = /bridges/bridge/bridge-type
    bridge_vlan = /bridges/bridge/component/bridge-vlan
    bridges = /bridges
    capabilities = /interfaces/interface/bridge-port/capabilities
    capabilities_1 = /bridges/bridge/component/capabilities
    component = /bridges/bridge/component
    component_name = /interfaces/interface/bridge-port/component-name
    components = /bridges/bridge/components
    configurable_pvid_tagging = /bridges/bridge/component/capabilities/configurable-pvid-tagging
    connection_identifier = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-filtering-entries/static-filtering-entries/connection-identifier
    connection_identifier_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-filtering-entries/static-filtering-entries/connection-identifier
    connection_identifier_2 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-filtering-entries/static-filtering-entries/connection-identifier
    control_element = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-filtering-entries/static-filtering-entries/control-element
    control_element_1 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries/control-element
    control_element_10 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-filtering-entries/static-filtering-entries/control-element
    control_element_11 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries/control-element
    control_element_12 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries/control-element
    control_element_13 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries/control-element
    control_element_14 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries/control-element
    control_element_2 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries/control-element
    control_element_3 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries/control-element
    control_element_4 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries/control-element
    control_element_5 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-filtering-entries/static-filtering-entries/control-element
    control_element_6 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries/control-element
    control_element_7 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries/control-element
    control_element_8 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries/control-element
    control_element_9 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries/control-element
    database_id = /bridges/bridge/component/filtering-database/filtering-entry/database-id
    database_id_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/database-id
    database_id_2 = /bridges/bridge/component/permanent-database/filtering-entry/database-id
    db_index = /bridges/bridge/component/bridge-vlan/protocol-group-database/db-index
    default_priority = /interfaces/interface/bridge-port/default-priority
    dei = /interfaces/interface/bridge-port/pcp-encoding-table/pcp-encoding-map/priority-map/dei
    delay_exceeded_discards = /interfaces/interface/bridge-port/statistics/delay-exceeded-discards
    discard_inbound = /interfaces/interface/bridge-port/statistics/discard-inbound
    discard_lack_of_buffers = /interfaces/interface/bridge-port/statistics/discard-lack-of-buffers
    discard_on_error = /interfaces/interface/bridge-port/statistics/discard-on-error
    discard_on_ingress_filtering = /interfaces/interface/bridge-port/statistics/discard-on-ingress-filtering
    discard_transit_delay_exceeded = /interfaces/interface/bridge-port/statistics/discard-transit-delay-exceeded
    drop_eligible = /interfaces/interface/bridge-port/pcp-decoding-table/pcp-decoding-map/priority-map/drop-eligible
    drop_encoding = /interfaces/interface/bridge-port/drop-encoding
    dsap_ssap_pairs = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format/llc-other/dsap-ssap-pairs
    dynamic_entries = /bridges/bridge/component/filtering-database/dynamic-entries
    dynamic_filtering_entries = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-filtering-entries
    dynamic_filtering_entries_1 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries
    dynamic_filtering_entries_2 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-filtering-entries
    dynamic_filtering_entries_3 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries
    dynamic_filtering_entries_4 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-filtering-entries
    dynamic_filtering_entries_5 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries
    dynamic_reservation_entries = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-reservation-entries
    dynamic_reservation_entries_1 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries
    dynamic_reservation_entries_2 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-reservation-entries
    dynamic_reservation_entries_3 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries
    dynamic_reservation_entries_4 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-reservation-entries
    dynamic_reservation_entries_5 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries
    dynamic_vlan_registration_entries = /bridges/bridge/component/filtering-database/dynamic-vlan-registration-entries
    dynamic_vlan_registration_entries_1 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-vlan-registration-entries
    dynamic_vlan_registration_entries_2 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries
    dynamic_vlan_registration_entries_3 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-vlan-registration-entries
    dynamic_vlan_registration_entries_4 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries
    dynamic_vlan_registration_entries_5 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-vlan-registration-entries
    dynamic_vlan_registration_entries_6 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries
    egress_ports = /bridges/bridge/component/bridge-vlan/vlan/egress-ports
    egress_vid_translations = /interfaces/interface/bridge-port/egress-vid-translations
    enable_egress_vid_translation_table = /interfaces/interface/bridge-port/enable-egress-vid-translation-table
    enable_ingress_filtering = /interfaces/interface/bridge-port/enable-ingress-filtering
    enable_restricted_vlan_registration = /interfaces/interface/bridge-port/enable-restricted-vlan-registration
    enable_vid_translation_table = /interfaces/interface/bridge-port/enable-vid-translation-table
    entry_type = /bridges/bridge/component/filtering-database/filtering-entry/entry-type
    entry_type_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/entry-type
    ethernet_rfc1042_snap8021H = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format/ethernet-rfc1042-snap8021H
    ethertype = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format/ethernet-rfc1042-snap8021H/ethertype
    extended_filtering = /bridges/bridge/component/capabilities/extended-filtering
    external = /interfaces/interface/bridge-port/external
    fid = /bridges/bridge/component/bridge-vlan/vid-to-fid-allocation/fid
    fid_1 = /bridges/bridge/component/bridge-vlan/fid-to-vid-allocation/fid
    fid_2 = /bridges/bridge/component/bridge-vlan/vid-to-fid/fid
    fid_3 = /bridges/bridge/component/bridge-mst/fid-to-mstid/fid
    fid_to_mstid = /bridges/bridge/component/bridge-mst/fid-to-mstid
    fid_to_mstid_allocation = /bridges/bridge/component/bridge-mst/fid-to-mstid-allocation
    fid_to_vid_allocation = /bridges/bridge/component/bridge-vlan/fid-to-vid-allocation
    fids = /bridges/bridge/component/bridge-mst/fid-to-mstid-allocation/fids
    filtering_database = /bridges/bridge/component/filtering-database
    filtering_entry = /bridges/bridge/component/filtering-database/filtering-entry
    filtering_entry_1 = /bridges/bridge/component/permanent-database/filtering-entry
    forward_outbound = /interfaces/interface/bridge-port/statistics/forward-outbound
    frame_format = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format
    frame_format_type = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format-type
    frame_rx = /interfaces/interface/bridge-port/statistics/frame-rx
    frame_tx = /interfaces/interface/bridge-port/statistics/frame-tx
    group_id = /interfaces/interface/bridge-port/protocol-group-vid-set/group-id
    group_id_1 = /bridges/bridge/component/bridge-vlan/protocol-group-database/group-id
    hybrid_capable = /bridges/bridge/component/capabilities/hybrid-capable
    id = /bridges/bridge/component/id
    ivl_capable = /bridges/bridge/component/capabilities/ivl-capable
    llc_address = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format/llc-other/dsap-ssap-pairs/llc-address
    llc_other = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format/llc-other
    local_vid = /interfaces/interface/bridge-port/vid-translations/local-vid
    local_vid_1 = /interfaces/interface/bridge-port/egress-vid-translations/local-vid
    local_vlan_capable = /bridges/bridge/component/capabilities/local-vlan-capable
    mac_address_registration_entries = /bridges/bridge/component/filtering-database/mac-address-registration-entries
    mac_address_registration_entries_1 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/mac-address-registration-entries
    mac_address_registration_entries_2 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries
    mac_address_registration_entries_3 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/mac-address-registration-entries
    mac_address_registration_entries_4 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries
    mac_address_registration_entries_5 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/mac-address-registration-entries
    mac_address_registration_entries_6 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries
    map_type = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type
    map_type_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type
    map_type_2 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type
    max_msti = /bridges/bridge/component/bridge-vlan/max-msti
    max_vid_set_entries = /interfaces/interface/bridge-port/max-vid-set-entries
    max_vids = /bridges/bridge/component/bridge-vlan/max-vids
    media_dependent_overhead = /interfaces/interface/bridge-port/media-dependent-overhead
    mstid = /bridges/bridge/component/bridge-mst/mstid
    mstid_1 = /bridges/bridge/component/bridge-mst/fid-to-mstid/mstid
    mstid_2 = /bridges/bridge/component/bridge-mst/fid-to-mstid-allocation/mstid
    mtu_exceeded_discards = /interfaces/interface/bridge-port/statistics/mtu-exceeded-discards
    name = /bridges/bridge/name
    name_1 = /bridges/bridge/component/name
    name_2 = /bridges/bridge/component/bridge-vlan/vlan/name
    num_traffic_class = /interfaces/interface/bridge-port/traffic-class/traffic-class-map/available-traffic-class/num-traffic-class
    octets_rx = /interfaces/interface/bridge-port/statistics/octets-rx
    octets_tx = /interfaces/interface/bridge-port/statistics/octets-tx
    oper_point_to_point = /interfaces/interface/bridge-port/oper-point-to-point
    override_default_pvid = /bridges/bridge/component/bridge-vlan/override-default-pvid
    pcp = /interfaces/interface/bridge-port/pcp-decoding-table/pcp-decoding-map/pcp
    pcp_1 = /interfaces/interface/bridge-port/pcp-encoding-table/pcp-encoding-map/pcp
    pcp_decoding_map = /interfaces/interface/bridge-port/pcp-decoding-table/pcp-decoding-map
    pcp_decoding_table = /interfaces/interface/bridge-port/pcp-decoding-table
    pcp_encoding_map = /interfaces/interface/bridge-port/pcp-encoding-table/pcp-encoding-map
    pcp_encoding_table = /interfaces/interface/bridge-port/pcp-encoding-table
    pcp_selection = /interfaces/interface/bridge-port/pcp-selection
    permanent_database = /bridges/bridge/component/permanent-database
    port_map = /bridges/bridge/component/filtering-database/filtering-entry/port-map
    port_map_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map
    port_map_2 = /bridges/bridge/component/permanent-database/filtering-entry/port-map
    port_number = /interfaces/interface/bridge-port/port-number
    port_ref = /bridges/bridge/component/filtering-database/filtering-entry/port-map/port-ref
    port_ref_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/port-ref
    port_ref_2 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/port-ref
    port_type = /interfaces/interface/bridge-port/port-type
    ports = /bridges/bridge/ports
    ports_1 = /bridges/bridge/component/ports
    priority = /interfaces/interface/bridge-port/pcp-decoding-table/pcp-decoding-map/priority-map/priority
    priority0 = /interfaces/interface/bridge-port/priority-regeneration/priority0
    priority0_1 = /interfaces/interface/bridge-port/service-access-priority/priority0
    priority1 = /interfaces/interface/bridge-port/priority-regeneration/priority1
    priority1_1 = /interfaces/interface/bridge-port/service-access-priority/priority1
    priority2 = /interfaces/interface/bridge-port/priority-regeneration/priority2
    priority2_1 = /interfaces/interface/bridge-port/service-access-priority/priority2
    priority3 = /interfaces/interface/bridge-port/priority-regeneration/priority3
    priority3_1 = /interfaces/interface/bridge-port/service-access-priority/priority3
    priority4 = /interfaces/interface/bridge-port/priority-regeneration/priority4
    priority4_1 = /interfaces/interface/bridge-port/service-access-priority/priority4
    priority5 = /interfaces/interface/bridge-port/priority-regeneration/priority5
    priority5_1 = /interfaces/interface/bridge-port/service-access-priority/priority5
    priority6 = /interfaces/interface/bridge-port/priority-regeneration/priority6
    priority6_1 = /interfaces/interface/bridge-port/service-access-priority/priority6
    priority7 = /interfaces/interface/bridge-port/priority-regeneration/priority7
    priority7_1 = /interfaces/interface/bridge-port/service-access-priority/priority7
    priority_1 = /interfaces/interface/bridge-port/pcp-encoding-table/pcp-encoding-map/priority-map/priority
    priority_2 = /interfaces/interface/bridge-port/traffic-class/traffic-class-map/priority
    priority_code_point = /interfaces/interface/bridge-port/pcp-decoding-table/pcp-decoding-map/priority-map/priority-code-point
    priority_code_point_1 = /interfaces/interface/bridge-port/pcp-encoding-table/pcp-encoding-map/priority-map/priority-code-point
    priority_map = /interfaces/interface/bridge-port/pcp-decoding-table/pcp-decoding-map/priority-map
    priority_map_1 = /interfaces/interface/bridge-port/pcp-encoding-table/pcp-encoding-map/priority-map
    priority_regeneration = /interfaces/interface/bridge-port/priority-regeneration
    protocol_based_vlan_classification = /interfaces/interface/bridge-port/protocol-based-vlan-classification
    protocol_group_database = /bridges/bridge/component/bridge-vlan/protocol-group-database
    protocol_group_vid_set = /interfaces/interface/bridge-port/protocol-group-vid-set
    protocol_id = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format/snap-other/protocol-id
    protocol_template = /bridges/bridge/component/bridge-vlan/protocol-template
    pvid = /interfaces/interface/bridge-port/pvid
    registrar_admin_control = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries/registrar-admin-control
    registrar_admin_control_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries/registrar-admin-control
    registrar_admin_control_2 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries/registrar-admin-control
    relay_vid = /interfaces/interface/bridge-port/vid-translations/relay-vid
    relay_vid_1 = /interfaces/interface/bridge-port/egress-vid-translations/relay-vid
    service_access_priority = /interfaces/interface/bridge-port/service-access-priority
    service_access_priority_selection = /interfaces/interface/bridge-port/service-access-priority-selection
    size = /bridges/bridge/component/filtering-database/size
    size_1 = /bridges/bridge/component/permanent-database/size
    snap_other = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format/snap-other
    static_entries = /bridges/bridge/component/filtering-database/static-entries
    static_entries_1 = /bridges/bridge/component/permanent-database/static-entries
    static_entry_individual_port = /bridges/bridge/component/capabilities/static-entry-individual-port
    static_filtering_entries = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-filtering-entries
    static_filtering_entries_1 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-filtering-entries/static-filtering-entries
    static_filtering_entries_2 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-filtering-entries
    static_filtering_entries_3 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-filtering-entries/static-filtering-entries
    static_filtering_entries_4 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-filtering-entries
    static_filtering_entries_5 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-filtering-entries/static-filtering-entries
    static_vlan_registration_entries = /bridges/bridge/component/filtering-database/static-vlan-registration-entries
    static_vlan_registration_entries_1 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-vlan-registration-entries
    static_vlan_registration_entries_2 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries
    static_vlan_registration_entries_3 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-vlan-registration-entries
    static_vlan_registration_entries_4 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries
    static_vlan_registration_entries_5 = /bridges/bridge/component/permanent-database/static-vlan-registration-entries
    static_vlan_registration_entries_6 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-vlan-registration-entries
    static_vlan_registration_entries_7 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries
    statistics = /interfaces/interface/bridge-port/statistics
    status = /bridges/bridge/component/filtering-database/filtering-entry/status
    status_1 = /bridges/bridge/component/permanent-database/filtering-entry/status
    svl_capable = /bridges/bridge/component/capabilities/svl-capable
    traffic_class = /interfaces/interface/bridge-port/traffic-class
    traffic_class_1 = /interfaces/interface/bridge-port/traffic-class/traffic-class-map/available-traffic-class/traffic-class
    traffic_class_2 = /interfaces/interface/bridge-port/transmission-selection-algorithm-table/transmission-selection-algorithm-map/traffic-class
    traffic_class_enabled = /bridges/bridge/component/traffic-class-enabled
    traffic_class_map = /interfaces/interface/bridge-port/traffic-class/traffic-class-map
    traffic_classes = /bridges/bridge/component/capabilities/traffic-classes
    transmission_selection_algorithm = /interfaces/interface/bridge-port/transmission-selection-algorithm-table/transmission-selection-algorithm-map/transmission-selection-algorithm
    transmission_selection_algorithm_map = /interfaces/interface/bridge-port/transmission-selection-algorithm-table/transmission-selection-algorithm-map
    transmission_selection_algorithm_table = /interfaces/interface/bridge-port/transmission-selection-algorithm-table
    type = /bridges/bridge/component/type
    type_capabilties = /interfaces/interface/bridge-port/type-capabilties
    untagged_ports = /bridges/bridge/component/bridge-vlan/vlan/untagged-ports
    up_time = /bridges/bridge/up-time
    use_dei = /interfaces/interface/bridge-port/use-dei
    version = /bridges/bridge/component/bridge-vlan/version
    vid = /interfaces/interface/bridge-port/protocol-group-vid-set/vid
    vid_1 = /bridges/bridge/component/bridge-vlan/vlan/vid
    vid_2 = /bridges/bridge/component/bridge-vlan/fid-to-vid-allocation/vid
    vid_3 = /bridges/bridge/component/bridge-vlan/vid-to-fid/vid
    vid_to_fid = /bridges/bridge/component/bridge-vlan/vid-to-fid
    vid_to_fid_allocation = /bridges/bridge/component/bridge-vlan/vid-to-fid-allocation
    vid_translations = /interfaces/interface/bridge-port/vid-translations
    vids = /bridges/bridge/component/filtering-database/filtering-entry/vids
    vids_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/vids
    vids_2 = /bridges/bridge/component/permanent-database/filtering-entry/vids
    vids_3 = /bridges/bridge/component/bridge-vlan/vid-to-fid-allocation/vids
    vlan = /bridges/bridge/component/bridge-vlan/vlan
    vlan_registration_entry = /bridges/bridge/component/filtering-database/vlan-registration-entry
    vlan_transmitted = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries/vlan-transmitted
    vlan_transmitted_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries/vlan-transmitted
    vlan_transmitted_2 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries/vlan-transmitted
</pre>

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_action.h"
#include "agt_cb.h"
#include "agt_cfg.h"
#include "agt_rpc.h"
#include "agt_sil_lib.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "agt_val.h"
#include "cfg.h"
#include "dlq.h"
#include "getcb.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "obj.h"
#include "rpc.h"
#include "sil_sa.h"
#include "status.h"
#include "val.h"
#include "val_child.h"
#include "val_util.h"
#include "xml_val.h"

#include "tsn_uniconf/yangs/yang_db_access.h"
#include "tsn_uniconf/yangs/yang_modules.h"


/* SIL bundle: x4ucsilsa */
#include "y_ietf-interfaces.h"
#include "u_ietf-interfaces.h"
#include "y_ieee802-dot1q-bridge.h"
#include "u_ieee802-dot1q-bridge.h"
#include "y_ieee802-dot1q-tsn-config-uni.h"
#include "u_ieee802-dot1q-tsn-config-uni.h"
#include "y_excelfore-interfaces.h"
#include "u_excelfore-interfaces.h"
#include "y_ieee1588-ptp.h"
#include "u_ieee1588-ptp.h"
#include "y_ieee802-dot1as-ptp.h"
#include "u_ieee802-dot1as-ptp.h"
#include "y_excelfore-gptp.h"
#include "u_excelfore-gptp.h"


/**
 * @addtogroup yang-library YANG Library
 *
 * Collection of modules supported by the server.
 * Generated by yangdump-sdk.
 */



/**
 * @addtogroup silsa-x4ucsilsa-ieee802-dot1q-bridge Module ieee802-dot1q-bridge in Bundle x4ucsilsa
 * @ingroup silsa-x4ucsilsa
 *
 * @{
 *
 * YANG instrumentation library.
 * Generated by yangdump-sdk.
 */



/* put your static variables here */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /interfaces/interface/bridge-port/priority-regeneration
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_if_name Ancestor key leaf 'name' in list 'interface'\n
 * Path: /if:interfaces/if:interface/if:name
 * @return return status for the phase.
 */
status_t u_dot1q_priority_regeneration_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_if_name)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_priority_regeneration_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_priority0)) {
                /* leaf priority0 (uint8) */

            } else if (!xml_strcmp(name, y_dot1q_N_priority1)) {
                /* leaf priority1 (uint8) */

            } else if (!xml_strcmp(name, y_dot1q_N_priority2)) {
                /* leaf priority2 (uint8) */

            } else if (!xml_strcmp(name, y_dot1q_N_priority3)) {
                /* leaf priority3 (uint8) */

            } else if (!xml_strcmp(name, y_dot1q_N_priority4)) {
                /* leaf priority4 (uint8) */

            } else if (!xml_strcmp(name, y_dot1q_N_priority5)) {
                /* leaf priority5 (uint8) */

            } else if (!xml_strcmp(name, y_dot1q_N_priority6)) {
                /* leaf priority6 (uint8) */

            } else if (!xml_strcmp(name, y_dot1q_N_priority7)) {
                /* leaf priority7 (uint8) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_priority_regeneration_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /interfaces/interface/bridge-port/traffic-class
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_if_name Ancestor key leaf 'name' in list 'interface'\n
 * Path: /if:interfaces/if:interface/if:name
 * @return return status for the phase.
 */
status_t u_dot1q_traffic_class_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_if_name)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_traffic_class_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_traffic_class_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /interfaces/interface/bridge-port/transmission-selection-algorithm-table/transmission-selection-algorithm-map
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_if_name Ancestor key leaf 'name' in list 'interface'\n
 * Path: /if:interfaces/if:interface/if:name
 * @param k_dot1q_traffic_class_2 Local key leaf 'traffic-class' in list 'transmission-selection-algorithm-map'\n
 * Path: /if:interfaces/if:interface/dot1q:bridge-port/dot1q:transmission-selection-algorithm-table/dot1q:transmission-selection-algorithm-map/dot1q:traffic-class
 * @return return status for the phase.
 */
status_t u_dot1q_transmission_selection_algorithm_map_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_if_name,
    uint8 k_dot1q_traffic_class_2)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_transmission_selection_algorithm_map_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_transmission_selection_algorithm)) {
                /* leaf transmission-selection-algorithm (identityref) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_transmission_selection_algorithm_map_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /interfaces/interface/bridge-port/transmission-selection-algorithm-table
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_if_name Ancestor key leaf 'name' in list 'interface'\n
 * Path: /if:interfaces/if:interface/if:name
 * @return return status for the phase.
 */
status_t u_dot1q_transmission_selection_algorithm_table_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_if_name)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_transmission_selection_algorithm_table_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_transmission_selection_algorithm_table_edit */


/**
 * @brief Get database object callback for leaf address (getcb_fn2_t)\n
 * Path: leaf /interfaces/interface/bridge-port/address\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_if_name Ancestor key leaf 'name' in list 'interface'\n
 * Path: /if:interfaces/if:interface/if:name
 * @return return status of the callback.
 */
status_t u_dot1q_address_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_if_name)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_address_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_address = 0;

    /* add address to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_address,
        v_address,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_address_get */



/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /interfaces/interface/bridge-port
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_if_name Ancestor key leaf 'name' in list 'interface'\n
 * Path: /if:interfaces/if:interface/if:name
 * @return return status for the phase.
 */
status_t u_dot1q_bridge_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_if_name)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_bridge_port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_component_name)) {
                /* leaf component-name (string) */

            } else if (!xml_strcmp(name, y_dot1q_N_pvid)) {
                /* leaf pvid (uint32) */

            } else if (!xml_strcmp(name, y_dot1q_N_default_priority)) {
                /* leaf default-priority (uint8) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_bridge_port_edit */


/**
 * @brief Get database object callback for leaf ports (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/ports\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_ports_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_ports_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint16 v_ports = 0;

    /* add ports to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_ports,
        v_ports,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_ports_get */



/**
 * @brief Get database object callback for leaf up-time (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/up-time\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_up_time_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_up_time_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint32 v_up_time = 0;

    /* add up_time to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_up_time,
        v_up_time,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_up_time_get */



/**
 * @brief Get database object callback for leaf components (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/components\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_components_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_components_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint32 v_components = 0;

    /* add components to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_components,
        v_components,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_components_get */



/**
 * @brief Get database object callback for leaf ports (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/ports\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_ports_1_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_ports_1_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint16 v_ports = 0;

    /* add ports to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_ports,
        v_ports,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_ports_1_get */



/**
 * @brief Get database object callback for leaf-list bridge-port (getcb_fn2_t)\n
 * Path: leaf-list /bridges/bridge/component/bridge-port\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_bridge_port_1_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_bridge_port_1_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get all the instances of this leaf-list and add a val_value_t
     * for each one with the getcb_add_return_val function
     */

    return res;

} /* u_dot1q_bridge_port_1_get */



/**
 * @brief Get database object callback for container capabilities (getcb_fn2_t)\n
 * Path: container /bridges/bridge/component/capabilities\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_capabilities_1_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_capabilities_1_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed
     */
    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_dot1q_N_extended_filtering)) {
            /* leaf extended-filtering (boolean) */

        } else if (!xml_strcmp(name, y_dot1q_N_traffic_classes)) {
            /* leaf traffic-classes (boolean) */

        } else if (!xml_strcmp(name, y_dot1q_N_static_entry_individual_port)) {
            /* leaf static-entry-individual-port (boolean) */

        } else if (!xml_strcmp(name, y_dot1q_N_ivl_capable)) {
            /* leaf ivl-capable (boolean) */

        } else if (!xml_strcmp(name, y_dot1q_N_svl_capable)) {
            /* leaf svl-capable (boolean) */

        } else if (!xml_strcmp(name, y_dot1q_N_hybrid_capable)) {
            /* leaf hybrid-capable (boolean) */

        } else if (!xml_strcmp(name, y_dot1q_N_configurable_pvid_tagging)) {
            /* leaf configurable-pvid-tagging (boolean) */

        } else if (!xml_strcmp(name, y_dot1q_N_local_vlan_capable)) {
            /* leaf local-vlan-capable (boolean) */

        }
    }

    return res;

} /* u_dot1q_capabilities_1_get */



/**
 * @brief Get database object callback for leaf size (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/filtering-database/size\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_size_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_size_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint32 v_size = 0;

    /* add size to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_size,
        v_size,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_size_get */



/**
 * @brief Get database object callback for leaf static-entries (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/filtering-database/static-entries\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_static_entries_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_static_entries_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint32 v_static_entries = 0;

    /* add static_entries to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_static_entries,
        v_static_entries,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_static_entries_get */



/**
 * @brief Get database object callback for leaf dynamic-entries (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/filtering-database/dynamic-entries\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_dynamic_entries_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_dynamic_entries_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint32 v_dynamic_entries = 0;

    /* add dynamic_entries to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_dynamic_entries,
        v_dynamic_entries,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_dynamic_entries_get */



/**
 * @brief Get database object callback for leaf static-vlan-registration-entries (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/filtering-database/static-vlan-registration-entries\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_static_vlan_registration_entries_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_static_vlan_registration_entries_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint32 v_static_vlan_registration_entries = 0;

    /* add static_vlan_registration_entries to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_static_vlan_registration_entries,
        v_static_vlan_registration_entries,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_static_vlan_registration_entries_get */



/**
 * @brief Get database object callback for leaf dynamic-vlan-registration-entries (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/filtering-database/dynamic-vlan-registration-entries\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_dynamic_vlan_registration_entries_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_dynamic_vlan_registration_entries_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint32 v_dynamic_vlan_registration_entries = 0;

    /* add dynamic_vlan_registration_entries to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_dynamic_vlan_registration_entries,
        v_dynamic_vlan_registration_entries,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_dynamic_vlan_registration_entries_get */



#ifdef u_dot1q_F_extended_filtering_services

/**
 * @brief Get database object callback for leaf mac-address-registration-entries (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/filtering-database/mac-address-registration-entries\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_mac_address_registration_entries_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_mac_address_registration_entries_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint32 v_mac_address_registration_entries = 0;

    /* add mac_address_registration_entries to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_mac_address_registration_entries,
        v_mac_address_registration_entries,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_mac_address_registration_entries_get */


#endif /* u_dot1q_F_extended_filtering_services */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-filtering-entries/static-filtering-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id Ancestor key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids Ancestor key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_3 Ancestor key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:address
 * @param k_dot1q_port_ref Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_static_filtering_entries_1_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id,
    const xmlChar *k_dot1q_vids,
    const xmlChar *k_dot1q_address_3,
    uint32 k_dot1q_port_ref)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_static_filtering_entries_1_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_control_element)) {
                /* leaf control-element (enumeration) */

            } else if (!xml_strcmp(name, y_dot1q_N_connection_identifier)) {
                /* leaf connection-identifier (uint32) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_static_filtering_entries_1_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id Ancestor key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids Ancestor key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_3 Ancestor key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:address
 * @param k_dot1q_port_ref Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_static_vlan_registration_entries_2_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id,
    const xmlChar *k_dot1q_vids,
    const xmlChar *k_dot1q_address_3,
    uint32 k_dot1q_port_ref)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_static_vlan_registration_entries_2_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_registrar_admin_control)) {
                /* leaf registrar-admin-control (enumeration) */

            } else if (!xml_strcmp(name, y_dot1q_N_vlan_transmitted)) {
                /* leaf vlan-transmitted (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_static_vlan_registration_entries_2_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id Ancestor key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids Ancestor key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_3 Ancestor key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:address
 * @param k_dot1q_port_ref Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_mac_address_registration_entries_2_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id,
    const xmlChar *k_dot1q_vids,
    const xmlChar *k_dot1q_address_3,
    uint32 k_dot1q_port_ref)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_mac_address_registration_entries_2_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_control_element)) {
                /* leaf control-element (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_mac_address_registration_entries_2_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id Ancestor key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids Ancestor key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_3 Ancestor key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:address
 * @param k_dot1q_port_ref Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_dynamic_vlan_registration_entries_2_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id,
    const xmlChar *k_dot1q_vids,
    const xmlChar *k_dot1q_address_3,
    uint32 k_dot1q_port_ref)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_dynamic_vlan_registration_entries_2_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_control_element)) {
                /* leaf control-element (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_dynamic_vlan_registration_entries_2_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id Ancestor key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids Ancestor key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_3 Ancestor key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:address
 * @param k_dot1q_port_ref Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_dynamic_reservation_entries_1_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id,
    const xmlChar *k_dot1q_vids,
    const xmlChar *k_dot1q_address_3,
    uint32 k_dot1q_port_ref)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_dynamic_reservation_entries_1_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_control_element)) {
                /* leaf control-element (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_dynamic_reservation_entries_1_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id Ancestor key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids Ancestor key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_3 Ancestor key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:address
 * @param k_dot1q_port_ref Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_dynamic_filtering_entries_1_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id,
    const xmlChar *k_dot1q_vids,
    const xmlChar *k_dot1q_address_3,
    uint32 k_dot1q_port_ref)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_dynamic_filtering_entries_1_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_control_element)) {
                /* leaf control-element (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_dynamic_filtering_entries_1_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/filtering-database/filtering-entry/port-map
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id Ancestor key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids Ancestor key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_3 Ancestor key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:address
 * @param k_dot1q_port_ref Local key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_port_map_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id,
    const xmlChar *k_dot1q_vids,
    const xmlChar *k_dot1q_address_3,
    uint32 k_dot1q_port_ref)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_port_map_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_port_map_edit */


/**
 * @brief Get database object callback for leaf status (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/filtering-database/filtering-entry/status\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id Ancestor key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids Ancestor key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_3 Ancestor key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:address
 * @return return status of the callback.
 */
status_t u_dot1q_status_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id,
    const xmlChar *k_dot1q_vids,
    const xmlChar *k_dot1q_address_3)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_status_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_status = 0;

    /* add status to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_status,
        v_status,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_status_get */



/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/filtering-database/filtering-entry
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id Local key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids Local key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_3 Local key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:address
 * @return return status for the phase.
 */
status_t u_dot1q_filtering_entry_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id,
    const xmlChar *k_dot1q_vids,
    const xmlChar *k_dot1q_address_3)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_filtering_entry_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_entry_type)) {
                /* leaf entry-type (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_filtering_entry_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-filtering-entries/static-filtering-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id_1 Ancestor key leaf 'database-id' in list 'vlan-registration-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:database-id
 * @param k_dot1q_vids_1 Ancestor key leaf 'vids' in list 'vlan-registration-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:vids
 * @param k_dot1q_port_ref_1 Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_static_filtering_entries_3_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id_1,
    const xmlChar *k_dot1q_vids_1,
    uint32 k_dot1q_port_ref_1)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_static_filtering_entries_3_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_control_element)) {
                /* leaf control-element (enumeration) */

            } else if (!xml_strcmp(name, y_dot1q_N_connection_identifier)) {
                /* leaf connection-identifier (uint32) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_static_filtering_entries_3_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id_1 Ancestor key leaf 'database-id' in list 'vlan-registration-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:database-id
 * @param k_dot1q_vids_1 Ancestor key leaf 'vids' in list 'vlan-registration-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:vids
 * @param k_dot1q_port_ref_1 Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_static_vlan_registration_entries_4_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id_1,
    const xmlChar *k_dot1q_vids_1,
    uint32 k_dot1q_port_ref_1)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_static_vlan_registration_entries_4_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_registrar_admin_control)) {
                /* leaf registrar-admin-control (enumeration) */

            } else if (!xml_strcmp(name, y_dot1q_N_vlan_transmitted)) {
                /* leaf vlan-transmitted (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_static_vlan_registration_entries_4_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id_1 Ancestor key leaf 'database-id' in list 'vlan-registration-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:database-id
 * @param k_dot1q_vids_1 Ancestor key leaf 'vids' in list 'vlan-registration-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:vids
 * @param k_dot1q_port_ref_1 Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_mac_address_registration_entries_4_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id_1,
    const xmlChar *k_dot1q_vids_1,
    uint32 k_dot1q_port_ref_1)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_mac_address_registration_entries_4_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_control_element)) {
                /* leaf control-element (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_mac_address_registration_entries_4_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id_1 Ancestor key leaf 'database-id' in list 'vlan-registration-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:database-id
 * @param k_dot1q_vids_1 Ancestor key leaf 'vids' in list 'vlan-registration-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:vids
 * @param k_dot1q_port_ref_1 Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_dynamic_vlan_registration_entries_4_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id_1,
    const xmlChar *k_dot1q_vids_1,
    uint32 k_dot1q_port_ref_1)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_dynamic_vlan_registration_entries_4_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_control_element)) {
                /* leaf control-element (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_dynamic_vlan_registration_entries_4_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id_1 Ancestor key leaf 'database-id' in list 'vlan-registration-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:database-id
 * @param k_dot1q_vids_1 Ancestor key leaf 'vids' in list 'vlan-registration-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:vids
 * @param k_dot1q_port_ref_1 Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_dynamic_reservation_entries_3_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id_1,
    const xmlChar *k_dot1q_vids_1,
    uint32 k_dot1q_port_ref_1)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_dynamic_reservation_entries_3_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_control_element)) {
                /* leaf control-element (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_dynamic_reservation_entries_3_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id_1 Ancestor key leaf 'database-id' in list 'vlan-registration-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:database-id
 * @param k_dot1q_vids_1 Ancestor key leaf 'vids' in list 'vlan-registration-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:vids
 * @param k_dot1q_port_ref_1 Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_dynamic_filtering_entries_3_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id_1,
    const xmlChar *k_dot1q_vids_1,
    uint32 k_dot1q_port_ref_1)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_dynamic_filtering_entries_3_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_control_element)) {
                /* leaf control-element (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_dynamic_filtering_entries_3_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id_1 Ancestor key leaf 'database-id' in list 'vlan-registration-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:database-id
 * @param k_dot1q_vids_1 Ancestor key leaf 'vids' in list 'vlan-registration-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:vids
 * @param k_dot1q_port_ref_1 Local key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_port_map_1_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id_1,
    const xmlChar *k_dot1q_vids_1,
    uint32 k_dot1q_port_ref_1)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_port_map_1_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_port_map_1_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/filtering-database/vlan-registration-entry
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id_1 Local key leaf 'database-id' in list 'vlan-registration-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:database-id
 * @param k_dot1q_vids_1 Local key leaf 'vids' in list 'vlan-registration-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:vids
 * @return return status for the phase.
 */
status_t u_dot1q_vlan_registration_entry_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id_1,
    const xmlChar *k_dot1q_vids_1)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_vlan_registration_entry_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_entry_type)) {
                /* leaf entry-type (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_vlan_registration_entry_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status for the phase.
 */
status_t u_dot1q_filtering_database_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_filtering_database_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_aging_time)) {
                /* leaf aging-time (uint32) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_filtering_database_edit */


/**
 * @brief Get database object callback for leaf size (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/permanent-database/size\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_size_1_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_size_1_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint32 v_size = 0;

    /* add size to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_size,
        v_size,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_size_1_get */



/**
 * @brief Get database object callback for leaf static-entries (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/permanent-database/static-entries\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_static_entries_1_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_static_entries_1_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint32 v_static_entries = 0;

    /* add static_entries to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_static_entries,
        v_static_entries,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_static_entries_1_get */



/**
 * @brief Get database object callback for leaf static-vlan-registration-entries (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/permanent-database/static-vlan-registration-entries\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_static_vlan_registration_entries_5_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_static_vlan_registration_entries_5_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint32 v_static_vlan_registration_entries = 0;

    /* add static_vlan_registration_entries to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_static_vlan_registration_entries,
        v_static_vlan_registration_entries,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_static_vlan_registration_entries_5_get */



/**
 * @brief Get database object callback for leaf status (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/permanent-database/filtering-entry/status\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id_2 Ancestor key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids_2 Ancestor key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_4 Ancestor key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:address
 * @return return status of the callback.
 */
status_t u_dot1q_status_1_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id_2,
    const xmlChar *k_dot1q_vids_2,
    const xmlChar *k_dot1q_address_4)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_status_1_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_status = 0;

    /* add status to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_status,
        v_status,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_status_1_get */



/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-filtering-entries/static-filtering-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id_2 Ancestor key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids_2 Ancestor key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_4 Ancestor key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:address
 * @param k_dot1q_port_ref_2 Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_static_filtering_entries_5_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id_2,
    const xmlChar *k_dot1q_vids_2,
    const xmlChar *k_dot1q_address_4,
    uint32 k_dot1q_port_ref_2)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_static_filtering_entries_5_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_control_element)) {
                /* leaf control-element (enumeration) */

            } else if (!xml_strcmp(name, y_dot1q_N_connection_identifier)) {
                /* leaf connection-identifier (uint32) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_static_filtering_entries_5_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id_2 Ancestor key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids_2 Ancestor key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_4 Ancestor key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:address
 * @param k_dot1q_port_ref_2 Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_static_vlan_registration_entries_7_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id_2,
    const xmlChar *k_dot1q_vids_2,
    const xmlChar *k_dot1q_address_4,
    uint32 k_dot1q_port_ref_2)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_static_vlan_registration_entries_7_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_registrar_admin_control)) {
                /* leaf registrar-admin-control (enumeration) */

            } else if (!xml_strcmp(name, y_dot1q_N_vlan_transmitted)) {
                /* leaf vlan-transmitted (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_static_vlan_registration_entries_7_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id_2 Ancestor key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids_2 Ancestor key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_4 Ancestor key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:address
 * @param k_dot1q_port_ref_2 Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_mac_address_registration_entries_6_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id_2,
    const xmlChar *k_dot1q_vids_2,
    const xmlChar *k_dot1q_address_4,
    uint32 k_dot1q_port_ref_2)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_mac_address_registration_entries_6_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_control_element)) {
                /* leaf control-element (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_mac_address_registration_entries_6_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id_2 Ancestor key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids_2 Ancestor key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_4 Ancestor key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:address
 * @param k_dot1q_port_ref_2 Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_dynamic_vlan_registration_entries_6_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id_2,
    const xmlChar *k_dot1q_vids_2,
    const xmlChar *k_dot1q_address_4,
    uint32 k_dot1q_port_ref_2)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_dynamic_vlan_registration_entries_6_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_control_element)) {
                /* leaf control-element (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_dynamic_vlan_registration_entries_6_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id_2 Ancestor key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids_2 Ancestor key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_4 Ancestor key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:address
 * @param k_dot1q_port_ref_2 Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_dynamic_reservation_entries_5_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id_2,
    const xmlChar *k_dot1q_vids_2,
    const xmlChar *k_dot1q_address_4,
    uint32 k_dot1q_port_ref_2)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_dynamic_reservation_entries_5_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_control_element)) {
                /* leaf control-element (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_dynamic_reservation_entries_5_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id_2 Ancestor key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids_2 Ancestor key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_4 Ancestor key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:address
 * @param k_dot1q_port_ref_2 Ancestor key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_dynamic_filtering_entries_5_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id_2,
    const xmlChar *k_dot1q_vids_2,
    const xmlChar *k_dot1q_address_4,
    uint32 k_dot1q_port_ref_2)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_dynamic_filtering_entries_5_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_control_element)) {
                /* leaf control-element (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_dynamic_filtering_entries_5_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/permanent-database/filtering-entry/port-map
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id_2 Ancestor key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids_2 Ancestor key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_4 Ancestor key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:address
 * @param k_dot1q_port_ref_2 Local key leaf 'port-ref' in list 'port-map'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:port-ref
 * @return return status for the phase.
 */
status_t u_dot1q_port_map_2_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id_2,
    const xmlChar *k_dot1q_vids_2,
    const xmlChar *k_dot1q_address_4,
    uint32 k_dot1q_port_ref_2)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_port_map_2_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_port_map_2_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/permanent-database/filtering-entry
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_database_id_2 Local key leaf 'database-id' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:database-id
 * @param k_dot1q_vids_2 Local key leaf 'vids' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:vids
 * @param k_dot1q_address_4 Local key leaf 'address' in list 'filtering-entry'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:address
 * @return return status for the phase.
 */
status_t u_dot1q_filtering_entry_1_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_database_id_2,
    const xmlChar *k_dot1q_vids_2,
    const xmlChar *k_dot1q_address_4)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_filtering_entry_1_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_filtering_entry_1_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/permanent-database
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status for the phase.
 */
status_t u_dot1q_permanent_database_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_permanent_database_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_permanent_database_edit */


/**
 * @brief Get database object callback for leaf version (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/bridge-vlan/version\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_version_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_version_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint16 v_version = 0;

    /* add version to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_version,
        v_version,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_version_get */



/**
 * @brief Get database object callback for leaf max-vids (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/bridge-vlan/max-vids\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_max_vids_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_max_vids_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint16 v_max_vids = 0;

    /* add max_vids to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_max_vids,
        v_max_vids,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_max_vids_get */



/**
 * @brief Get database object callback for leaf override-default-pvid (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/bridge-vlan/override-default-pvid\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_override_default_pvid_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_override_default_pvid_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    boolean v_override_default_pvid = 0;

    /* add override_default_pvid to get2cb return_valQ */
    val_value_t *return_val = agt_make_boolean_leaf(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_override_default_pvid,
        v_override_default_pvid,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_override_default_pvid_get */



#ifdef u_dot1q_F_port_and_protocol_based_vlan

/**
 * @brief Get database object callback for leaf protocol-template (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/bridge-vlan/protocol-template\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_protocol_template_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_protocol_template_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_protocol_template = 0;

    /* add protocol_template to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_protocol_template,
        v_protocol_template,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_protocol_template_get */


#endif /* u_dot1q_F_port_and_protocol_based_vlan */


/**
 * @brief Get database object callback for leaf max-msti (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/bridge-vlan/max-msti\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status of the callback.
 */
status_t u_dot1q_max_msti_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_max_msti_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint16 v_max_msti = 0;

    /* add max_msti to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_max_msti,
        v_max_msti,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_max_msti_get */



/**
 * @brief Get database object callback for leaf-list untagged-ports (getcb_fn2_t)\n
 * Path: leaf-list /bridges/bridge/component/bridge-vlan/vlan/untagged-ports\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_vid_1 Ancestor key leaf 'vid' in list 'vlan'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:vlan/dot1q:vid
 * @return return status of the callback.
 */
status_t u_dot1q_untagged_ports_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_vid_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_untagged_ports_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get all the instances of this leaf-list and add a val_value_t
     * for each one with the getcb_add_return_val function
     */

    return res;

} /* u_dot1q_untagged_ports_get */



/**
 * @brief Get database object callback for leaf-list egress-ports (getcb_fn2_t)\n
 * Path: leaf-list /bridges/bridge/component/bridge-vlan/vlan/egress-ports\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_vid_1 Ancestor key leaf 'vid' in list 'vlan'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:vlan/dot1q:vid
 * @return return status of the callback.
 */
status_t u_dot1q_egress_ports_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_vid_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_egress_ports_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get all the instances of this leaf-list and add a val_value_t
     * for each one with the getcb_add_return_val function
     */

    return res;

} /* u_dot1q_egress_ports_get */



/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/bridge-vlan/vlan
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_vid_1 Local key leaf 'vid' in list 'vlan'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:vlan/dot1q:vid
 * @return return status for the phase.
 */
status_t u_dot1q_vlan_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_vid_1)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_vlan_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_name)) {
                /* leaf name (string) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_vlan_edit */


#ifdef u_dot1q_F_port_and_protocol_based_vlan

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format/llc-other/dsap-ssap-pairs
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_db_index Ancestor key leaf 'db-index' in list 'protocol-group-database'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:protocol-group-database/dot1q:db-index
 * @return return status for the phase.
 */
status_t u_dot1q_dsap_ssap_pairs_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint16 k_dot1q_db_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_dsap_ssap_pairs_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_llc_address)) {
                /* leaf llc-address (string) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_dsap_ssap_pairs_edit */

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/bridge-vlan/protocol-group-database
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_db_index Local key leaf 'db-index' in list 'protocol-group-database'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:protocol-group-database/dot1q:db-index
 * @return return status for the phase.
 */
status_t u_dot1q_protocol_group_database_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint16 k_dot1q_db_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_protocol_group_database_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_frame_format_type)) {
                /* leaf frame-format-type (enumeration) */

            } else if (!xml_strcmp(name, y_dot1q_N_ethertype)) {
                /* leaf ethertype (string) */

            } else if (!xml_strcmp(name, y_dot1q_N_protocol_id)) {
                /* leaf protocol-id (string) */

            } else if (!xml_strcmp(name, y_dot1q_N_group_id)) {
                /* leaf group-id (uint32) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_protocol_group_database_edit */
#endif /* u_dot1q_F_port_and_protocol_based_vlan */


/**
 * @brief Get database object callback for leaf fid (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/bridge-vlan/vid-to-fid-allocation/fid\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_vids_3 Ancestor key leaf 'vids' in list 'vid-to-fid-allocation'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:vid-to-fid-allocation/dot1q:vids
 * @return return status of the callback.
 */
status_t u_dot1q_fid_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    const xmlChar *k_dot1q_vids_3)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_fid_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint32 v_fid = 0;

    /* add fid to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_fid,
        v_fid,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_fid_get */



/**
 * @brief Get database object callback for leaf allocation-type (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/bridge-vlan/vid-to-fid-allocation/allocation-type\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_vids_3 Ancestor key leaf 'vids' in list 'vid-to-fid-allocation'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:vid-to-fid-allocation/dot1q:vids
 * @return return status of the callback.
 */
status_t u_dot1q_allocation_type_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    const xmlChar *k_dot1q_vids_3)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_allocation_type_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_allocation_type = 0;

    /* add allocation_type to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_allocation_type,
        v_allocation_type,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_allocation_type_get */



/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/bridge-vlan/vid-to-fid-allocation
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_vids_3 Local key leaf 'vids' in list 'vid-to-fid-allocation'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:vid-to-fid-allocation/dot1q:vids
 * @return return status for the phase.
 */
status_t u_dot1q_vid_to_fid_allocation_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    const xmlChar *k_dot1q_vids_3)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_vid_to_fid_allocation_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_vid_to_fid_allocation_edit */


/**
 * @brief Get database object callback for leaf allocation-type (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/bridge-vlan/fid-to-vid-allocation/allocation-type\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_fid_1 Ancestor key leaf 'fid' in list 'fid-to-vid-allocation'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:fid-to-vid-allocation/dot1q:fid
 * @return return status of the callback.
 */
status_t u_dot1q_allocation_type_1_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_fid_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_allocation_type_1_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_allocation_type = 0;

    /* add allocation_type to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_dot1q_M_dot1q,
        y_dot1q_N_allocation_type,
        v_allocation_type,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_dot1q_allocation_type_1_get */



/**
 * @brief Get database object callback for leaf-list vid (getcb_fn2_t)\n
 * Path: leaf-list /bridges/bridge/component/bridge-vlan/fid-to-vid-allocation/vid\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_fid_1 Ancestor key leaf 'fid' in list 'fid-to-vid-allocation'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:fid-to-vid-allocation/dot1q:fid
 * @return return status of the callback.
 */
status_t u_dot1q_vid_2_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_fid_1)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_vid_2_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get all the instances of this leaf-list and add a val_value_t
     * for each one with the getcb_add_return_val function
     */

    return res;

} /* u_dot1q_vid_2_get */



/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/bridge-vlan/fid-to-vid-allocation
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_fid_1 Local key leaf 'fid' in list 'fid-to-vid-allocation'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:fid-to-vid-allocation/dot1q:fid
 * @return return status for the phase.
 */
status_t u_dot1q_fid_to_vid_allocation_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_fid_1)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_fid_to_vid_allocation_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_fid_to_vid_allocation_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/bridge-vlan/vid-to-fid
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_vid_3 Local key leaf 'vid' in list 'vid-to-fid'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:vid-to-fid/dot1q:vid
 * @return return status for the phase.
 */
status_t u_dot1q_vid_to_fid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_vid_3)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_vid_to_fid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_fid)) {
                /* leaf fid (uint32) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_vid_to_fid_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/bridge-vlan
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status for the phase.
 */
status_t u_dot1q_bridge_vlan_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_bridge_vlan_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_bridge_vlan_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/bridge-mst/fid-to-mstid
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_fid_3 Local key leaf 'fid' in list 'fid-to-mstid'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-mst/dot1q:fid-to-mstid/dot1q:fid
 * @return return status for the phase.
 */
status_t u_dot1q_fid_to_mstid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    uint32 k_dot1q_fid_3)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_fid_to_mstid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_mstid)) {
                /* leaf mstid (uint32) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_fid_to_mstid_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/bridge-mst/fid-to-mstid-allocation
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @param k_dot1q_fids Local key leaf 'fids' in list 'fid-to-mstid-allocation'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-mst/dot1q:fid-to-mstid-allocation/dot1q:fids
 * @return return status for the phase.
 */
status_t u_dot1q_fid_to_mstid_allocation_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1,
    const xmlChar *k_dot1q_fids)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_fid_to_mstid_allocation_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_mstid)) {
                /* leaf mstid (uint32) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_fid_to_mstid_allocation_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/bridge-mst
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Ancestor key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status for the phase.
 */
status_t u_dot1q_bridge_mst_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_bridge_mst_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_mstid)) {
                /* leaf-list mstid (uint32) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_bridge_mst_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Ancestor key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @param k_dot1q_name_1 Local key leaf 'name' in list 'component'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:name
 * @return return status for the phase.
 */
status_t u_dot1q_component_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name,
    const xmlChar *k_dot1q_name_1)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_component_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_id)) {
                /* leaf id (uint32) */

            } else if (!xml_strcmp(name, y_dot1q_N_type)) {
                /* leaf type (identityref) */

            } else if (!xml_strcmp(name, y_dot1q_N_address)) {
                /* leaf address (string) */

            } else if (!xml_strcmp(name, y_dot1q_N_traffic_class_enabled)) {
                /* leaf traffic-class-enabled (boolean) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_component_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_dot1q_name Local key leaf 'name' in list 'bridge'\n
 * Path: /dot1q:bridges/dot1q:bridge/dot1q:name
 * @return return status for the phase.
 */
status_t u_dot1q_bridge_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_dot1q_name)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_bridge_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_dot1q_N_address)) {
                /* leaf address (string) */

            } else if (!xml_strcmp(name, y_dot1q_N_bridge_type)) {
                /* leaf bridge-type (identityref) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_bridge_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
status_t u_dot1q_bridges_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_dot1q_bridges_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_dot1q_bridges_edit */


/**
 * @brief Phase 1: Initialize the ieee802-dot1q-bridge server instrumentation library.
 *
 * Called by server when module is loaded.
 *
 * @param modname requested module name to load
 * @param revision requested revision date of the module to load.
 * This may be NULL if the module has no revision statements.
 * @return return status. An error will cause the module load to fail.
 */
status_t u_ieee802_dot1q_bridge_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ieee802_dot1q_bridge_init");
    }

    ncx_module_t *ieee802_dot1q_bridge_mod = NULL;

    ieee802_dot1q_bridge_mod = ncx_find_module(modname, revision);
    if (ieee802_dot1q_bridge_mod == NULL) {
        return ERR_NCX_OPERATION_FAILED;
    }

    /* put your module initialization code here */

    return res;

} /* u_ieee802_dot1q_bridge_init */


/**
 * @brief Phase 2: Initialize the ieee802-dot1q-bridge server instrumentation library.
 *
 * SIL init phase 2: non-config data structures.
 * Called after running config is loaded.
 *
 * @return return status. An error will cause the
 * server initialization to fail.
 */
status_t u_ieee802_dot1q_bridge_init2 (void)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ieee802_dot1q_bridge_init2");
    }


    /* put your init2 code here */

    return res;

} /* u_ieee802_dot1q_bridge_init2 */


/**
 * @brief Cleanup the ieee802-dot1q-bridge server instrumentation library.
 *
 * Called by server when module is unloaded.
 *
 */
void u_ieee802_dot1q_bridge_cleanup (void)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ieee802_dot1q_bridge_cleanup");
    }


    /* put your cleanup code here */

} /* u_ieee802_dot1q_bridge_cleanup */


 /** @} */

/* END SIL-SA u_ieee802-dot1q-bridge.c */
