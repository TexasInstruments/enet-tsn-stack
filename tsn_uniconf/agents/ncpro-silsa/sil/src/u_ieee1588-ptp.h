/*
 * Copyright (c) 2023 Texas Instruments Incorporated
 * Copyright (c) 2023 Excelfore Corporation (https://excelfore.com)
 *
 * All rights reserved not granted herein.
 * Limited License.
 *
 * Texas Instruments Incorporated grants a world-wide, royalty-free,
 * non-exclusive license under copyrights and patents it now or hereafter
 * owns or controls to make, have made, use, import, offer to sell and sell ("Utilize")
 * this software subject to the terms herein. With respect to the foregoing patent
 * license, such license is granted solely to the extent that any such patent is necessary
 * to Utilize the software alone. The patent license shall not apply to any combinations which
 * include this software, other than combinations with devices manufactured by or for TI ("TI Devices").
 * No hardware patent is licensed hereunder.
 *
 * Redistributions must preserve existing copyright notices and reproduce this license (including the
 * above copyright notice and the disclaimer and (if applicable) source code license limitations below)
 * in the documentation and/or other materials provided with the distribution
 *
 * Redistribution and use in binary form, without modification, are permitted provided that the following
 * conditions are met:
 *
 * * No reverse engineering, decompilation, or disassembly of this software is permitted with respect to any
 * software provided in binary form.
 * * any redistribution and use are licensed by TI for use only with TI Devices.
 * * Nothing shall obligate TI to provide you with source code for the software licensed and provided to you in object code.
 *
 * If software source code is provided to you, modification and redistribution of the source code are permitted
 * provided that the following conditions are met:
 *
 * * any redistribution and use of the source code, including any resulting derivative works, are licensed by
 * TI for use only with TI Devices.
 * * any redistribution and use of any object code compiled from the source code and any resulting derivative
 * works, are licensed by TI for use only with TI Devices.
 *
 * Neither the name of Texas Instruments Incorporated nor the names of its suppliers may be used to endorse or
 * promote products derived from this software without specific prior written permission.
 *
 * DISCLAIMER.
 *
 * THIS SOFTWARE IS PROVIDED BY TI AND TI"S LICENSORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TI AND TI"S LICENSORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _H_u_ieee1588_ptp
#define _H_u_ieee1588_ptp
/*
 * Copyright (c) 2008 - 2012, Andy Bierman, All Rights Reserved.
 * Copyright (c) 2012 - 2022, YumaWorks, Inc., All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

/**
 * @file u_ieee1588-ptp.h
 * @brief User SIL-SA header for module ieee1588-ptp
 *

*** Generated by yangdump-sdk 21.10-12

<pre>

    User SIL-SA header
    bundle x4ucsilsa
    module ieee1588-ptp
    revision 2022-08-30
    prefix ptp
    namespace urn:ieee:std:1588:yang:ieee1588-ptp
    organization IEEE 1588 Working Group
    Created: 2023-03-29T06:45:58Z

Online Developer Manual:
https://www.yumaworks.com/pub/21.10/dev/yumapro-dev-manual.html

    CLI parameters:
        defnames true
        deviation excelfore-interfaces
        deviation excelfore-gptp
        format uh
        indent 4
        module ietf-interfaces
        module ieee802-dot1q-bridge
        module ieee802-dot1q-tsn-config-uni
        module excelfore-interfaces
        module ieee1588-ptp
        module ieee802-dot1as-ptp
        module excelfore-gptp
        sil-bundle x4ucsilsa
        sil-edit2
        sil-get2
        sil-include tsn_uniconf/yangs/yang_db_access.h
        sil-include tsn_uniconf/yangs/yang_modules.h
        sil-sa
        unified true
</pre>

 */


/* Feature ieee1588-ptp:fault-log
 * Comment out #define to disable */
#define u_ptp_F_fault_log 1

/* Feature ieee1588-ptp:unicast-negotiation
 * Comment out #define to disable */
#define u_ptp_F_unicast_negotiation 1

/* Feature ieee1588-ptp:path-trace
 * Comment out #define to disable */
#define u_ptp_F_path_trace 1

/* Feature ieee1588-ptp:alternate-timescale
 * Comment out #define to disable */
#define u_ptp_F_alternate_timescale 1

/* Feature ieee1588-ptp:holdover-upgrade
 * Comment out #define to disable */
#define u_ptp_F_holdover_upgrade 1

/* Feature ieee1588-ptp:cmlds
 * Comment out #define to disable */
#define u_ptp_F_cmlds 1

/* Feature ieee1588-ptp:timestamp-correction
 * Comment out #define to disable */
#define u_ptp_F_timestamp_correction 1

/* Feature ieee1588-ptp:asymmetry-correction
 * Comment out #define to disable */
#define u_ptp_F_asymmetry_correction 1

/* Feature ieee1588-ptp:slave-monitoring
 * Comment out #define to disable */
#define u_ptp_F_slave_monitoring 1

/* Feature ieee1588-ptp:enhanced-metrics
 * Comment out #define to disable */
#define u_ptp_F_enhanced_metrics 1

/* Feature ieee1588-ptp:grandmaster-cluster
 * Comment out #define to disable */
#define u_ptp_F_grandmaster_cluster 1

/* Feature ieee1588-ptp:alternate-master
 * Comment out #define to disable */
#define u_ptp_F_alternate_master 1

/* Feature ieee1588-ptp:unicast-discovery
 * Comment out #define to disable */
#define u_ptp_F_unicast_discovery 1

/* Feature ieee1588-ptp:acceptable-master
 * Comment out #define to disable */
#define u_ptp_F_acceptable_master 1

/* Feature ieee1588-ptp:external-port-config
 * Comment out #define to disable */
#define u_ptp_F_external_port_config 1

/* Feature ieee1588-ptp:performance-monitoring
 * Comment out #define to disable */
#define u_ptp_F_performance_monitoring 1

/* Feature ieee1588-ptp:l1-sync
 * Comment out #define to disable */
#define u_ptp_F_l1_sync 1

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_cb.h"
#include "dlq.h"
#include "ncxtypes.h"
#include "op.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "y_ieee1588-ptp.h"
#include "u_ietf-interfaces.h"
#include "u_ieee802-dot1q-bridge.h"
#include "u_ieee802-dot1q-tsn-config-uni.h"
#include "u_excelfore-interfaces.h"
#include "u_ieee802-dot1as-ptp.h"
#include "u_excelfore-gptp.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @addtogroup yang-library YANG Library
 *
 * Collection of modules supported by the server.
 * Generated by yangdump-sdk.
 */



/**
 * @addtogroup silsa-x4ucsilsa-ieee1588-ptp Module ieee1588-ptp in Bundle x4ucsilsa
 * @ingroup silsa-x4ucsilsa
 *
 * @{
 *
 * YANG instrumentation library.
 * Generated by yangdump-sdk.
 */



/* container /ptp/instances/instance/default-ds/clock-quality */
typedef struct y_ptp_T_clock_quality_ {
    val_idref_t *v_clock_class;
    val_idref_t *v_clock_accuracy;
    uint16 v_offset_scaled_log_variance;
} y_ptp_T_clock_quality;

/* container /ptp/instances/instance/default-ds/current-time */
typedef struct y_ptp_T_current_time_ {
    uint64 v_seconds_field;
    uint32 v_nanoseconds_field;
} y_ptp_T_current_time;

/* container /ptp/instances/instance/default-ds */
typedef struct y_ptp_T_default_ds_ {
    xmlChar *v_clock_identity;
    uint16 v_number_ports;
    y_ptp_T_clock_quality v_clock_quality;
    uint8 v_priority1;
    uint8 v_priority2;
    uint8 v_domain_number;
    boolean v_slave_only;
    uint16 v_sdo_id;
    y_ptp_T_current_time v_current_time;

#ifdef u_ptp_F_external_port_config
    boolean v_external_port_config_enable;
#endif /* u_ptp_F_external_port_config */
    uint8 v_max_steps_removed;
    boolean ieee802_dot1as_ptp_gm_capable;
    int16 ieee802_dot1as_ptp_current_utc_offset;
    boolean ieee802_dot1as_ptp_current_utc_offset_valid;
    boolean ieee802_dot1as_ptp_leap59;
    boolean ieee802_dot1as_ptp_leap61;
    boolean ieee802_dot1as_ptp_time_traceable;
    boolean ieee802_dot1as_ptp_frequency_traceable;
    boolean ieee802_dot1as_ptp_ptp_timescale;
    val_idref_t *ieee802_dot1as_ptp_time_source;
} y_ptp_T_default_ds;

/* container /ptp/instances/instance/current-ds */
typedef struct y_ptp_T_current_ds_ {
    uint16 v_steps_removed;
    int64 v_offset_from_master;
    int64 v_mean_delay;
    xmlChar *ieee802_dot1as_ptp_last_gm_phase_change;
    xmlChar *ieee802_dot1as_ptp_last_gm_freq_change;
    uint16 ieee802_dot1as_ptp_gm_timebase_indicator;
    uint32 ieee802_dot1as_ptp_time_of_last_freq_change;
} y_ptp_T_current_ds;

/* container /ptp/instances/instance/parent-ds/parent-port-identity */
typedef struct y_ptp_T_parent_port_identity_ {
    xmlChar *v_clock_identity;
    uint16 v_port_number;
} y_ptp_T_parent_port_identity;

/* container /ptp/instances/instance/parent-ds/grandmaster-clock-quality */
typedef struct y_ptp_T_grandmaster_clock_quality_ {
    val_idref_t *v_clock_class;
    val_idref_t *v_clock_accuracy;
    uint16 v_offset_scaled_log_variance;
} y_ptp_T_grandmaster_clock_quality;

/* container /ptp/instances/instance/parent-ds/protocol-address */
typedef struct y_ptp_T_protocol_address_ {
    val_idref_t *v_network_protocol;
    uint16 v_address_length;
    xmlChar *v_address_field;
} y_ptp_T_protocol_address;

/* container /ptp/instances/instance/parent-ds */
typedef struct y_ptp_T_parent_ds_ {
    y_ptp_T_parent_port_identity v_parent_port_identity;
    xmlChar *v_grandmaster_identity;
    y_ptp_T_grandmaster_clock_quality v_grandmaster_clock_quality;
    uint8 v_grandmaster_priority1;
    uint8 v_grandmaster_priority2;
    y_ptp_T_protocol_address v_protocol_address;
} y_ptp_T_parent_ds;

/* container /ptp/instances/instance/time-properties-ds */
typedef struct y_ptp_T_time_properties_ds_ {
    int16 v_current_utc_offset;
    boolean v_current_utc_offset_valid;
    boolean v_leap59;
    boolean v_leap61;
    boolean v_time_traceable;
    boolean v_frequency_traceable;
    boolean v_ptp_timescale;
    val_idref_t *v_time_source;
} y_ptp_T_time_properties_ds;

/* container /ptp/instances/instance/fault-log-ds/fault-record-list/time */
typedef struct y_ptp_T_time_ {
    uint64 v_seconds_field;
    uint32 v_nanoseconds_field;
} y_ptp_T_time;

/* list /ptp/instances/instance/fault-log-ds/fault-record-list */
typedef struct y_ptp_T_fault_record_list_ {
    dlq_hdr_t qhdr;
    y_ptp_T_time v_time;
    xmlChar *v_severity;
    xmlChar *v_name;
    xmlChar *v_value;
    xmlChar *v_description;
} y_ptp_T_fault_record_list;

/* container /ptp/instances/instance/fault-log-ds/reset/input */
typedef struct y_ptp_T_input_ {
} y_ptp_T_input;

/* container /ptp/instances/instance/fault-log-ds/reset/output */
typedef struct y_ptp_T_output_ {
} y_ptp_T_output;

/* action /ptp/instances/instance/fault-log-ds/reset */
typedef struct y_ptp_T_reset_ {
    y_ptp_T_input v_input;
    y_ptp_T_output v_output;
} y_ptp_T_reset;


#ifdef u_ptp_F_fault_log
/* container /ptp/instances/instance/fault-log-ds */
typedef struct y_ptp_T_fault_log_ds_ {
    uint16 v_number_of_fault_records;
    dlq_hdr_t v_fault_record_list;
    y_ptp_T_reset v_reset;
} y_ptp_T_fault_log_ds;
#endif /* u_ptp_F_fault_log */

/* leaf-list /ptp/instances/instance/path-trace-ds/list */
typedef struct y_ptp_T_list_ {
    dlq_hdr_t qhdr;
    xmlChar *v_list;
} y_ptp_T_list;


#ifdef u_ptp_F_path_trace
/* container /ptp/instances/instance/path-trace-ds */
typedef struct y_ptp_T_path_trace_ds_ {
    dlq_hdr_t v_list;
    boolean v_enable;
} y_ptp_T_path_trace_ds;
#endif /* u_ptp_F_path_trace */

/* list /ptp/instances/instance/alternate-timescale-ds/list */
typedef struct y_ptp_T_list_1_ {
    dlq_hdr_t qhdr;
    uint8 v_key_field;
    boolean v_enable;
    int32 v_current_offset;
    int32 v_jump_seconds;
    uint64 v_time_of_next_jump;
    xmlChar *v_display_name;
} y_ptp_T_list_1;


#ifdef u_ptp_F_alternate_timescale
/* container /ptp/instances/instance/alternate-timescale-ds */
typedef struct y_ptp_T_alternate_timescale_ds_ {
    uint8 v_max_key;
    dlq_hdr_t v_list;
} y_ptp_T_alternate_timescale_ds;
#endif /* u_ptp_F_alternate_timescale */


#ifdef u_ptp_F_holdover_upgrade
/* container /ptp/instances/instance/holdover-upgrade-ds */
typedef struct y_ptp_T_holdover_upgrade_ds_ {
    boolean v_enable;
} y_ptp_T_holdover_upgrade_ds;
#endif /* u_ptp_F_holdover_upgrade */

/* list /ptp/instances/instance/grandmaster-cluster-ds/port-address */
typedef struct y_ptp_T_port_address_ {
    dlq_hdr_t qhdr;
    uint16 v_index;
    val_idref_t *v_network_protocol;
    uint16 v_address_length;
    xmlChar *v_address_field;
} y_ptp_T_port_address;


#ifdef u_ptp_F_grandmaster_cluster
/* container /ptp/instances/instance/grandmaster-cluster-ds */
typedef struct y_ptp_T_grandmaster_cluster_ds_ {
    uint8 v_max_table_size;
    int8 v_log_query_interval;
    dlq_hdr_t v_port_address;
} y_ptp_T_grandmaster_cluster_ds;
#endif /* u_ptp_F_grandmaster_cluster */

/* container /ptp/instances/instance/acceptable-master-ds/list/acceptable-port-identity */
typedef struct y_ptp_T_acceptable_port_identity_ {
    xmlChar *v_clock_identity;
    uint16 v_port_number;
} y_ptp_T_acceptable_port_identity;

/* list /ptp/instances/instance/acceptable-master-ds/list */
typedef struct y_ptp_T_list_2_ {
    dlq_hdr_t qhdr;
    uint8 v_index;
    y_ptp_T_acceptable_port_identity v_acceptable_port_identity;
    uint8 v_alternate_priority1;
} y_ptp_T_list_2;


#ifdef u_ptp_F_acceptable_master
/* container /ptp/instances/instance/acceptable-master-ds */
typedef struct y_ptp_T_acceptable_master_ds_ {
    uint16 v_max_table_size;
    dlq_hdr_t v_list;
} y_ptp_T_acceptable_master_ds;
#endif /* u_ptp_F_acceptable_master */

/* list /ptp/instances/instance/performance-monitoring-ds/record-list */
typedef struct y_ptp_T_record_list_ {
    dlq_hdr_t qhdr;
    uint16 v_index;
    boolean v_measurement_valid;
    boolean v_period_complete;
    uint32 v_pm_time;
    int64 v_average_master_slave_delay;
    int64 v_minimum_master_slave_delay;
    int64 v_maximum_master_slave_delay;
    int64 v_stddev_master_slave_delay;
    int64 v_average_slave_master_delay;
    int64 v_minimum_slave_master_delay;
    int64 v_maximum_slave_master_delay;
    int64 v_stddev_slave_master_delay;
    int64 v_average_mean_path_delay;
    int64 v_minimum_mean_path_delay;
    int64 v_maximum_mean_path_delay;
    int64 v_stddev_mean_path_delay;
    int64 v_average_offset_from_master;
    int64 v_minimum_offset_from_master;
    int64 v_maximum_offset_from_master;
    int64 v_stddev_offset_from_master;
} y_ptp_T_record_list;


#ifdef u_ptp_F_performance_monitoring
/* container /ptp/instances/instance/performance-monitoring-ds */
typedef struct y_ptp_T_performance_monitoring_ds_ {
    boolean v_enable;
    dlq_hdr_t v_record_list;
} y_ptp_T_performance_monitoring_ds;
#endif /* u_ptp_F_performance_monitoring */


#ifdef u_ptp_F_enhanced_metrics
/* container /ptp/instances/instance/enhanced-metrics-ds */
typedef struct y_ptp_T_enhanced_metrics_ds_ {
    boolean v_enable;
} y_ptp_T_enhanced_metrics_ds;
#endif /* u_ptp_F_enhanced_metrics */

/* container /ptp/instances/instance/ports/port/port-ds/port-identity */
typedef struct y_ptp_T_port_identity_ {
    xmlChar *v_clock_identity;
    uint16 v_port_number;
} y_ptp_T_port_identity;

/* container /ptp/instances/instance/ports/port/port-ds */
typedef struct y_ptp_T_port_ds_ {
    y_ptp_T_port_identity v_port_identity;
    int8 v_log_min_delay_req_interval;
    int64 v_mean_link_delay;
    int8 v_log_announce_interval;
    uint8 v_announce_receipt_timeout;
    int8 v_log_sync_interval;
    xmlChar *v_delay_mechanism;
    int8 v_log_min_pdelay_req_interval;
    uint8 v_version_number;
    uint8 v_minor_version_number;
    int64 v_delay_asymmetry;
    boolean v_port_enable;
    boolean ieee802_dot1as_ptp_is_measuring_delay;
    boolean ieee802_dot1as_ptp_as_capable;
    int64 ieee802_dot1as_ptp_mean_link_delay_thresh;
    int32 ieee802_dot1as_ptp_neighbor_rate_ratio;
    int8 ieee802_dot1as_ptp_initial_log_announce_interval;
    int8 ieee802_dot1as_ptp_current_log_announce_interval;
    boolean ieee802_dot1as_ptp_use_mgt_log_announce_interval;
    int8 ieee802_dot1as_ptp_initial_log_sync_interval;
    int8 ieee802_dot1as_ptp_current_log_sync_interval;
    boolean ieee802_dot1as_ptp_use_mgt_log_sync_interval;
    uint8 ieee802_dot1as_ptp_sync_receipt_timeout;
    xmlChar *ieee802_dot1as_ptp_sync_receipt_timeout_interval;
    int8 ieee802_dot1as_ptp_initial_log_pdelay_req_interval;
    int8 ieee802_dot1as_ptp_current_log_pdelay_req_interval;
    boolean ieee802_dot1as_ptp_use_mgt_log_pdelay_req_interval;
    int8 ieee802_dot1as_ptp_mgt_log_pdelay_req_interval;
    int8 ieee802_dot1as_ptp_current_log_gptp_cap_interval;
    boolean ieee802_dot1as_ptp_use_mgt_compute_rate_ratio;
    boolean ieee802_dot1as_ptp_use_mgt_compute_mean_link_delay;
    uint8 ieee802_dot1as_ptp_allowed_lost_responses;
    uint8 ieee802_dot1as_ptp_allowed_faults;
    uint8 ieee802_dot1as_ptp_gptp_cap_receipt_timeout;
    boolean ieee802_dot1as_ptp_one_step_tx_oper;
    boolean ieee802_dot1as_ptp_one_step_receive;
    boolean ieee802_dot1as_ptp_one_step_transmit;
    int8 ieee802_dot1as_ptp_initial_one_step_tx_oper;
    int8 ieee802_dot1as_ptp_current_one_step_tx_oper;
    boolean ieee802_dot1as_ptp_use_mgt_one_step_tx_oper;
    int8 ieee802_dot1as_ptp_mgt_one_step_tx_oper;
    dlq_hdr_t ieee802_dot1as_ptp_pdelay_truncated_timestamps;
} y_ptp_T_port_ds;


#ifdef u_ptp_F_timestamp_correction
/* container /ptp/instances/instance/ports/port/timestamp-correction-port-ds */
typedef struct y_ptp_T_timestamp_correction_port_ds_ {
    int64 v_egress_latency;
    int64 v_ingress_latency;
} y_ptp_T_timestamp_correction_port_ds;
#endif /* u_ptp_F_timestamp_correction */


#ifdef u_ptp_F_asymmetry_correction
/* container /ptp/instances/instance/ports/port/asymmetry-correction-port-ds */
typedef struct y_ptp_T_asymmetry_correction_port_ds_ {
    int64 v_constant_asymmetry;
    int64 v_scaled_delay_coefficient;
    boolean v_enable;
} y_ptp_T_asymmetry_correction_port_ds;
#endif /* u_ptp_F_asymmetry_correction */


#ifdef u_ptp_F_unicast_negotiation
/* container /ptp/instances/instance/ports/port/unicast-negotiation-port-ds */
typedef struct y_ptp_T_unicast_negotiation_port_ds_ {
    boolean v_enable;
} y_ptp_T_unicast_negotiation_port_ds;
#endif /* u_ptp_F_unicast_negotiation */


#ifdef u_ptp_F_alternate_master
/* container /ptp/instances/instance/ports/port/alternate-master-port-ds */
typedef struct y_ptp_T_alternate_master_port_ds_ {
    uint8 v_number_of_alt_masters;
    boolean v_tx_alt_multicast_sync;
    int8 v_log_alt_multicast_sync_interval;
} y_ptp_T_alternate_master_port_ds;
#endif /* u_ptp_F_alternate_master */

/* list /ptp/instances/instance/ports/port/unicast-discovery-port-ds/port-address */
typedef struct y_ptp_T_port_address_1_ {
    dlq_hdr_t qhdr;
    uint16 v_index;
    val_idref_t *v_network_protocol;
    uint16 v_address_length;
    xmlChar *v_address_field;
} y_ptp_T_port_address_1;


#ifdef u_ptp_F_unicast_discovery
/* container /ptp/instances/instance/ports/port/unicast-discovery-port-ds */
typedef struct y_ptp_T_unicast_discovery_port_ds_ {
    uint16 v_max_table_size;
    int8 v_log_query_interval;
    dlq_hdr_t v_port_address;
} y_ptp_T_unicast_discovery_port_ds;
#endif /* u_ptp_F_unicast_discovery */


#ifdef u_ptp_F_acceptable_master
/* container /ptp/instances/instance/ports/port/acceptable-master-port-ds */
typedef struct y_ptp_T_acceptable_master_port_ds_ {
    boolean v_enable;
} y_ptp_T_acceptable_master_port_ds;
#endif /* u_ptp_F_acceptable_master */


#ifdef u_ptp_F_l1_sync
/* container /ptp/instances/instance/ports/port/l1-sync-basic-port-ds */
typedef struct y_ptp_T_l1_sync_basic_port_ds_ {
    boolean v_enabled;
    boolean v_tx_coherent_is_required;
    boolean v_rx_coherent_is_required;
    boolean v_congruent_is_required;
    boolean v_opt_params_enabled;
    int8 v_log_l1sync_interval;
    uint8 v_l1sync_receipt_timeout;
    boolean v_link_alive;
    boolean v_is_tx_coherent;
    boolean v_is_rx_coherent;
    boolean v_is_congruent;
    xmlChar *v_l1sync_state;
    boolean v_peer_tx_coherent_is_required;
    boolean v_peer_rx_coherent_is_required;
    boolean v_peer_congruent_is_required;
    boolean v_peer_is_tx_coherent;
    boolean v_peer_is_rx_coherent;
    boolean v_peer_is_congruent;
} y_ptp_T_l1_sync_basic_port_ds;
#endif /* u_ptp_F_l1_sync */

/* container /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx-timestamp */
typedef struct y_ptp_T_phase_offset_tx_timestamp_ {
    uint64 v_seconds_field;
    uint32 v_nanoseconds_field;
} y_ptp_T_phase_offset_tx_timestamp;

/* container /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx-timestamp */
typedef struct y_ptp_T_frequency_offset_tx_timestamp_ {
    uint64 v_seconds_field;
    uint32 v_nanoseconds_field;
} y_ptp_T_frequency_offset_tx_timestamp;


#ifdef u_ptp_F_l1_sync
/* container /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds */
typedef struct y_ptp_T_l1_sync_opt_params_port_ds_ {
    boolean v_timestamps_corrected_tx;
    boolean v_phase_offset_tx_valid;
    int64 v_phase_offset_tx;
    y_ptp_T_phase_offset_tx_timestamp v_phase_offset_tx_timestamp;
    boolean v_frequency_offset_tx_valid;
    int64 v_frequency_offset_tx;
    y_ptp_T_frequency_offset_tx_timestamp v_frequency_offset_tx_timestamp;
} y_ptp_T_l1_sync_opt_params_port_ds;
#endif /* u_ptp_F_l1_sync */

/* list /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay */
typedef struct y_ptp_T_record_list_peer_delay_ {
    dlq_hdr_t qhdr;
    uint16 v_index;
    uint32 v_pm_time;
    int64 v_average_mean_link_delay;
    int64 v_min_mean_link_delay;
    int64 v_max_mean_link_delay;
    int64 v_stddev_mean_link_delay;
} y_ptp_T_record_list_peer_delay;

/* list /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list */
typedef struct y_ptp_T_record_list_1_ {
    dlq_hdr_t qhdr;
    uint16 v_index;
    uint32 v_pm_time;
    uint32 v_announce_tx;
    uint32 v_announce_rx;
    uint32 v_announce_foreign_rx;
    uint32 v_sync_tx;
    uint32 v_sync_rx;
    uint32 v_follow_up_tx;
    uint32 v_follow_up_rx;
    uint32 v_delay_req_tx;
    uint32 v_delay_req_rx;
    uint32 v_delay_resp_tx;
    uint32 v_delay_resp_rx;
    uint32 v_pdelay_req_tx;
    uint32 v_pdelay_req_rx;
    uint32 v_pdelay_resp_tx;
    uint32 v_pdelay_resp_rx;
    uint32 v_pdelay_resp_follow_up_tx;
    uint32 v_pdelay_resp_follow_up_rx;
} y_ptp_T_record_list_1;


#ifdef u_ptp_F_performance_monitoring
/* container /ptp/instances/instance/ports/port/performance-monitoring-port-ds */
typedef struct y_ptp_T_performance_monitoring_port_ds_ {
    dlq_hdr_t v_record_list_peer_delay;
    dlq_hdr_t v_record_list;
} y_ptp_T_performance_monitoring_port_ds;
#endif /* u_ptp_F_performance_monitoring */


#ifdef u_ptp_F_external_port_config
/* container /ptp/instances/instance/ports/port/external-port-config-port-ds */
typedef struct y_ptp_T_external_port_config_port_ds_ {
    xmlChar *v_desired_state;
} y_ptp_T_external_port_config_port_ds;
#endif /* u_ptp_F_external_port_config */


#ifdef u_ptp_F_slave_monitoring
/* container /ptp/instances/instance/ports/port/slave-monitoring-port-ds */
typedef struct y_ptp_T_slave_monitoring_port_ds_ {
    ncx_list_t v_enable;
    uint8 v_events_per_rx_sync_timing_tlv;
    uint8 v_events_per_rx_sync_computed_tlv;
    uint8 v_events_per_tx_timestamps_tlv;
    uint8 v_tx_event_type;
    uint8 v_rx_sync_timing_tlv_message_m;
    uint8 v_rx_sync_computed_tlv_message_m;
    uint8 v_tx_timestamps_tlv_message_m;
} y_ptp_T_slave_monitoring_port_ds;
#endif /* u_ptp_F_slave_monitoring */

/* list /ptp/instances/instance/ports/port */
typedef struct y_ptp_T_port_ {
    dlq_hdr_t qhdr;
    uint16 v_port_index;
    xmlChar *v_underlying_interface;
    y_ptp_T_port_ds v_port_ds;

#ifdef u_ptp_F_timestamp_correction
    y_ptp_T_timestamp_correction_port_ds v_timestamp_correction_port_ds;
#endif /* u_ptp_F_timestamp_correction */

#ifdef u_ptp_F_asymmetry_correction
    y_ptp_T_asymmetry_correction_port_ds v_asymmetry_correction_port_ds;
#endif /* u_ptp_F_asymmetry_correction */

#ifdef u_ptp_F_unicast_negotiation
    y_ptp_T_unicast_negotiation_port_ds v_unicast_negotiation_port_ds;
#endif /* u_ptp_F_unicast_negotiation */

#ifdef u_ptp_F_alternate_master
    y_ptp_T_alternate_master_port_ds v_alternate_master_port_ds;
#endif /* u_ptp_F_alternate_master */

#ifdef u_ptp_F_unicast_discovery
    y_ptp_T_unicast_discovery_port_ds v_unicast_discovery_port_ds;
#endif /* u_ptp_F_unicast_discovery */

#ifdef u_ptp_F_acceptable_master
    y_ptp_T_acceptable_master_port_ds v_acceptable_master_port_ds;
#endif /* u_ptp_F_acceptable_master */

#ifdef u_ptp_F_l1_sync
    y_ptp_T_l1_sync_basic_port_ds v_l1_sync_basic_port_ds;
#endif /* u_ptp_F_l1_sync */

#ifdef u_ptp_F_l1_sync
    y_ptp_T_l1_sync_opt_params_port_ds v_l1_sync_opt_params_port_ds;
#endif /* u_ptp_F_l1_sync */

#ifdef u_ptp_F_performance_monitoring
    y_ptp_T_performance_monitoring_port_ds v_performance_monitoring_port_ds;
#endif /* u_ptp_F_performance_monitoring */

#ifdef u_ptp_F_external_port_config
    y_ptp_T_external_port_config_port_ds v_external_port_config_port_ds;
#endif /* u_ptp_F_external_port_config */

#ifdef u_ptp_F_slave_monitoring
    y_ptp_T_slave_monitoring_port_ds v_slave_monitoring_port_ds;
#endif /* u_ptp_F_slave_monitoring */
    // y_dot1as_ptp_T_port_statistics_ds ieee802_dot1as_ptp_port_statistics_ds;
} y_ptp_T_port;

/* container /ptp/instances/instance/ports */
typedef struct y_ptp_T_ports_ {
    dlq_hdr_t v_port;
} y_ptp_T_ports;

/* list /ptp/instances/instance */
typedef struct y_ptp_T_instance_ {
    dlq_hdr_t qhdr;
    uint32 v_instance_index;
    y_ptp_T_default_ds v_default_ds;
    y_ptp_T_current_ds v_current_ds;
    y_ptp_T_parent_ds v_parent_ds;
    y_ptp_T_time_properties_ds v_time_properties_ds;

#ifdef u_ptp_F_fault_log
    y_ptp_T_fault_log_ds v_fault_log_ds;
#endif /* u_ptp_F_fault_log */

#ifdef u_ptp_F_path_trace
    y_ptp_T_path_trace_ds v_path_trace_ds;
#endif /* u_ptp_F_path_trace */

#ifdef u_ptp_F_alternate_timescale
    y_ptp_T_alternate_timescale_ds v_alternate_timescale_ds;
#endif /* u_ptp_F_alternate_timescale */

#ifdef u_ptp_F_holdover_upgrade
    y_ptp_T_holdover_upgrade_ds v_holdover_upgrade_ds;
#endif /* u_ptp_F_holdover_upgrade */

#ifdef u_ptp_F_grandmaster_cluster
    y_ptp_T_grandmaster_cluster_ds v_grandmaster_cluster_ds;
#endif /* u_ptp_F_grandmaster_cluster */

#ifdef u_ptp_F_acceptable_master
    y_ptp_T_acceptable_master_ds v_acceptable_master_ds;
#endif /* u_ptp_F_acceptable_master */

#ifdef u_ptp_F_performance_monitoring
    y_ptp_T_performance_monitoring_ds v_performance_monitoring_ds;
#endif /* u_ptp_F_performance_monitoring */

#ifdef u_ptp_F_enhanced_metrics
    y_ptp_T_enhanced_metrics_ds v_enhanced_metrics_ds;
#endif /* u_ptp_F_enhanced_metrics */
    y_ptp_T_ports v_ports;
} y_ptp_T_instance;

/* container /ptp/instances */
typedef struct y_ptp_T_instances_ {
    dlq_hdr_t v_instance;
} y_ptp_T_instances;

/* container /ptp */
typedef struct y_ptp_T_ptp_ {
    y_ptp_T_instances v_instances;
    dlq_hdr_t excelfore_gptp_instance_domain_map;
} y_ptp_T_ptp;


/**
 * @brief Get database object callback for leaf clock-identity (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/default-ds/clock-identity\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_clock_identity_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);


/**
 * @brief Get database object callback for leaf number-ports (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/default-ds/number-ports\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_number_ports_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/default-ds/clock-quality
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
extern status_t u_ptp_clock_quality_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index);


/**
 * @brief Get database object callback for leaf domain-number (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/default-ds/domain-number\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_domain_number_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);


/**
 * @brief Get database object callback for leaf sdo-id (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/default-ds/sdo-id\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_sdo_id_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/default-ds/current-time
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
extern status_t u_ptp_current_time_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index);


/**
 * @brief Get database object callback for leaf max-steps-removed (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/default-ds/max-steps-removed\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_max_steps_removed_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/default-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
extern status_t u_ptp_default_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index);


/**
 * @brief Get database object callback for container current-ds (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/current-ds\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_current_ds_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);


/**
 * @brief Get database object callback for container parent-port-identity (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/parent-ds/parent-port-identity\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_parent_port_identity_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);


/**
 * @brief Get database object callback for container grandmaster-clock-quality (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/parent-ds/grandmaster-clock-quality\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_grandmaster_clock_quality_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);


/**
 * @brief Get database object callback for container protocol-address (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/parent-ds/protocol-address\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_protocol_address_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);


/**
 * @brief Get database object callback for container parent-ds (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/parent-ds\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_parent_ds_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);


/**
 * @brief Get database object callback for container time-properties-ds (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/time-properties-ds\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_time_properties_ds_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);


#ifdef u_ptp_F_fault_log

/**
 * @brief Get database object callback for container time (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/fault-log-ds/fault-record-list/time\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_time_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);


/**
 * @brief Get database object callback for list fault-record-list (getcb_fn2_t)\n
 * Path: list /ptp/instances/instance/fault-log-ds/fault-record-list\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_fault_record_list_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);


/**
 * @brief YANG 1.1 action validate callback. (agt_action_cb_t)\n
 * Path: /ptp/instances/instance/fault-log-ds/reset
 *
 * @param scb session invoking the "<action>" RPC
 * @param msg message in progress for this "<rpc>" request
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @param actionval the nested 'action-method-name' node that was parsed
 * within the topval subtree, in the RPC "<action>" request.
 * This is used to help derive the list keys.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
extern status_t u_reset_action_val (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode,
    val_value_t *actionval,
    uint32 k_ptp_instance_index);


/**
 * @brief YANG 1.1 action invoke callback. (agt_action_cb_t)\n
 * Path: /ptp/instances/instance/fault-log-ds/reset
 *
 * @param scb session invoking the "<action>" RPC
 * @param msg message in progress for this "<rpc>" request
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @param actionval the nested 'action-method-name' node that was parsed
 * within the topval subtree, in the RPC "<action>" request.
 * This is used to help derive the list keys.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
extern status_t u_reset_action_inv (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode,
    val_value_t *actionval,
    uint32 k_ptp_instance_index);


/**
 * @brief Get database object callback for container fault-log-ds (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/fault-log-ds\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_fault_log_ds_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);

#endif /* u_ptp_F_fault_log */


#ifdef u_ptp_F_path_trace

/**
 * @brief Get database object callback for leaf-list list (getcb_fn2_t)\n
 * Path: leaf-list /ptp/instances/instance/path-trace-ds/list\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_list_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/path-trace-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
extern status_t u_ptp_path_trace_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index);

#endif /* u_ptp_F_path_trace */


#ifdef u_ptp_F_alternate_timescale

/**
 * @brief Get database object callback for leaf max-key (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/alternate-timescale-ds/max-key\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_max_key_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance/alternate-timescale-ds/list
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_key_field Local key leaf 'key-field' in list 'list'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:alternate-timescale-ds/ptp:list/ptp:key-field
 * @return return status for the phase.
 */
extern status_t u_ptp_list_1_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint8 k_ptp_key_field);

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/alternate-timescale-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
extern status_t u_ptp_alternate_timescale_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index);

#endif /* u_ptp_F_alternate_timescale */


#ifdef u_ptp_F_holdover_upgrade
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/holdover-upgrade-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
extern status_t u_ptp_holdover_upgrade_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index);

#endif /* u_ptp_F_holdover_upgrade */


#ifdef u_ptp_F_grandmaster_cluster

/**
 * @brief Get database object callback for leaf max-table-size (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/grandmaster-cluster-ds/max-table-size\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_max_table_size_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance/grandmaster-cluster-ds/port-address
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_index Local key leaf 'index' in list 'port-address'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:grandmaster-cluster-ds/ptp:port-address/ptp:index
 * @return return status for the phase.
 */
extern status_t u_ptp_port_address_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_index);

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/grandmaster-cluster-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
extern status_t u_ptp_grandmaster_cluster_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index);

#endif /* u_ptp_F_grandmaster_cluster */


#ifdef u_ptp_F_acceptable_master

/**
 * @brief Get database object callback for leaf max-table-size (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/acceptable-master-ds/max-table-size\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
extern status_t u_ptp_max_table_size_1_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index);


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/acceptable-master-ds/list/acceptable-port-identity
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_index_1 Ancestor key leaf 'index' in list 'list'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:acceptable-master-ds/ptp:list/ptp:index
 * @return return status for the phase.
 */
extern status_t u_ptp_acceptable_port_identity_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint8 k_ptp_index_1);


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance/acceptable-master-ds/list
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_index_1 Local key leaf 'index' in list 'list'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:acceptable-master-ds/ptp:list/ptp:index
 * @return return status for the phase.
 */
extern status_t u_ptp_list_2_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint8 k_ptp_index_1);

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/acceptable-master-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
extern status_t u_ptp_acceptable_master_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index);

#endif /* u_ptp_F_acceptable_master */


#ifdef u_ptp_F_performance_monitoring

/**
 * @brief Get database object callback for list record-list (getcb_fn2_t)\n
 * Path: list /ptp/instances/instance/performance-monitoring-ds/record-list\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_index_2 Local key leaf 'index' in list 'record-list'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:performance-monitoring-ds/ptp:record-list/ptp:index
 * @param index_fixed TRUE if this key is fixed in a getnext request.
 * @param index_present TRUE if this key is present and 'k_ptp_index_2' is valid.\n
 * FALSE to get first in a getnext request.
 * @return return status of the callback.
 */
extern status_t u_ptp_record_list_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_index_2,
    boolean index_fixed,
    boolean index_present);

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/performance-monitoring-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
extern status_t u_ptp_performance_monitoring_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index);

#endif /* u_ptp_F_performance_monitoring */


#ifdef u_ptp_F_enhanced_metrics
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/enhanced-metrics-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
extern status_t u_ptp_enhanced_metrics_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index);

#endif /* u_ptp_F_enhanced_metrics */


/**
 * @brief Get database object callback for container port-identity (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/ports/port/port-ds/port-identity\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_port_identity_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf mean-link-delay (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/mean-link-delay\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_mean_link_delay_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf log-sync-interval (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/log-sync-interval\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_log_sync_interval_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf delay-mechanism (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/delay-mechanism\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_delay_mechanism_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf version-number (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/version-number\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_version_number_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf minor-version-number (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/minor-version-number\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_minor_version_number_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf delay-asymmetry (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/delay-asymmetry\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_delay_asymmetry_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
extern status_t u_ptp_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


#ifdef u_ptp_F_timestamp_correction
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/timestamp-correction-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
extern status_t u_ptp_timestamp_correction_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);

#endif /* u_ptp_F_timestamp_correction */


#ifdef u_ptp_F_asymmetry_correction
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/asymmetry-correction-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
extern status_t u_ptp_asymmetry_correction_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);

#endif /* u_ptp_F_asymmetry_correction */


#ifdef u_ptp_F_unicast_negotiation
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/unicast-negotiation-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
extern status_t u_ptp_unicast_negotiation_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);

#endif /* u_ptp_F_unicast_negotiation */


#ifdef u_ptp_F_alternate_master
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/alternate-master-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
extern status_t u_ptp_alternate_master_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);

#endif /* u_ptp_F_alternate_master */


#ifdef u_ptp_F_unicast_discovery

/**
 * @brief Get database object callback for leaf max-table-size (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/unicast-discovery-port-ds/max-table-size\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_max_table_size_2_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance/ports/port/unicast-discovery-port-ds/port-address
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @param k_ptp_index_3 Local key leaf 'index' in list 'port-address'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:unicast-discovery-port-ds/ptp:port-address/ptp:index
 * @return return status for the phase.
 */
extern status_t u_ptp_port_address_1_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index,
    uint16 k_ptp_index_3);

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/unicast-discovery-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
extern status_t u_ptp_unicast_discovery_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);

#endif /* u_ptp_F_unicast_discovery */


#ifdef u_ptp_F_acceptable_master
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/acceptable-master-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
extern status_t u_ptp_acceptable_master_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);

#endif /* u_ptp_F_acceptable_master */


#ifdef u_ptp_F_l1_sync

/**
 * @brief Get database object callback for leaf link-alive (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/link-alive\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_link_alive_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf is-tx-coherent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/is-tx-coherent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_is_tx_coherent_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf is-rx-coherent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/is-rx-coherent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_is_rx_coherent_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf is-congruent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/is-congruent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_is_congruent_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf l1sync-state (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/l1sync-state\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_l1sync_state_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf peer-tx-coherent-is-required (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-tx-coherent-is-required\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_peer_tx_coherent_is_required_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf peer-rx-coherent-is-required (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-rx-coherent-is-required\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_peer_rx_coherent_is_required_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf peer-congruent-is-required (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-congruent-is-required\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_peer_congruent_is_required_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf peer-is-tx-coherent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-is-tx-coherent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_peer_is_tx_coherent_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf peer-is-rx-coherent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-is-rx-coherent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_peer_is_rx_coherent_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf peer-is-congruent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-is-congruent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_peer_is_congruent_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/l1-sync-basic-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
extern status_t u_ptp_l1_sync_basic_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);

#endif /* u_ptp_F_l1_sync */


#ifdef u_ptp_F_l1_sync

/**
 * @brief Get database object callback for leaf phase-offset-tx-valid (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx-valid\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_phase_offset_tx_valid_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf phase-offset-tx (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_phase_offset_tx_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for container phase-offset-tx-timestamp (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx-timestamp\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_phase_offset_tx_timestamp_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf frequency-offset-tx-valid (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx-valid\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_frequency_offset_tx_valid_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for leaf frequency-offset-tx (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_frequency_offset_tx_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Get database object callback for container frequency-offset-tx-timestamp (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx-timestamp\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
extern status_t u_ptp_frequency_offset_tx_timestamp_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
extern status_t u_ptp_l1_sync_opt_params_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);

#endif /* u_ptp_F_l1_sync */


#ifdef u_ptp_F_performance_monitoring

/**
 * @brief Get database object callback for list record-list-peer-delay (getcb_fn2_t)\n
 * Path: list /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @param k_ptp_index_4 Local key leaf 'index' in list 'record-list-peer-delay'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:performance-monitoring-port-ds/ptp:record-list-peer-delay/ptp:index
 * @param index_fixed TRUE if this key is fixed in a getnext request.
 * @param index_present TRUE if this key is present and 'k_ptp_index_4' is valid.\n
 * FALSE to get first in a getnext request.
 * @return return status of the callback.
 */
extern status_t u_ptp_record_list_peer_delay_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index,
    uint16 k_ptp_index_4,
    boolean index_fixed,
    boolean index_present);


/**
 * @brief Get database object callback for list record-list (getcb_fn2_t)\n
 * Path: list /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @param k_ptp_index_5 Local key leaf 'index' in list 'record-list'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:performance-monitoring-port-ds/ptp:record-list/ptp:index
 * @param index_fixed TRUE if this key is fixed in a getnext request.
 * @param index_present TRUE if this key is present and 'k_ptp_index_5' is valid.\n
 * FALSE to get first in a getnext request.
 * @return return status of the callback.
 */
extern status_t u_ptp_record_list_1_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index,
    uint16 k_ptp_index_5,
    boolean index_fixed,
    boolean index_present);

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/performance-monitoring-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
extern status_t u_ptp_performance_monitoring_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);

#endif /* u_ptp_F_performance_monitoring */


#ifdef u_ptp_F_external_port_config
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/external-port-config-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
extern status_t u_ptp_external_port_config_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);

#endif /* u_ptp_F_external_port_config */


#ifdef u_ptp_F_slave_monitoring
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/slave-monitoring-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
extern status_t u_ptp_slave_monitoring_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);

#endif /* u_ptp_F_slave_monitoring */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance/ports/port
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Local key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
extern status_t u_ptp_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index);


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
extern status_t u_ptp_ports_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index);


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Local key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
extern status_t u_ptp_instance_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index);


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
extern status_t u_ptp_instances_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval);


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
extern status_t u_ptp_ptp_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval);


/**
 * @brief Phase 1: Initialize the ieee1588-ptp server instrumentation library.
 *
 * Called by server when module is loaded.
 *
 * @param modname requested module name to load
 * @param revision requested revision date of the module to load.
 * This may be NULL if the module has no revision statements.
 * @return return status. An error will cause the module load to fail.
 */
extern status_t u_ieee1588_ptp_init (
    const xmlChar *modname,
    const xmlChar *revision);


/**
 * @brief Phase 2: Initialize the ieee1588-ptp server instrumentation library.
 *
 * SIL init phase 2: non-config data structures.
 * Called after running config is loaded.
 *
 * @return return status. An error will cause the
 * server initialization to fail.
 */
extern status_t u_ieee1588_ptp_init2 (void);


/**
 * @brief Cleanup the ieee1588-ptp server instrumentation library.
 *
 * Called by server when module is unloaded.
 *
 */
extern void u_ieee1588_ptp_cleanup (void);


 /** @} */

#ifdef __cplusplus
} /* end extern 'C' */
#endif

#endif
