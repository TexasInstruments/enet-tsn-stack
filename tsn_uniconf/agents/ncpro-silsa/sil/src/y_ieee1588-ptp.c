/*
 * Copyright (c) 2023 Texas Instruments Incorporated
 * Copyright (c) 2023 Excelfore Corporation (https://excelfore.com)
 *
 * All rights reserved not granted herein.
 * Limited License.
 *
 * Texas Instruments Incorporated grants a world-wide, royalty-free,
 * non-exclusive license under copyrights and patents it now or hereafter
 * owns or controls to make, have made, use, import, offer to sell and sell ("Utilize")
 * this software subject to the terms herein. With respect to the foregoing patent
 * license, such license is granted solely to the extent that any such patent is necessary
 * to Utilize the software alone. The patent license shall not apply to any combinations which
 * include this software, other than combinations with devices manufactured by or for TI ("TI Devices").
 * No hardware patent is licensed hereunder.
 *
 * Redistributions must preserve existing copyright notices and reproduce this license (including the
 * above copyright notice and the disclaimer and (if applicable) source code license limitations below)
 * in the documentation and/or other materials provided with the distribution
 *
 * Redistribution and use in binary form, without modification, are permitted provided that the following
 * conditions are met:
 *
 * * No reverse engineering, decompilation, or disassembly of this software is permitted with respect to any
 * software provided in binary form.
 * * any redistribution and use are licensed by TI for use only with TI Devices.
 * * Nothing shall obligate TI to provide you with source code for the software licensed and provided to you in object code.
 *
 * If software source code is provided to you, modification and redistribution of the source code are permitted
 * provided that the following conditions are met:
 *
 * * any redistribution and use of the source code, including any resulting derivative works, are licensed by
 * TI for use only with TI Devices.
 * * any redistribution and use of any object code compiled from the source code and any resulting derivative
 * works, are licensed by TI for use only with TI Devices.
 *
 * Neither the name of Texas Instruments Incorporated nor the names of its suppliers may be used to endorse or
 * promote products derived from this software without specific prior written permission.
 *
 * DISCLAIMER.
 *
 * THIS SOFTWARE IS PROVIDED BY TI AND TI"S LICENSORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TI AND TI"S LICENSORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * Copyright (c) 2008 - 2012, Andy Bierman, All Rights Reserved.
 * Copyright (c) 2012 - 2022, YumaWorks, Inc., All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

/**
 * @file y_ieee1588-ptp.c
 * @brief YumaPro SIL-SA module for module ieee1588-ptp
 *

*** Generated by yangdump-sdk 21.10-12

<pre>

    YumaPro SIL-SA module
    bundle x4ucsilsa
    module ieee1588-ptp
    revision 2022-08-30
    prefix ptp
    namespace urn:ieee:std:1588:yang:ieee1588-ptp
    organization IEEE 1588 Working Group
    Created: 2023-03-29T06:45:58Z

Online Developer Manual:
https://www.yumaworks.com/pub/21.10/dev/yumapro-dev-manual.html

    CLI parameters:
        defnames true
        deviation excelfore-interfaces
        deviation excelfore-gptp
        format yc
        indent 4
        module ietf-interfaces
        module ieee802-dot1q-bridge
        module ieee802-dot1q-tsn-config-uni
        module excelfore-interfaces
        module ieee1588-ptp
        module ieee802-dot1as-ptp
        module excelfore-gptp
        sil-bundle x4ucsilsa
        sil-edit2
        sil-get2
        sil-include tsn_uniconf/yangs/yang_db_access.h
        sil-include tsn_uniconf/yangs/yang_modules.h
        sil-sa
        unified true

  Short Name Mappings
    acceptable_master_ds = /ptp/instances/instance/acceptable-master-ds
    acceptable_master_port_ds = /ptp/instances/instance/ports/port/acceptable-master-port-ds
    acceptable_port_identity = /ptp/instances/instance/acceptable-master-ds/list/acceptable-port-identity
    address_field = /ptp/instances/instance/parent-ds/protocol-address/address-field
    address_field_1 = /ptp/instances/instance/grandmaster-cluster-ds/port-address/address-field
    address_field_2 = /ptp/instances/instance/ports/port/description-port-ds/protocol-address/address-field
    address_field_3 = /ptp/instances/instance/ports/port/unicast-discovery-port-ds/port-address/address-field
    address_length = /ptp/instances/instance/parent-ds/protocol-address/address-length
    address_length_1 = /ptp/instances/instance/grandmaster-cluster-ds/port-address/address-length
    address_length_2 = /ptp/instances/instance/ports/port/description-port-ds/protocol-address/address-length
    address_length_3 = /ptp/instances/instance/ports/port/unicast-discovery-port-ds/port-address/address-length
    alternate_master_port_ds = /ptp/instances/instance/ports/port/alternate-master-port-ds
    alternate_priority1 = /ptp/instances/instance/acceptable-master-ds/list/alternate-priority1
    alternate_timescale_ds = /ptp/instances/instance/alternate-timescale-ds
    announce_foreign_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/announce-foreign-rx
    announce_foreign_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/announce-foreign-rx
    announce_receipt_timeout = /ptp/instances/instance/ports/port/port-ds/announce-receipt-timeout
    announce_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/announce-rx
    announce_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/announce-rx
    announce_tx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/announce-tx
    announce_tx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/announce-tx
    asymmetry_correction_port_ds = /ptp/instances/instance/ports/port/asymmetry-correction-port-ds
    asymmetry_correction_port_ds_1 = /ptp/common-services/cmlds/ports/port/asymmetry-correction-port-ds
    average_master_slave_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/average-master-slave-delay
    average_mean_link_delay = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay/average-mean-link-delay
    average_mean_link_delay_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list-peer-delay/average-mean-link-delay
    average_mean_path_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/average-mean-path-delay
    average_offset_from_master = /ptp/instances/instance/performance-monitoring-ds/record-list/average-offset-from-master
    average_slave_master_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/average-slave-master-delay
    clock_accuracy = /ptp/instances/instance/default-ds/clock-quality/clock-accuracy
    clock_accuracy_1 = /ptp/instances/instance/parent-ds/grandmaster-clock-quality/clock-accuracy
    clock_class = /ptp/instances/instance/default-ds/clock-quality/clock-class
    clock_class_1 = /ptp/instances/instance/parent-ds/grandmaster-clock-quality/clock-class
    clock_identity = /ptp/instances/instance/default-ds/clock-identity
    clock_identity_1 = /ptp/instances/instance/parent-ds/parent-port-identity/clock-identity
    clock_identity_2 = /ptp/instances/instance/acceptable-master-ds/list/acceptable-port-identity/clock-identity
    clock_identity_3 = /ptp/instances/instance/ports/port/port-ds/port-identity/clock-identity
    clock_identity_4 = /ptp/transparent-clock-default-ds/clock-identity
    clock_identity_5 = /ptp/transparent-clock-ports/port/port-ds/port-identity/clock-identity
    clock_identity_6 = /ptp/common-services/cmlds/default-ds/clock-identity
    clock_identity_7 = /ptp/common-services/cmlds/ports/port/link-port-ds/port-identity/clock-identity
    clock_quality = /ptp/instances/instance/default-ds/clock-quality
    cmlds = /ptp/common-services/cmlds
    cmlds_link_port_port_number = /ptp/instances/instance/ports/port/common-services-port-ds/cmlds-link-port-port-number
    common_services = /ptp/common-services
    common_services_port_ds = /ptp/instances/instance/ports/port/common-services-port-ds
    communication_cap_port_ds = /ptp/instances/instance/ports/port/communication-cap-port-ds
    congruent_is_required = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/congruent-is-required
    constant_asymmetry = /ptp/instances/instance/ports/port/asymmetry-correction-port-ds/constant-asymmetry
    constant_asymmetry_1 = /ptp/common-services/cmlds/ports/port/asymmetry-correction-port-ds/constant-asymmetry
    current_ds = /ptp/instances/instance/current-ds
    current_offset = /ptp/instances/instance/alternate-timescale-ds/list/current-offset
    current_time = /ptp/instances/instance/default-ds/current-time
    current_utc_offset = /ptp/instances/instance/time-properties-ds/current-utc-offset
    current_utc_offset_valid = /ptp/instances/instance/time-properties-ds/current-utc-offset-valid
    default_ds = /ptp/instances/instance/default-ds
    default_ds_1 = /ptp/common-services/cmlds/default-ds
    delay_asymmetry = /ptp/instances/instance/ports/port/port-ds/delay-asymmetry
    delay_asymmetry_1 = /ptp/common-services/cmlds/ports/port/link-port-ds/delay-asymmetry
    delay_mechanism = /ptp/instances/instance/ports/port/port-ds/delay-mechanism
    delay_mechanism_1 = /ptp/transparent-clock-default-ds/delay-mechanism
    delay_req_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/delay-req-rx
    delay_req_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/delay-req-rx
    delay_req_tx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/delay-req-tx
    delay_req_tx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/delay-req-tx
    delay_resp = /ptp/instances/instance/ports/port/communication-cap-port-ds/delay-resp
    delay_resp_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/delay-resp-rx
    delay_resp_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/delay-resp-rx
    delay_resp_tx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/delay-resp-tx
    delay_resp_tx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/delay-resp-tx
    description = /ptp/instances/instance/fault-log-ds/fault-record-list/description
    description_ds = /ptp/instances/instance/description-ds
    description_port_ds = /ptp/instances/instance/ports/port/description-port-ds
    desired_state = /ptp/instances/instance/ports/port/external-port-config-port-ds/desired-state
    display_name = /ptp/instances/instance/alternate-timescale-ds/list/display-name
    domain_number = /ptp/instances/instance/default-ds/domain-number
    domain_number_1 = /ptp/common-services/cmlds/ports/port/link-port-ds/domain-number
    egress_latency = /ptp/instances/instance/ports/port/timestamp-correction-port-ds/egress-latency
    egress_latency_1 = /ptp/common-services/cmlds/ports/port/timestamp-correction-port-ds/egress-latency
    enable = /ptp/instances/instance/path-trace-ds/enable
    enable_1 = /ptp/instances/instance/alternate-timescale-ds/list/enable
    enable_2 = /ptp/instances/instance/holdover-upgrade-ds/enable
    enable_3 = /ptp/instances/instance/performance-monitoring-ds/enable
    enable_4 = /ptp/instances/instance/enhanced-metrics-ds/enable
    enable_5 = /ptp/instances/instance/ports/port/asymmetry-correction-port-ds/enable
    enable_6 = /ptp/instances/instance/ports/port/unicast-negotiation-port-ds/enable
    enable_7 = /ptp/instances/instance/ports/port/acceptable-master-port-ds/enable
    enable_8 = /ptp/instances/instance/ports/port/slave-monitoring-port-ds/enable
    enable_9 = /ptp/common-services/cmlds/ports/port/asymmetry-correction-port-ds/enable
    enabled = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/enabled
    enhanced_metrics_ds = /ptp/instances/instance/enhanced-metrics-ds
    events_per_rx_sync_computed_tlv = /ptp/instances/instance/ports/port/slave-monitoring-port-ds/events-per-rx-sync-computed-tlv
    events_per_rx_sync_timing_tlv = /ptp/instances/instance/ports/port/slave-monitoring-port-ds/events-per-rx-sync-timing-tlv
    events_per_tx_timestamps_tlv = /ptp/instances/instance/ports/port/slave-monitoring-port-ds/events-per-tx-timestamps-tlv
    external_port_config_enable = /ptp/instances/instance/default-ds/external-port-config-enable
    external_port_config_port_ds = /ptp/instances/instance/ports/port/external-port-config-port-ds
    fault_log_ds = /ptp/instances/instance/fault-log-ds
    fault_record_list = /ptp/instances/instance/fault-log-ds/fault-record-list
    faulty_flag = /ptp/transparent-clock-ports/port/port-ds/faulty-flag
    follow_up_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/follow-up-rx
    follow_up_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/follow-up-rx
    follow_up_tx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/follow-up-tx
    follow_up_tx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/follow-up-tx
    frequency_offset_tx = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx
    frequency_offset_tx_timestamp = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx-timestamp
    frequency_offset_tx_valid = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx-valid
    frequency_traceable = /ptp/instances/instance/time-properties-ds/frequency-traceable
    grandmaster_clock_quality = /ptp/instances/instance/parent-ds/grandmaster-clock-quality
    grandmaster_cluster_ds = /ptp/instances/instance/grandmaster-cluster-ds
    grandmaster_identity = /ptp/instances/instance/parent-ds/grandmaster-identity
    grandmaster_priority1 = /ptp/instances/instance/parent-ds/grandmaster-priority1
    grandmaster_priority2 = /ptp/instances/instance/parent-ds/grandmaster-priority2
    holdover_upgrade_ds = /ptp/instances/instance/holdover-upgrade-ds
    index = /ptp/instances/instance/grandmaster-cluster-ds/port-address/index
    index_1 = /ptp/instances/instance/acceptable-master-ds/list/index
    index_2 = /ptp/instances/instance/performance-monitoring-ds/record-list/index
    index_3 = /ptp/instances/instance/ports/port/unicast-discovery-port-ds/port-address/index
    index_4 = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay/index
    index_5 = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/index
    index_6 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list-peer-delay/index
    index_7 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/index
    ingress_latency = /ptp/instances/instance/ports/port/timestamp-correction-port-ds/ingress-latency
    ingress_latency_1 = /ptp/common-services/cmlds/ports/port/timestamp-correction-port-ds/ingress-latency
    input = /ptp/instances/instance/fault-log-ds/reset/input
    instance = /ptp/instances/instance
    instance_enable = /ptp/instances/instance/default-ds/instance-enable
    instance_index = /ptp/instances/instance/instance-index
    instance_type = /ptp/instances/instance/default-ds/instance-type
    instances = /ptp/instances
    is_congruent = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/is-congruent
    is_rx_coherent = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/is-rx-coherent
    is_tx_coherent = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/is-tx-coherent
    jump_seconds = /ptp/instances/instance/alternate-timescale-ds/list/jump-seconds
    key_field = /ptp/instances/instance/alternate-timescale-ds/list/key-field
    l1_sync_basic_port_ds = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds
    l1_sync_opt_params_port_ds = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds
    l1sync_receipt_timeout = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/l1sync-receipt-timeout
    l1sync_state = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/l1sync-state
    leap59 = /ptp/instances/instance/time-properties-ds/leap59
    leap61 = /ptp/instances/instance/time-properties-ds/leap61
    link_alive = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/link-alive
    link_port_ds = /ptp/common-services/cmlds/ports/port/link-port-ds
    list = /ptp/instances/instance/path-trace-ds/list
    list_1 = /ptp/instances/instance/alternate-timescale-ds/list
    list_2 = /ptp/instances/instance/acceptable-master-ds/list
    log_alt_multicast_sync_interval = /ptp/instances/instance/ports/port/alternate-master-port-ds/log-alt-multicast-sync-interval
    log_announce_interval = /ptp/instances/instance/ports/port/port-ds/log-announce-interval
    log_l1sync_interval = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/log-l1sync-interval
    log_min_delay_req_interval = /ptp/instances/instance/ports/port/port-ds/log-min-delay-req-interval
    log_min_pdelay_req_interval = /ptp/instances/instance/ports/port/port-ds/log-min-pdelay-req-interval
    log_min_pdelay_req_interval_1 = /ptp/transparent-clock-ports/port/port-ds/log-min-pdelay-req-interval
    log_min_pdelay_req_interval_2 = /ptp/common-services/cmlds/ports/port/link-port-ds/log-min-pdelay-req-interval
    log_query_interval = /ptp/instances/instance/grandmaster-cluster-ds/log-query-interval
    log_query_interval_1 = /ptp/instances/instance/ports/port/unicast-discovery-port-ds/log-query-interval
    log_sync_interval = /ptp/instances/instance/ports/port/port-ds/log-sync-interval
    manufacturer_identity = /ptp/instances/instance/description-ds/manufacturer-identity
    master_only = /ptp/instances/instance/ports/port/port-ds/master-only
    max_key = /ptp/instances/instance/alternate-timescale-ds/max-key
    max_mean_link_delay = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay/max-mean-link-delay
    max_mean_link_delay_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list-peer-delay/max-mean-link-delay
    max_steps_removed = /ptp/instances/instance/default-ds/max-steps-removed
    max_table_size = /ptp/instances/instance/grandmaster-cluster-ds/max-table-size
    max_table_size_1 = /ptp/instances/instance/acceptable-master-ds/max-table-size
    max_table_size_2 = /ptp/instances/instance/ports/port/unicast-discovery-port-ds/max-table-size
    maximum_master_slave_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/maximum-master-slave-delay
    maximum_mean_path_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/maximum-mean-path-delay
    maximum_offset_from_master = /ptp/instances/instance/performance-monitoring-ds/record-list/maximum-offset-from-master
    maximum_slave_master_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/maximum-slave-master-delay
    mean_delay = /ptp/instances/instance/current-ds/mean-delay
    mean_link_delay = /ptp/instances/instance/ports/port/port-ds/mean-link-delay
    mean_link_delay_1 = /ptp/common-services/cmlds/ports/port/link-port-ds/mean-link-delay
    mean_path_delay = /ptp/instances/instance/current-ds/mean-path-delay
    measurement_valid = /ptp/instances/instance/performance-monitoring-ds/record-list/measurement-valid
    min_mean_link_delay = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay/min-mean-link-delay
    min_mean_link_delay_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list-peer-delay/min-mean-link-delay
    minimum_master_slave_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/minimum-master-slave-delay
    minimum_mean_path_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/minimum-mean-path-delay
    minimum_offset_from_master = /ptp/instances/instance/performance-monitoring-ds/record-list/minimum-offset-from-master
    minimum_slave_master_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/minimum-slave-master-delay
    minor_version_number = /ptp/instances/instance/ports/port/port-ds/minor-version-number
    minor_version_number_1 = /ptp/common-services/cmlds/ports/port/link-port-ds/minor-version-number
    multicast_capable = /ptp/instances/instance/ports/port/communication-cap-port-ds/sync/multicast-capable
    multicast_capable_1 = /ptp/instances/instance/ports/port/communication-cap-port-ds/delay-resp/multicast-capable
    name = /ptp/instances/instance/fault-log-ds/fault-record-list/name
    nanoseconds_field = /ptp/instances/instance/default-ds/current-time/nanoseconds-field
    nanoseconds_field_1 = /ptp/instances/instance/fault-log-ds/fault-record-list/time/nanoseconds-field
    nanoseconds_field_2 = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx-timestamp/nanoseconds-field
    nanoseconds_field_3 = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx-timestamp/nanoseconds-field
    network_protocol = /ptp/instances/instance/parent-ds/protocol-address/network-protocol
    network_protocol_1 = /ptp/instances/instance/grandmaster-cluster-ds/port-address/network-protocol
    network_protocol_2 = /ptp/instances/instance/ports/port/description-port-ds/protocol-address/network-protocol
    network_protocol_3 = /ptp/instances/instance/ports/port/unicast-discovery-port-ds/port-address/network-protocol
    number_link_ports = /ptp/common-services/cmlds/default-ds/number-link-ports
    number_of_alt_masters = /ptp/instances/instance/ports/port/alternate-master-port-ds/number-of-alt-masters
    number_of_fault_records = /ptp/instances/instance/fault-log-ds/number-of-fault-records
    number_ports = /ptp/instances/instance/default-ds/number-ports
    number_ports_1 = /ptp/transparent-clock-default-ds/number-ports
    observed_parent_clock_phase_change_rate = /ptp/instances/instance/parent-ds/observed-parent-clock-phase-change-rate
    observed_parent_offset_scaled_log_variance = /ptp/instances/instance/parent-ds/observed-parent-offset-scaled-log-variance
    offset_from_master = /ptp/instances/instance/current-ds/offset-from-master
    offset_scaled_log_variance = /ptp/instances/instance/default-ds/clock-quality/offset-scaled-log-variance
    offset_scaled_log_variance_1 = /ptp/instances/instance/parent-ds/grandmaster-clock-quality/offset-scaled-log-variance
    opt_params_enabled = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/opt-params-enabled
    output = /ptp/instances/instance/fault-log-ds/reset/output
    parent_ds = /ptp/instances/instance/parent-ds
    parent_port_identity = /ptp/instances/instance/parent-ds/parent-port-identity
    parent_stats = /ptp/instances/instance/parent-ds/parent-stats
    path_trace_ds = /ptp/instances/instance/path-trace-ds
    pdelay_req_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/pdelay-req-rx
    pdelay_req_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/pdelay-req-rx
    pdelay_req_tx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/pdelay-req-tx
    pdelay_req_tx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/pdelay-req-tx
    pdelay_resp_follow_up_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/pdelay-resp-follow-up-rx
    pdelay_resp_follow_up_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/pdelay-resp-follow-up-rx
    pdelay_resp_follow_up_tx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/pdelay-resp-follow-up-tx
    pdelay_resp_follow_up_tx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/pdelay-resp-follow-up-tx
    pdelay_resp_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/pdelay-resp-rx
    pdelay_resp_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/pdelay-resp-rx
    pdelay_resp_tx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/pdelay-resp-tx
    pdelay_resp_tx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/pdelay-resp-tx
    peer_congruent_is_required = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-congruent-is-required
    peer_is_congruent = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-is-congruent
    peer_is_rx_coherent = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-is-rx-coherent
    peer_is_tx_coherent = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-is-tx-coherent
    peer_mean_path_delay = /ptp/instances/instance/ports/port/port-ds/peer-mean-path-delay
    peer_mean_path_delay_1 = /ptp/transparent-clock-ports/port/port-ds/peer-mean-path-delay
    peer_rx_coherent_is_required = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-rx-coherent-is-required
    peer_tx_coherent_is_required = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-tx-coherent-is-required
    performance_monitoring_ds = /ptp/instances/instance/performance-monitoring-ds
    performance_monitoring_port_ds = /ptp/instances/instance/ports/port/performance-monitoring-port-ds
    performance_monitoring_port_ds_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds
    period_complete = /ptp/instances/instance/performance-monitoring-ds/record-list/period-complete
    phase_offset_tx = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx
    phase_offset_tx_timestamp = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx-timestamp
    phase_offset_tx_valid = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx-valid
    pm_time = /ptp/instances/instance/performance-monitoring-ds/record-list/pm-time
    pm_time_1 = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay/pm-time
    pm_time_2 = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/pm-time
    pm_time_3 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list-peer-delay/pm-time
    pm_time_4 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/pm-time
    port = /ptp/instances/instance/ports/port
    port_1 = /ptp/transparent-clock-ports/port
    port_2 = /ptp/common-services/cmlds/ports/port
    port_address = /ptp/instances/instance/grandmaster-cluster-ds/port-address
    port_address_1 = /ptp/instances/instance/ports/port/unicast-discovery-port-ds/port-address
    port_ds = /ptp/instances/instance/ports/port/port-ds
    port_ds_1 = /ptp/transparent-clock-ports/port/port-ds
    port_enable = /ptp/instances/instance/ports/port/port-ds/port-enable
    port_identity = /ptp/instances/instance/ports/port/port-ds/port-identity
    port_identity_1 = /ptp/transparent-clock-ports/port/port-ds/port-identity
    port_identity_2 = /ptp/common-services/cmlds/ports/port/link-port-ds/port-identity
    port_index = /ptp/instances/instance/ports/port/port-index
    port_index_1 = /ptp/transparent-clock-ports/port/port-index
    port_index_2 = /ptp/common-services/cmlds/ports/port/port-index
    port_number = /ptp/instances/instance/parent-ds/parent-port-identity/port-number
    port_number_1 = /ptp/instances/instance/acceptable-master-ds/list/acceptable-port-identity/port-number
    port_number_2 = /ptp/instances/instance/ports/port/port-ds/port-identity/port-number
    port_number_3 = /ptp/transparent-clock-ports/port/port-ds/port-identity/port-number
    port_number_4 = /ptp/common-services/cmlds/ports/port/link-port-ds/port-identity/port-number
    port_state = /ptp/instances/instance/ports/port/port-ds/port-state
    ports = /ptp/instances/instance/ports
    ports_1 = /ptp/common-services/cmlds/ports
    primary_domain = /ptp/transparent-clock-default-ds/primary-domain
    priority1 = /ptp/instances/instance/default-ds/priority1
    priority2 = /ptp/instances/instance/default-ds/priority2
    product_description = /ptp/instances/instance/description-ds/product-description
    product_revision = /ptp/instances/instance/description-ds/product-revision
    profile_identifier = /ptp/instances/instance/ports/port/description-port-ds/profile-identifier
    protocol_address = /ptp/instances/instance/parent-ds/protocol-address
    protocol_address_1 = /ptp/instances/instance/ports/port/description-port-ds/protocol-address
    ptp = /ptp
    ptp_timescale = /ptp/instances/instance/time-properties-ds/ptp-timescale
    record_list = /ptp/instances/instance/performance-monitoring-ds/record-list
    record_list_1 = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list
    record_list_2 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list
    record_list_peer_delay = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay
    record_list_peer_delay_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list-peer-delay
    reset = /ptp/instances/instance/fault-log-ds/reset
    rx_coherent_is_required = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/rx-coherent-is-required
    rx_sync_computed_tlv_message_m = /ptp/instances/instance/ports/port/slave-monitoring-port-ds/rx-sync-computed-tlv-message-m
    rx_sync_timing_tlv_message_m = /ptp/instances/instance/ports/port/slave-monitoring-port-ds/rx-sync-timing-tlv-message-m
    scaled_delay_coefficient = /ptp/instances/instance/ports/port/asymmetry-correction-port-ds/scaled-delay-coefficient
    scaled_delay_coefficient_1 = /ptp/common-services/cmlds/ports/port/asymmetry-correction-port-ds/scaled-delay-coefficient
    scaled_neighbor_rate_ratio = /ptp/common-services/cmlds/ports/port/link-port-ds/scaled-neighbor-rate-ratio
    sdo_id = /ptp/instances/instance/default-ds/sdo-id
    seconds_field = /ptp/instances/instance/default-ds/current-time/seconds-field
    seconds_field_1 = /ptp/instances/instance/fault-log-ds/fault-record-list/time/seconds-field
    seconds_field_2 = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx-timestamp/seconds-field
    seconds_field_3 = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx-timestamp/seconds-field
    service_measurement_valid = /ptp/common-services/cmlds/ports/port/link-port-ds/service-measurement-valid
    severity = /ptp/instances/instance/fault-log-ds/fault-record-list/severity
    slave_monitoring_port_ds = /ptp/instances/instance/ports/port/slave-monitoring-port-ds
    slave_only = /ptp/instances/instance/default-ds/slave-only
    stddev_master_slave_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/stddev-master-slave-delay
    stddev_mean_link_delay = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay/stddev-mean-link-delay
    stddev_mean_link_delay_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list-peer-delay/stddev-mean-link-delay
    stddev_mean_path_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/stddev-mean-path-delay
    stddev_offset_from_master = /ptp/instances/instance/performance-monitoring-ds/record-list/stddev-offset-from-master
    stddev_slave_master_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/stddev-slave-master-delay
    steps_removed = /ptp/instances/instance/current-ds/steps-removed
    sync = /ptp/instances/instance/ports/port/communication-cap-port-ds/sync
    sync_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/sync-rx
    sync_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/sync-rx
    sync_tx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/sync-tx
    sync_tx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/sync-tx
    synchronization_uncertain = /ptp/instances/instance/current-ds/synchronization-uncertain
    synchronization_uncertain_1 = /ptp/instances/instance/parent-ds/synchronization-uncertain
    time = /ptp/instances/instance/fault-log-ds/fault-record-list/time
    time_of_next_jump = /ptp/instances/instance/alternate-timescale-ds/list/time-of-next-jump
    time_properties_ds = /ptp/instances/instance/time-properties-ds
    time_source = /ptp/instances/instance/time-properties-ds/time-source
    time_traceable = /ptp/instances/instance/time-properties-ds/time-traceable
    timestamp_correction_port_ds = /ptp/instances/instance/ports/port/timestamp-correction-port-ds
    timestamp_correction_port_ds_1 = /ptp/common-services/cmlds/ports/port/timestamp-correction-port-ds
    timestamps_corrected_tx = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/timestamps-corrected-tx
    transparent_clock_default_ds = /ptp/transparent-clock-default-ds
    transparent_clock_ports = /ptp/transparent-clock-ports
    two_step_flag = /ptp/instances/instance/default-ds/two-step-flag
    tx_alt_multicast_sync = /ptp/instances/instance/ports/port/alternate-master-port-ds/tx-alt-multicast-sync
    tx_coherent_is_required = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/tx-coherent-is-required
    tx_event_type = /ptp/instances/instance/ports/port/slave-monitoring-port-ds/tx-event-type
    tx_timestamps_tlv_message_m = /ptp/instances/instance/ports/port/slave-monitoring-port-ds/tx-timestamps-tlv-message-m
    underlying_interface = /ptp/instances/instance/ports/port/underlying-interface
    underlying_interface_1 = /ptp/transparent-clock-ports/port/underlying-interface
    underlying_interface_2 = /ptp/common-services/cmlds/ports/port/underlying-interface
    unicast_capable = /ptp/instances/instance/ports/port/communication-cap-port-ds/sync/unicast-capable
    unicast_capable_1 = /ptp/instances/instance/ports/port/communication-cap-port-ds/delay-resp/unicast-capable
    unicast_discovery_port_ds = /ptp/instances/instance/ports/port/unicast-discovery-port-ds
    unicast_negotiation_capable = /ptp/instances/instance/ports/port/communication-cap-port-ds/sync/unicast-negotiation-capable
    unicast_negotiation_capable_1 = /ptp/instances/instance/ports/port/communication-cap-port-ds/delay-resp/unicast-negotiation-capable
    unicast_negotiation_port_ds = /ptp/instances/instance/ports/port/unicast-negotiation-port-ds
    unicast_negotiation_required = /ptp/instances/instance/ports/port/communication-cap-port-ds/sync/unicast-negotiation-required
    unicast_negotiation_required_1 = /ptp/instances/instance/ports/port/communication-cap-port-ds/delay-resp/unicast-negotiation-required
    user_description = /ptp/instances/instance/description-ds/user-description
    value = /ptp/instances/instance/fault-log-ds/fault-record-list/value
    version_number = /ptp/instances/instance/ports/port/port-ds/version-number
    version_number_1 = /ptp/common-services/cmlds/ports/port/link-port-ds/version-number
</pre>

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_action.h"
#include "agt_cb.h"
#include "agt_cfg.h"
#include "agt_rpc.h"
#include "agt_sil_lib.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "agt_val.h"
#include "cfg.h"
#include "dlq.h"
#include "getcb.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "obj.h"
#include "rpc.h"
#include "sil_sa.h"
#include "status.h"
#include "val.h"
#include "val_child.h"
#include "val_util.h"
#include "xml_val.h"

#include "tsn_uniconf/yangs/yang_db_access.h"
#include "tsn_uniconf/yangs/yang_modules.h"


/* SIL bundle: x4ucsilsa */
#include "y_ietf-interfaces.h"
#include "u_ietf-interfaces.h"
#include "y_ieee802-dot1q-bridge.h"
#include "u_ieee802-dot1q-bridge.h"
#include "y_ieee802-dot1q-tsn-config-uni.h"
#include "u_ieee802-dot1q-tsn-config-uni.h"
#include "y_excelfore-interfaces.h"
#include "u_excelfore-interfaces.h"
#include "y_ieee1588-ptp.h"
#include "u_ieee1588-ptp.h"
#include "y_ieee802-dot1as-ptp.h"
#include "u_ieee802-dot1as-ptp.h"
#include "y_excelfore-gptp.h"
#include "u_excelfore-gptp.h"


/**
 * @addtogroup yang-library YANG Library
 *
 * Collection of modules supported by the server.
 * Generated by yangdump-sdk.
 */



/**
 * @addtogroup silsa-x4ucsilsa-ieee1588-ptp Module ieee1588-ptp in Bundle x4ucsilsa
 * @ingroup silsa-x4ucsilsa
 *
 * @{
 *
 * YANG instrumentation library.
 * Generated by yangdump-sdk.
 */


/* module static variables */
static ncx_module_t *ieee1588_ptp_mod;
static obj_template_t *ptp_obj;
static val_value_t *ptp_val;

/**
 * @brief Initialize module static variables
 *
 * Called by server when module is loaded.
 */
static void y_ptp_init_static_vars (void)
{
    ieee1588_ptp_mod = NULL;
    ptp_obj = NULL;
    ptp_val = NULL;

} /* y_ptp_init_static_vars */


/**
 * @brief Get database object callback for leaf clock-identity (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/default-ds/clock-identity\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t clock_identity_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter clock_identity_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_clock_identity_get(
        get2cb,
        k_ptp_instance_index);

} /* clock_identity_get */


/**
 * @brief Get database object callback for leaf number-ports (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/default-ds/number-ports\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t number_ports_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter number_ports_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_number_ports_get(
        get2cb,
        k_ptp_instance_index);

} /* number_ports_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/default-ds/clock-quality
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t clock_quality_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter clock_quality_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_clock_quality_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* clock_quality_edit */


/**
 * @brief Get database object callback for leaf domain-number (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/default-ds/domain-number\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t domain_number_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter domain_number_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_domain_number_get(
        get2cb,
        k_ptp_instance_index);

} /* domain_number_get */


/**
 * @brief Get database object callback for leaf sdo-id (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/default-ds/sdo-id\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t sdo_id_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter sdo_id_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_sdo_id_get(
        get2cb,
        k_ptp_instance_index);

} /* sdo_id_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/default-ds/current-time
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t current_time_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter current_time_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_current_time_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* current_time_edit */


/**
 * @brief Get database object callback for leaf max-steps-removed (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/default-ds/max-steps-removed\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t max_steps_removed_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter max_steps_removed_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_max_steps_removed_get(
        get2cb,
        k_ptp_instance_index);

} /* max_steps_removed_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/default-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t default_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter default_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_default_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* default_ds_edit */


/**
 * @brief Get database object callback for container current-ds (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/current-ds\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t current_ds_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter current_ds_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_current_ds_get(
        get2cb,
        k_ptp_instance_index);

} /* current_ds_get */


/**
 * @brief Get database object callback for container parent-port-identity (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/parent-ds/parent-port-identity\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t parent_port_identity_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter parent_port_identity_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_parent_port_identity_get(
        get2cb,
        k_ptp_instance_index);

} /* parent_port_identity_get */


/**
 * @brief Get database object callback for container grandmaster-clock-quality (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/parent-ds/grandmaster-clock-quality\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t grandmaster_clock_quality_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter grandmaster_clock_quality_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_grandmaster_clock_quality_get(
        get2cb,
        k_ptp_instance_index);

} /* grandmaster_clock_quality_get */


/**
 * @brief Get database object callback for container protocol-address (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/parent-ds/protocol-address\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t protocol_address_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter protocol_address_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_protocol_address_get(
        get2cb,
        k_ptp_instance_index);

} /* protocol_address_get */


/**
 * @brief Get database object callback for container parent-ds (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/parent-ds\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t parent_ds_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter parent_ds_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_parent_ds_get(
        get2cb,
        k_ptp_instance_index);

} /* parent_ds_get */


/**
 * @brief Get database object callback for container time-properties-ds (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/time-properties-ds\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t time_properties_ds_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter time_properties_ds_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_time_properties_ds_get(
        get2cb,
        k_ptp_instance_index);

} /* time_properties_ds_get */


#ifdef u_ptp_F_fault_log

/**
 * @brief Get database object callback for container time (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/fault-log-ds/fault-record-list/time\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t time_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter time_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_time_get(
        get2cb,
        k_ptp_instance_index);

} /* time_get */


/**
 * @brief Get database object callback for list fault-record-list (getcb_fn2_t)\n
 * Path: list /ptp/instances/instance/fault-log-ds/fault-record-list\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t fault_record_list_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter fault_record_list_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_fault_record_list_get(
        get2cb,
        k_ptp_instance_index);

} /* fault_record_list_get */


/**
 * @brief YANG 1.1 action validate callback. (agt_action_cb_t)\n
 * Path: /ptp/instances/instance/fault-log-ds/reset
 *
 * @param scb session invoking the "<action>" RPC
 * @param msg message in progress for this "<rpc>" request
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @param actionval the nested 'action-method-name' node that was parsed
 * within the topval subtree, in the RPC "<action>" request.
 * This is used to help derive the list keys.
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
static status_t reset_action_val (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode,
    val_value_t *actionval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_action_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter reset_action_val for action <reset>");
    }

    res = u_reset_action_val(
        scb, msg, methnode, actionval,
        k_ptp_instance_index);
    return res;

} /* reset_action_val */


/**
 * @brief YANG 1.1 action invoke callback. (agt_action_cb_t)\n
 * Path: /ptp/instances/instance/fault-log-ds/reset
 *
 * @param scb session invoking the "<action>" RPC
 * @param msg message in progress for this "<rpc>" request
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @param actionval the nested 'action-method-name' node that was parsed
 * within the topval subtree, in the RPC "<action>" request.
 * This is used to help derive the list keys.
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
static status_t reset_action_inv (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode,
    val_value_t *actionval)
{
    status_t res = NO_ERR;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_action_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter reset_action_inv for action <reset>");
    }

    res = u_reset_action_inv(
        scb, msg, methnode, actionval,
        k_ptp_instance_index);
    return res;

} /* reset_action_inv */


/**
 * @brief Get database object callback for container fault-log-ds (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/fault-log-ds\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t fault_log_ds_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter fault_log_ds_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_fault_log_ds_get(
        get2cb,
        k_ptp_instance_index);

} /* fault_log_ds_get */

#endif /* u_ptp_F_fault_log */


#ifdef u_ptp_F_path_trace

/**
 * @brief Get database object callback for leaf-list list (getcb_fn2_t)\n
 * Path: leaf-list /ptp/instances/instance/path-trace-ds/list\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t list_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter list_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_list_get(
        get2cb,
        k_ptp_instance_index);

} /* list_get */

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/path-trace-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t path_trace_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter path_trace_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_path_trace_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* path_trace_ds_edit */
#endif /* u_ptp_F_path_trace */


#ifdef u_ptp_F_alternate_timescale

/**
 * @brief Get database object callback for leaf max-key (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/alternate-timescale-ds/max-key\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t max_key_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter max_key_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_max_key_get(
        get2cb,
        k_ptp_instance_index);

} /* max_key_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance/alternate-timescale-ds/list
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t list_1_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* local key ieee1588-ptp:key-field */
    uint8 k_ptp_key_field =
        VAL_UINT8(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter list_1_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_list_1_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_key_field);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* list_1_edit */

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/alternate-timescale-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t alternate_timescale_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter alternate_timescale_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_alternate_timescale_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* alternate_timescale_ds_edit */
#endif /* u_ptp_F_alternate_timescale */


#ifdef u_ptp_F_holdover_upgrade
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/holdover-upgrade-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t holdover_upgrade_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter holdover_upgrade_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_holdover_upgrade_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* holdover_upgrade_ds_edit */
#endif /* u_ptp_F_holdover_upgrade */


#ifdef u_ptp_F_grandmaster_cluster

/**
 * @brief Get database object callback for leaf max-table-size (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/grandmaster-cluster-ds/max-table-size\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t max_table_size_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter max_table_size_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_max_table_size_get(
        get2cb,
        k_ptp_instance_index);

} /* max_table_size_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance/grandmaster-cluster-ds/port-address
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t port_address_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* local key ieee1588-ptp:index */
    uint16 k_ptp_index =
        VAL_UINT16(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter port_address_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_port_address_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* port_address_edit */

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/grandmaster-cluster-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t grandmaster_cluster_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter grandmaster_cluster_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_grandmaster_cluster_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* grandmaster_cluster_ds_edit */
#endif /* u_ptp_F_grandmaster_cluster */


#ifdef u_ptp_F_acceptable_master

/**
 * @brief Get database object callback for leaf max-table-size (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/acceptable-master-ds/max-table-size\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t max_table_size_1_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter max_table_size_1_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    return u_ptp_max_table_size_1_get(
        get2cb,
        k_ptp_instance_index);

} /* max_table_size_1_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/acceptable-master-ds/list/acceptable-port-identity
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t acceptable_port_identity_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key ieee1588-ptp:index */
    uint8 k_ptp_index_1 =
        VAL_UINT8(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter acceptable_port_identity_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_acceptable_port_identity_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_index_1);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* acceptable_port_identity_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance/acceptable-master-ds/list
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t list_2_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* local key ieee1588-ptp:index */
    uint8 k_ptp_index_1 =
        VAL_UINT8(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter list_2_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_list_2_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_index_1);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* list_2_edit */

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/acceptable-master-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t acceptable_master_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter acceptable_master_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_acceptable_master_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* acceptable_master_ds_edit */
#endif /* u_ptp_F_acceptable_master */


#ifdef u_ptp_F_performance_monitoring

/**
 * @brief Get database object callback for list record-list (getcb_fn2_t)\n
 * Path: list /ptp/instances/instance/performance-monitoring-ds/record-list\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t record_list_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter record_list_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* local key ieee1588-ptp:index */
    uint16 k_ptp_index_2 = 0;
    boolean index_fixed = FALSE;
    boolean index_present = FALSE;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_index,
        (uint32)6);
    if (keyval) {
        k_ptp_index_2 = VAL_UINT16(keyval);
        index_fixed = VAL_IS_FIXED_VALUE(keyval);
        index_present = TRUE;
    }

    return u_ptp_record_list_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_index_2,
        index_fixed,
        index_present);

} /* record_list_get */

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/performance-monitoring-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t performance_monitoring_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter performance_monitoring_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_performance_monitoring_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* performance_monitoring_ds_edit */
#endif /* u_ptp_F_performance_monitoring */


#ifdef u_ptp_F_enhanced_metrics
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/enhanced-metrics-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t enhanced_metrics_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter enhanced_metrics_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_enhanced_metrics_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* enhanced_metrics_ds_edit */
#endif /* u_ptp_F_enhanced_metrics */


/**
 * @brief Get database object callback for container port-identity (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/ports/port/port-ds/port-identity\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t port_identity_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter port_identity_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_port_identity_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* port_identity_get */


/**
 * @brief Get database object callback for leaf mean-link-delay (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/mean-link-delay\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t mean_link_delay_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter mean_link_delay_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_mean_link_delay_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* mean_link_delay_get */


/**
 * @brief Get database object callback for leaf log-sync-interval (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/log-sync-interval\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t log_sync_interval_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter log_sync_interval_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_log_sync_interval_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* log_sync_interval_get */


/**
 * @brief Get database object callback for leaf delay-mechanism (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/delay-mechanism\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t delay_mechanism_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter delay_mechanism_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_delay_mechanism_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* delay_mechanism_get */


/**
 * @brief Get database object callback for leaf version-number (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/version-number\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t version_number_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter version_number_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_version_number_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* version_number_get */


/**
 * @brief Get database object callback for leaf minor-version-number (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/minor-version-number\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t minor_version_number_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter minor_version_number_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_minor_version_number_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* minor_version_number_get */


/**
 * @brief Get database object callback for leaf delay-asymmetry (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/delay-asymmetry\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t delay_asymmetry_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter delay_asymmetry_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_delay_asymmetry_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* delay_asymmetry_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index =
        VAL_UINT16(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_port_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_port_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* port_ds_edit */


#ifdef u_ptp_F_timestamp_correction
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/timestamp-correction-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t timestamp_correction_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index =
        VAL_UINT16(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter timestamp_correction_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_timestamp_correction_port_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_port_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* timestamp_correction_port_ds_edit */
#endif /* u_ptp_F_timestamp_correction */


#ifdef u_ptp_F_asymmetry_correction
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/asymmetry-correction-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t asymmetry_correction_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index =
        VAL_UINT16(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter asymmetry_correction_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_asymmetry_correction_port_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_port_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* asymmetry_correction_port_ds_edit */
#endif /* u_ptp_F_asymmetry_correction */


#ifdef u_ptp_F_unicast_negotiation
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/unicast-negotiation-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t unicast_negotiation_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index =
        VAL_UINT16(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter unicast_negotiation_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_unicast_negotiation_port_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_port_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* unicast_negotiation_port_ds_edit */
#endif /* u_ptp_F_unicast_negotiation */


#ifdef u_ptp_F_alternate_master
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/alternate-master-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t alternate_master_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index =
        VAL_UINT16(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter alternate_master_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_alternate_master_port_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_port_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* alternate_master_port_ds_edit */
#endif /* u_ptp_F_alternate_master */


#ifdef u_ptp_F_unicast_discovery

/**
 * @brief Get database object callback for leaf max-table-size (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/unicast-discovery-port-ds/max-table-size\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t max_table_size_2_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter max_table_size_2_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_max_table_size_2_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* max_table_size_2_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance/ports/port/unicast-discovery-port-ds/port-address
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t port_address_1_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index =
        VAL_UINT16(sil_sa_get_key(msg, 2));

    /* local key ieee1588-ptp:index */
    uint16 k_ptp_index_3 =
        VAL_UINT16(sil_sa_get_key(msg, 3));

    if (LOGDEBUG) {
        log_debug("\nEnter port_address_1_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_port_address_1_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_port_index,
        k_ptp_index_3);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* port_address_1_edit */

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/unicast-discovery-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t unicast_discovery_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index =
        VAL_UINT16(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter unicast_discovery_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_unicast_discovery_port_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_port_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* unicast_discovery_port_ds_edit */
#endif /* u_ptp_F_unicast_discovery */


#ifdef u_ptp_F_acceptable_master
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/acceptable-master-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t acceptable_master_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index =
        VAL_UINT16(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter acceptable_master_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_acceptable_master_port_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_port_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* acceptable_master_port_ds_edit */
#endif /* u_ptp_F_acceptable_master */


#ifdef u_ptp_F_l1_sync

/**
 * @brief Get database object callback for leaf link-alive (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/link-alive\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t link_alive_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter link_alive_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_link_alive_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* link_alive_get */


/**
 * @brief Get database object callback for leaf is-tx-coherent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/is-tx-coherent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t is_tx_coherent_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter is_tx_coherent_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_is_tx_coherent_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* is_tx_coherent_get */


/**
 * @brief Get database object callback for leaf is-rx-coherent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/is-rx-coherent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t is_rx_coherent_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter is_rx_coherent_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_is_rx_coherent_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* is_rx_coherent_get */


/**
 * @brief Get database object callback for leaf is-congruent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/is-congruent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t is_congruent_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter is_congruent_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_is_congruent_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* is_congruent_get */


/**
 * @brief Get database object callback for leaf l1sync-state (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/l1sync-state\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t l1sync_state_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter l1sync_state_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_l1sync_state_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* l1sync_state_get */


/**
 * @brief Get database object callback for leaf peer-tx-coherent-is-required (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-tx-coherent-is-required\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t peer_tx_coherent_is_required_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter peer_tx_coherent_is_required_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_peer_tx_coherent_is_required_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* peer_tx_coherent_is_required_get */


/**
 * @brief Get database object callback for leaf peer-rx-coherent-is-required (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-rx-coherent-is-required\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t peer_rx_coherent_is_required_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter peer_rx_coherent_is_required_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_peer_rx_coherent_is_required_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* peer_rx_coherent_is_required_get */


/**
 * @brief Get database object callback for leaf peer-congruent-is-required (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-congruent-is-required\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t peer_congruent_is_required_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter peer_congruent_is_required_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_peer_congruent_is_required_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* peer_congruent_is_required_get */


/**
 * @brief Get database object callback for leaf peer-is-tx-coherent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-is-tx-coherent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t peer_is_tx_coherent_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter peer_is_tx_coherent_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_peer_is_tx_coherent_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* peer_is_tx_coherent_get */


/**
 * @brief Get database object callback for leaf peer-is-rx-coherent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-is-rx-coherent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t peer_is_rx_coherent_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter peer_is_rx_coherent_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_peer_is_rx_coherent_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* peer_is_rx_coherent_get */


/**
 * @brief Get database object callback for leaf peer-is-congruent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-is-congruent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t peer_is_congruent_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter peer_is_congruent_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_peer_is_congruent_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* peer_is_congruent_get */

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/l1-sync-basic-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t l1_sync_basic_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index =
        VAL_UINT16(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter l1_sync_basic_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_l1_sync_basic_port_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_port_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* l1_sync_basic_port_ds_edit */
#endif /* u_ptp_F_l1_sync */


#ifdef u_ptp_F_l1_sync

/**
 * @brief Get database object callback for leaf phase-offset-tx-valid (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx-valid\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t phase_offset_tx_valid_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter phase_offset_tx_valid_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_phase_offset_tx_valid_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* phase_offset_tx_valid_get */


/**
 * @brief Get database object callback for leaf phase-offset-tx (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t phase_offset_tx_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter phase_offset_tx_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_phase_offset_tx_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* phase_offset_tx_get */


/**
 * @brief Get database object callback for container phase-offset-tx-timestamp (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx-timestamp\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t phase_offset_tx_timestamp_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter phase_offset_tx_timestamp_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_phase_offset_tx_timestamp_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* phase_offset_tx_timestamp_get */


/**
 * @brief Get database object callback for leaf frequency-offset-tx-valid (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx-valid\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t frequency_offset_tx_valid_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter frequency_offset_tx_valid_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_frequency_offset_tx_valid_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* frequency_offset_tx_valid_get */


/**
 * @brief Get database object callback for leaf frequency-offset-tx (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t frequency_offset_tx_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter frequency_offset_tx_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_frequency_offset_tx_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* frequency_offset_tx_get */


/**
 * @brief Get database object callback for container frequency-offset-tx-timestamp (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx-timestamp\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t frequency_offset_tx_timestamp_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter frequency_offset_tx_timestamp_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    return u_ptp_frequency_offset_tx_timestamp_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index);

} /* frequency_offset_tx_timestamp_get */

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t l1_sync_opt_params_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index =
        VAL_UINT16(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter l1_sync_opt_params_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_l1_sync_opt_params_port_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_port_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* l1_sync_opt_params_port_ds_edit */
#endif /* u_ptp_F_l1_sync */


#ifdef u_ptp_F_performance_monitoring

/**
 * @brief Get database object callback for list record-list-peer-delay (getcb_fn2_t)\n
 * Path: list /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t record_list_peer_delay_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter record_list_peer_delay_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    /* local key ieee1588-ptp:index */
    uint16 k_ptp_index_4 = 0;
    boolean index_fixed = FALSE;
    boolean index_present = FALSE;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_index,
        (uint32)8);
    if (keyval) {
        k_ptp_index_4 = VAL_UINT16(keyval);
        index_fixed = VAL_IS_FIXED_VALUE(keyval);
        index_present = TRUE;
    }

    return u_ptp_record_list_peer_delay_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index,
        k_ptp_index_4,
        index_fixed,
        index_present);

} /* record_list_peer_delay_get */


/**
 * @brief Get database object callback for list record-list (getcb_fn2_t)\n
 * Path: list /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t record_list_1_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter record_list_1_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_instance_index,
        (uint32)4);
    if (keyval) {
        k_ptp_instance_index = VAL_UINT(keyval);
    }

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_port_index,
        (uint32)6);
    if (keyval) {
        k_ptp_port_index = VAL_UINT16(keyval);
    }

    /* local key ieee1588-ptp:index */
    uint16 k_ptp_index_5 = 0;
    boolean index_fixed = FALSE;
    boolean index_present = FALSE;
    keyval = getcb_find_key_lvl(get2cb,
        y_ptp_M_ptp,
        y_ptp_N_index,
        (uint32)8);
    if (keyval) {
        k_ptp_index_5 = VAL_UINT16(keyval);
        index_fixed = VAL_IS_FIXED_VALUE(keyval);
        index_present = TRUE;
    }

    return u_ptp_record_list_1_get(
        get2cb,
        k_ptp_instance_index,
        k_ptp_port_index,
        k_ptp_index_5,
        index_fixed,
        index_present);

} /* record_list_1_get */

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/performance-monitoring-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t performance_monitoring_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index =
        VAL_UINT16(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter performance_monitoring_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_performance_monitoring_port_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_port_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* performance_monitoring_port_ds_edit */
#endif /* u_ptp_F_performance_monitoring */


#ifdef u_ptp_F_external_port_config
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/external-port-config-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t external_port_config_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index =
        VAL_UINT16(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter external_port_config_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_external_port_config_port_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_port_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* external_port_config_port_ds_edit */
#endif /* u_ptp_F_external_port_config */


#ifdef u_ptp_F_slave_monitoring
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/slave-monitoring-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t slave_monitoring_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index =
        VAL_UINT16(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter slave_monitoring_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_slave_monitoring_port_ds_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_port_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* slave_monitoring_port_ds_edit */
#endif /* u_ptp_F_slave_monitoring */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance/ports/port
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* local key ieee1588-ptp:port-index */
    uint16 k_ptp_port_index =
        VAL_UINT16(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_port_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index,
        k_ptp_port_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* port_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t ports_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter ports_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_ports_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* ports_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t instance_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* local key ieee1588-ptp:instance-index */
    uint32 k_ptp_instance_index =
        VAL_UINT(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter instance_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_instance_edit(scb, msg, cbtyp, editop, newval, curval,
        k_ptp_instance_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* instance_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t instances_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    if (LOGDEBUG) {
        log_debug("\nEnter instances_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_instances_edit(scb, msg, cbtyp, editop, newval, curval);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* instances_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t ptp_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    if (LOGDEBUG) {
        log_debug("\nEnter ptp_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_ptp_ptp_edit(scb, msg, cbtyp, editop, newval, curval);

    if (res == NO_ERR && cbtyp == AGT_CB_COMMIT) {
        res = agt_check_cache(&ptp_val, newval, curval, editop);
    }


    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* ptp_edit */


/**
 * @brief Phase 1: Initialize the ieee1588-ptp server instrumentation library.
 *
 * Called by server when module is loaded.
 *
 * @param modname requested module name to load
 * @param revision requested revision date of the module to load.
 * This may be NULL if the module has no revision statements.
 * @return return status. An error will cause the module load to fail.
 */
status_t y_ieee1588_ptp_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter y_ieee1588_ptp_init");
    }


    y_ptp_init_static_vars();

    /* change if custom handling done */
    if (xml_strcmp(modname, y_ptp_M_ptp)) {
        return ERR_NCX_UNKNOWN_MODULE;
    }

    if (revision && xml_strcmp(revision, y_ptp_R_ptp)) {
        return ERR_NCX_WRONG_VERSION;
    }

    /* Feature: ieee1588-ptp:fault-log */
    res = ncx_set_feature_enable(
        y_ptp_M_ptp,
        (const xmlChar *)"fault-log",
#ifdef u_ptp_F_fault_log
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee1588-ptp:unicast-negotiation */
    res = ncx_set_feature_enable(
        y_ptp_M_ptp,
        (const xmlChar *)"unicast-negotiation",
#ifdef u_ptp_F_unicast_negotiation
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee1588-ptp:path-trace */
    res = ncx_set_feature_enable(
        y_ptp_M_ptp,
        (const xmlChar *)"path-trace",
#ifdef u_ptp_F_path_trace
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee1588-ptp:alternate-timescale */
    res = ncx_set_feature_enable(
        y_ptp_M_ptp,
        (const xmlChar *)"alternate-timescale",
#ifdef u_ptp_F_alternate_timescale
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee1588-ptp:holdover-upgrade */
    res = ncx_set_feature_enable(
        y_ptp_M_ptp,
        (const xmlChar *)"holdover-upgrade",
#ifdef u_ptp_F_holdover_upgrade
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee1588-ptp:cmlds */
    res = ncx_set_feature_enable(
        y_ptp_M_ptp,
        (const xmlChar *)"cmlds",
#ifdef u_ptp_F_cmlds
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee1588-ptp:timestamp-correction */
    res = ncx_set_feature_enable(
        y_ptp_M_ptp,
        (const xmlChar *)"timestamp-correction",
#ifdef u_ptp_F_timestamp_correction
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee1588-ptp:asymmetry-correction */
    res = ncx_set_feature_enable(
        y_ptp_M_ptp,
        (const xmlChar *)"asymmetry-correction",
#ifdef u_ptp_F_asymmetry_correction
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee1588-ptp:slave-monitoring */
    res = ncx_set_feature_enable(
        y_ptp_M_ptp,
        (const xmlChar *)"slave-monitoring",
#ifdef u_ptp_F_slave_monitoring
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee1588-ptp:enhanced-metrics */
    res = ncx_set_feature_enable(
        y_ptp_M_ptp,
        (const xmlChar *)"enhanced-metrics",
#ifdef u_ptp_F_enhanced_metrics
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee1588-ptp:grandmaster-cluster */
    res = ncx_set_feature_enable(
        y_ptp_M_ptp,
        (const xmlChar *)"grandmaster-cluster",
#ifdef u_ptp_F_grandmaster_cluster
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee1588-ptp:alternate-master */
    res = ncx_set_feature_enable(
        y_ptp_M_ptp,
        (const xmlChar *)"alternate-master",
#ifdef u_ptp_F_alternate_master
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee1588-ptp:unicast-discovery */
    res = ncx_set_feature_enable(
        y_ptp_M_ptp,
        (const xmlChar *)"unicast-discovery",
#ifdef u_ptp_F_unicast_discovery
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee1588-ptp:acceptable-master */
    res = ncx_set_feature_enable(
        y_ptp_M_ptp,
        (const xmlChar *)"acceptable-master",
#ifdef u_ptp_F_acceptable_master
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee1588-ptp:external-port-config */
    res = ncx_set_feature_enable(
        y_ptp_M_ptp,
        (const xmlChar *)"external-port-config",
#ifdef u_ptp_F_external_port_config
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee1588-ptp:performance-monitoring */
    res = ncx_set_feature_enable(
        y_ptp_M_ptp,
        (const xmlChar *)"performance-monitoring",
#ifdef u_ptp_F_performance_monitoring
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee1588-ptp:l1-sync */
    res = ncx_set_feature_enable(
        y_ptp_M_ptp,
        (const xmlChar *)"l1-sync",
#ifdef u_ptp_F_l1_sync
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }


    res = ncxmod_load_module(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        agt_get_savedevQ(),
        &ieee1588_ptp_mod);
    if (res != NO_ERR) {
        return res;
    }

    ptp_obj = ncx_find_object(
        ieee1588_ptp_mod,
        y_ptp_N_ptp);
    if (ptp_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    res = agt_cb_register_edit2_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp",
        y_ptp_R_ptp,
        ptp_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances",
        y_ptp_R_ptp,
        instances_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance",
        y_ptp_R_ptp,
        instance_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:default-ds",
        y_ptp_R_ptp,
        default_ds_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:default-ds/ptp:clock-identity",
        y_ptp_R_ptp,
        clock_identity_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:default-ds/ptp:number-ports",
        y_ptp_R_ptp,
        number_ports_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:default-ds/ptp:clock-quality",
        y_ptp_R_ptp,
        clock_quality_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:default-ds/ptp:domain-number",
        y_ptp_R_ptp,
        domain_number_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:default-ds/ptp:sdo-id",
        y_ptp_R_ptp,
        sdo_id_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:default-ds/ptp:current-time",
        y_ptp_R_ptp,
        current_time_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:default-ds/ptp:max-steps-removed",
        y_ptp_R_ptp,
        max_steps_removed_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:current-ds",
        y_ptp_R_ptp,
        current_ds_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:parent-ds",
        y_ptp_R_ptp,
        parent_ds_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:parent-ds/ptp:parent-port-identity",
        y_ptp_R_ptp,
        parent_port_identity_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:parent-ds/ptp:grandmaster-clock-quality",
        y_ptp_R_ptp,
        grandmaster_clock_quality_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:parent-ds/ptp:protocol-address",
        y_ptp_R_ptp,
        protocol_address_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:time-properties-ds",
        y_ptp_R_ptp,
        time_properties_ds_get);
    if (res != NO_ERR) {
        return res;
    }


#ifdef u_ptp_F_fault_log
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"fault-log")) {
        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:fault-log-ds",
            y_ptp_R_ptp,
            fault_log_ds_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:fault-log-ds/ptp:fault-record-list",
            y_ptp_R_ptp,
            fault_record_list_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:fault-log-ds/ptp:fault-record-list/ptp:time",
            y_ptp_R_ptp,
            time_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_action_register_action(
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:fault-log-ds/ptp:reset",
                AGT_RPC_PH_VALIDATE,
                reset_action_val);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_action_register_action(
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:fault-log-ds/ptp:reset",
                AGT_RPC_PH_INVOKE,
                reset_action_inv);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_fault_log */
#endif /* u_ptp_F_fault_log */


#ifdef u_ptp_F_path_trace
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"path-trace")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:path-trace-ds",
            y_ptp_R_ptp,
            path_trace_ds_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:path-trace-ds/ptp:list",
            y_ptp_R_ptp,
            list_get);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_path_trace */
#endif /* u_ptp_F_path_trace */


#ifdef u_ptp_F_alternate_timescale
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"alternate-timescale")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:alternate-timescale-ds",
            y_ptp_R_ptp,
            alternate_timescale_ds_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:alternate-timescale-ds/ptp:max-key",
            y_ptp_R_ptp,
            max_key_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:alternate-timescale-ds/ptp:list",
            y_ptp_R_ptp,
            list_1_edit);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_alternate_timescale */
#endif /* u_ptp_F_alternate_timescale */


#ifdef u_ptp_F_holdover_upgrade
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"holdover-upgrade")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:holdover-upgrade-ds",
            y_ptp_R_ptp,
            holdover_upgrade_ds_edit);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_holdover_upgrade */
#endif /* u_ptp_F_holdover_upgrade */


#ifdef u_ptp_F_grandmaster_cluster
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"grandmaster-cluster")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:grandmaster-cluster-ds",
            y_ptp_R_ptp,
            grandmaster_cluster_ds_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:grandmaster-cluster-ds/ptp:max-table-size",
            y_ptp_R_ptp,
            max_table_size_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:grandmaster-cluster-ds/ptp:port-address",
            y_ptp_R_ptp,
            port_address_edit);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_grandmaster_cluster */
#endif /* u_ptp_F_grandmaster_cluster */


#ifdef u_ptp_F_acceptable_master
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"acceptable-master")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:acceptable-master-ds",
            y_ptp_R_ptp,
            acceptable_master_ds_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:acceptable-master-ds/ptp:max-table-size",
            y_ptp_R_ptp,
            max_table_size_1_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:acceptable-master-ds/ptp:list",
            y_ptp_R_ptp,
            list_2_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:acceptable-master-ds/ptp:list/ptp:acceptable-port-identity",
            y_ptp_R_ptp,
            acceptable_port_identity_edit);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_acceptable_master */
#endif /* u_ptp_F_acceptable_master */


#ifdef u_ptp_F_performance_monitoring
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"performance-monitoring")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:performance-monitoring-ds",
            y_ptp_R_ptp,
            performance_monitoring_ds_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:performance-monitoring-ds/ptp:record-list",
            y_ptp_R_ptp,
            record_list_get);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_performance_monitoring */
#endif /* u_ptp_F_performance_monitoring */


#ifdef u_ptp_F_enhanced_metrics
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"enhanced-metrics")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:enhanced-metrics-ds",
            y_ptp_R_ptp,
            enhanced_metrics_ds_edit);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_enhanced_metrics */
#endif /* u_ptp_F_enhanced_metrics */

    res = agt_cb_register_edit2_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports",
        y_ptp_R_ptp,
        ports_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port",
        y_ptp_R_ptp,
        port_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-ds",
        y_ptp_R_ptp,
        port_ds_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-ds/ptp:port-identity",
        y_ptp_R_ptp,
        port_identity_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-ds/ptp:mean-link-delay",
        y_ptp_R_ptp,
        mean_link_delay_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-ds/ptp:log-sync-interval",
        y_ptp_R_ptp,
        log_sync_interval_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-ds/ptp:delay-mechanism",
        y_ptp_R_ptp,
        delay_mechanism_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-ds/ptp:version-number",
        y_ptp_R_ptp,
        version_number_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-ds/ptp:minor-version-number",
        y_ptp_R_ptp,
        minor_version_number_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-ds/ptp:delay-asymmetry",
        y_ptp_R_ptp,
        delay_asymmetry_get);
    if (res != NO_ERR) {
        return res;
    }


#ifdef u_ptp_F_timestamp_correction
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"timestamp-correction")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:timestamp-correction-port-ds",
            y_ptp_R_ptp,
            timestamp_correction_port_ds_edit);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_timestamp_correction */
#endif /* u_ptp_F_timestamp_correction */


#ifdef u_ptp_F_asymmetry_correction
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"asymmetry-correction")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:asymmetry-correction-port-ds",
            y_ptp_R_ptp,
            asymmetry_correction_port_ds_edit);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_asymmetry_correction */
#endif /* u_ptp_F_asymmetry_correction */


#ifdef u_ptp_F_unicast_negotiation
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"unicast-negotiation")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:unicast-negotiation-port-ds",
            y_ptp_R_ptp,
            unicast_negotiation_port_ds_edit);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_unicast_negotiation */
#endif /* u_ptp_F_unicast_negotiation */


#ifdef u_ptp_F_alternate_master
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"alternate-master")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:alternate-master-port-ds",
            y_ptp_R_ptp,
            alternate_master_port_ds_edit);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_alternate_master */
#endif /* u_ptp_F_alternate_master */


#ifdef u_ptp_F_unicast_discovery
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"unicast-discovery")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:unicast-discovery-port-ds",
            y_ptp_R_ptp,
            unicast_discovery_port_ds_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:unicast-discovery-port-ds/ptp:max-table-size",
            y_ptp_R_ptp,
            max_table_size_2_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:unicast-discovery-port-ds/ptp:port-address",
            y_ptp_R_ptp,
            port_address_1_edit);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_unicast_discovery */
#endif /* u_ptp_F_unicast_discovery */


#ifdef u_ptp_F_acceptable_master
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"acceptable-master")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:acceptable-master-port-ds",
            y_ptp_R_ptp,
            acceptable_master_port_ds_edit);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_acceptable_master */
#endif /* u_ptp_F_acceptable_master */


#ifdef u_ptp_F_l1_sync
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"l1-sync")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-basic-port-ds",
            y_ptp_R_ptp,
            l1_sync_basic_port_ds_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-basic-port-ds/ptp:link-alive",
            y_ptp_R_ptp,
            link_alive_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-basic-port-ds/ptp:is-tx-coherent",
            y_ptp_R_ptp,
            is_tx_coherent_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-basic-port-ds/ptp:is-rx-coherent",
            y_ptp_R_ptp,
            is_rx_coherent_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-basic-port-ds/ptp:is-congruent",
            y_ptp_R_ptp,
            is_congruent_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-basic-port-ds/ptp:l1sync-state",
            y_ptp_R_ptp,
            l1sync_state_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-basic-port-ds/ptp:peer-tx-coherent-is-required",
            y_ptp_R_ptp,
            peer_tx_coherent_is_required_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-basic-port-ds/ptp:peer-rx-coherent-is-required",
            y_ptp_R_ptp,
            peer_rx_coherent_is_required_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-basic-port-ds/ptp:peer-congruent-is-required",
            y_ptp_R_ptp,
            peer_congruent_is_required_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-basic-port-ds/ptp:peer-is-tx-coherent",
            y_ptp_R_ptp,
            peer_is_tx_coherent_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-basic-port-ds/ptp:peer-is-rx-coherent",
            y_ptp_R_ptp,
            peer_is_rx_coherent_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-basic-port-ds/ptp:peer-is-congruent",
            y_ptp_R_ptp,
            peer_is_congruent_get);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_l1_sync */
#endif /* u_ptp_F_l1_sync */


#ifdef u_ptp_F_l1_sync
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"l1-sync")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-opt-params-port-ds",
            y_ptp_R_ptp,
            l1_sync_opt_params_port_ds_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-opt-params-port-ds/ptp:phase-offset-tx-valid",
            y_ptp_R_ptp,
            phase_offset_tx_valid_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-opt-params-port-ds/ptp:phase-offset-tx",
            y_ptp_R_ptp,
            phase_offset_tx_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-opt-params-port-ds/ptp:phase-offset-tx-timestamp",
            y_ptp_R_ptp,
            phase_offset_tx_timestamp_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-opt-params-port-ds/ptp:frequency-offset-tx-valid",
            y_ptp_R_ptp,
            frequency_offset_tx_valid_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-opt-params-port-ds/ptp:frequency-offset-tx",
            y_ptp_R_ptp,
            frequency_offset_tx_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-opt-params-port-ds/ptp:frequency-offset-tx-timestamp",
            y_ptp_R_ptp,
            frequency_offset_tx_timestamp_get);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_l1_sync */
#endif /* u_ptp_F_l1_sync */


#ifdef u_ptp_F_performance_monitoring
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"performance-monitoring")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:performance-monitoring-port-ds",
            y_ptp_R_ptp,
            performance_monitoring_port_ds_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:performance-monitoring-port-ds/ptp:record-list-peer-delay",
            y_ptp_R_ptp,
            record_list_peer_delay_get);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_get_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:performance-monitoring-port-ds/ptp:record-list",
            y_ptp_R_ptp,
            record_list_1_get);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_performance_monitoring */
#endif /* u_ptp_F_performance_monitoring */


#ifdef u_ptp_F_external_port_config
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"external-port-config")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:external-port-config-port-ds",
            y_ptp_R_ptp,
            external_port_config_port_ds_edit);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_external_port_config */
#endif /* u_ptp_F_external_port_config */


#ifdef u_ptp_F_slave_monitoring
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"slave-monitoring")) {
        res = agt_cb_register_edit2_callback(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:slave-monitoring-port-ds",
            y_ptp_R_ptp,
            slave_monitoring_port_ds_edit);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_ptp_F_slave_monitoring */
#endif /* u_ptp_F_slave_monitoring */

    res = u_ieee1588_ptp_init(modname, revision);
    return res;

} /* y_ieee1588_ptp_init */


/**
 * @brief Phase 2: Initialize the ieee1588-ptp server instrumentation library.
 *
 * SIL init phase 2: non-config data structures.
 * Called after running config is loaded.
 *
 * @return return status. An error will cause the
 * server initialization to fail.
 */
status_t y_ieee1588_ptp_init2 (void)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter y_ieee1588_ptp_init2");
    }


    res = u_ieee1588_ptp_init2();

    return res;

} /* y_ieee1588_ptp_init2 */


/**
 * @brief Cleanup the ieee1588-ptp server instrumentation library.
 *
 * Called by server when module is unloaded.
 *
 */
void y_ieee1588_ptp_cleanup (void)
{

    if (LOGDEBUG) {
        log_debug("\nEnter y_ieee1588_ptp_cleanup");
    }


    agt_cb_unregister_callbacks(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp");

    agt_cb_unregister_callbacks(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances");

    agt_cb_unregister_callbacks(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance");

    agt_cb_unregister_callbacks(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:default-ds");

    agt_cb_unregister_callbacks(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:default-ds/ptp:clock-quality");

    agt_cb_unregister_callbacks(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:default-ds/ptp:current-time");

    agt_cb_unregister_callbacks(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:current-ds");

    agt_cb_unregister_callbacks(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:parent-ds");

    agt_cb_unregister_callbacks(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:parent-ds/ptp:parent-port-identity");

    agt_cb_unregister_callbacks(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:parent-ds/ptp:grandmaster-clock-quality");

    agt_cb_unregister_callbacks(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:parent-ds/ptp:protocol-address");

    agt_cb_unregister_callbacks(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:time-properties-ds");


#ifdef u_ptp_F_fault_log
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"fault-log")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:fault-log-ds");

        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:fault-log-ds/ptp:fault-record-list");

        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:fault-log-ds/ptp:fault-record-list/ptp:time");

        agt_action_unregister_action(
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:fault-log-ds/ptp:reset");
    } /* u_ptp_F_fault_log */
#endif /* u_ptp_F_fault_log */


#ifdef u_ptp_F_path_trace
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"path-trace")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:path-trace-ds");
    } /* u_ptp_F_path_trace */
#endif /* u_ptp_F_path_trace */


#ifdef u_ptp_F_alternate_timescale
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"alternate-timescale")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:alternate-timescale-ds");

        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:alternate-timescale-ds/ptp:list");
    } /* u_ptp_F_alternate_timescale */
#endif /* u_ptp_F_alternate_timescale */


#ifdef u_ptp_F_holdover_upgrade
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"holdover-upgrade")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:holdover-upgrade-ds");
    } /* u_ptp_F_holdover_upgrade */
#endif /* u_ptp_F_holdover_upgrade */


#ifdef u_ptp_F_grandmaster_cluster
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"grandmaster-cluster")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:grandmaster-cluster-ds");

        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:grandmaster-cluster-ds/ptp:port-address");
    } /* u_ptp_F_grandmaster_cluster */
#endif /* u_ptp_F_grandmaster_cluster */


#ifdef u_ptp_F_acceptable_master
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"acceptable-master")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:acceptable-master-ds");

        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:acceptable-master-ds/ptp:list");

        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:acceptable-master-ds/ptp:list/ptp:acceptable-port-identity");
    } /* u_ptp_F_acceptable_master */
#endif /* u_ptp_F_acceptable_master */


#ifdef u_ptp_F_performance_monitoring
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"performance-monitoring")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:performance-monitoring-ds");

        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:performance-monitoring-ds/ptp:record-list");
    } /* u_ptp_F_performance_monitoring */
#endif /* u_ptp_F_performance_monitoring */


#ifdef u_ptp_F_enhanced_metrics
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"enhanced-metrics")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:enhanced-metrics-ds");
    } /* u_ptp_F_enhanced_metrics */
#endif /* u_ptp_F_enhanced_metrics */

    agt_cb_unregister_callbacks(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports");

    agt_cb_unregister_callbacks(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port");

    agt_cb_unregister_callbacks(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-ds");

    agt_cb_unregister_callbacks(
        y_ptp_M_ptp,
        (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-ds/ptp:port-identity");


#ifdef u_ptp_F_timestamp_correction
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"timestamp-correction")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:timestamp-correction-port-ds");
    } /* u_ptp_F_timestamp_correction */
#endif /* u_ptp_F_timestamp_correction */


#ifdef u_ptp_F_asymmetry_correction
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"asymmetry-correction")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:asymmetry-correction-port-ds");
    } /* u_ptp_F_asymmetry_correction */
#endif /* u_ptp_F_asymmetry_correction */


#ifdef u_ptp_F_unicast_negotiation
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"unicast-negotiation")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:unicast-negotiation-port-ds");
    } /* u_ptp_F_unicast_negotiation */
#endif /* u_ptp_F_unicast_negotiation */


#ifdef u_ptp_F_alternate_master
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"alternate-master")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:alternate-master-port-ds");
    } /* u_ptp_F_alternate_master */
#endif /* u_ptp_F_alternate_master */


#ifdef u_ptp_F_unicast_discovery
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"unicast-discovery")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:unicast-discovery-port-ds");

        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:unicast-discovery-port-ds/ptp:port-address");
    } /* u_ptp_F_unicast_discovery */
#endif /* u_ptp_F_unicast_discovery */


#ifdef u_ptp_F_acceptable_master
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"acceptable-master")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:acceptable-master-port-ds");
    } /* u_ptp_F_acceptable_master */
#endif /* u_ptp_F_acceptable_master */


#ifdef u_ptp_F_l1_sync
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"l1-sync")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-basic-port-ds");
    } /* u_ptp_F_l1_sync */
#endif /* u_ptp_F_l1_sync */


#ifdef u_ptp_F_l1_sync
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"l1-sync")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-opt-params-port-ds");

        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-opt-params-port-ds/ptp:phase-offset-tx-timestamp");

        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:l1-sync-opt-params-port-ds/ptp:frequency-offset-tx-timestamp");
    } /* u_ptp_F_l1_sync */
#endif /* u_ptp_F_l1_sync */


#ifdef u_ptp_F_performance_monitoring
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"performance-monitoring")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:performance-monitoring-port-ds");

        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:performance-monitoring-port-ds/ptp:record-list-peer-delay");

        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:performance-monitoring-port-ds/ptp:record-list");
    } /* u_ptp_F_performance_monitoring */
#endif /* u_ptp_F_performance_monitoring */


#ifdef u_ptp_F_external_port_config
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"external-port-config")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:external-port-config-port-ds");
    } /* u_ptp_F_external_port_config */
#endif /* u_ptp_F_external_port_config */


#ifdef u_ptp_F_slave_monitoring
    if (ncx_feature_enabled_str(
        y_ptp_M_ptp,
        y_ptp_R_ptp,
        (const xmlChar *)"slave-monitoring")) {
        agt_cb_unregister_callbacks(
            y_ptp_M_ptp,
            (const xmlChar *)"/ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:slave-monitoring-port-ds");
    } /* u_ptp_F_slave_monitoring */
#endif /* u_ptp_F_slave_monitoring */

    u_ieee1588_ptp_cleanup();

} /* y_ieee1588_ptp_cleanup */


 /** @} */

/* END SIL-SA y_ieee1588-ptp.c */
