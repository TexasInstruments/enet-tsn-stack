/*
 * Copyright (c) 2023 Texas Instruments Incorporated
 * Copyright (c) 2023 Excelfore Corporation (https://excelfore.com)
 *
 * All rights reserved not granted herein.
 * Limited License.
 *
 * Texas Instruments Incorporated grants a world-wide, royalty-free,
 * non-exclusive license under copyrights and patents it now or hereafter
 * owns or controls to make, have made, use, import, offer to sell and sell ("Utilize")
 * this software subject to the terms herein. With respect to the foregoing patent
 * license, such license is granted solely to the extent that any such patent is necessary
 * to Utilize the software alone. The patent license shall not apply to any combinations which
 * include this software, other than combinations with devices manufactured by or for TI ("TI Devices").
 * No hardware patent is licensed hereunder.
 *
 * Redistributions must preserve existing copyright notices and reproduce this license (including the
 * above copyright notice and the disclaimer and (if applicable) source code license limitations below)
 * in the documentation and/or other materials provided with the distribution
 *
 * Redistribution and use in binary form, without modification, are permitted provided that the following
 * conditions are met:
 *
 * * No reverse engineering, decompilation, or disassembly of this software is permitted with respect to any
 * software provided in binary form.
 * * any redistribution and use are licensed by TI for use only with TI Devices.
 * * Nothing shall obligate TI to provide you with source code for the software licensed and provided to you in object code.
 *
 * If software source code is provided to you, modification and redistribution of the source code are permitted
 * provided that the following conditions are met:
 *
 * * any redistribution and use of the source code, including any resulting derivative works, are licensed by
 * TI for use only with TI Devices.
 * * any redistribution and use of any object code compiled from the source code and any resulting derivative
 * works, are licensed by TI for use only with TI Devices.
 *
 * Neither the name of Texas Instruments Incorporated nor the names of its suppliers may be used to endorse or
 * promote products derived from this software without specific prior written permission.
 *
 * DISCLAIMER.
 *
 * THIS SOFTWARE IS PROVIDED BY TI AND TI"S LICENSORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TI AND TI"S LICENSORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * Copyright (c) 2008 - 2012, Andy Bierman, All Rights Reserved.
 * Copyright (c) 2012 - 2022, YumaWorks, Inc., All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

/**
 * @file y_ieee802-dot1q-bridge.c
 * @brief YumaPro SIL-SA module for module ieee802-dot1q-bridge
 *

*** Generated by yangdump-sdk 21.10-12

<pre>

    YumaPro SIL-SA module
    bundle x4ucsilsa
    module ieee802-dot1q-bridge
    revision 2022-10-29
    prefix dot1q
    namespace urn:ieee:std:802.1Q:yang:ieee802-dot1q-bridge
    organization IEEE 802.1 Working Group
    Created: 2023-03-29T06:45:58Z

Online Developer Manual:
https://www.yumaworks.com/pub/21.10/dev/yumapro-dev-manual.html

    CLI parameters:
        defnames true
        deviation excelfore-interfaces
        deviation excelfore-gptp
        format yc
        indent 4
        module ietf-interfaces
        module ieee802-dot1q-bridge
        module ieee802-dot1q-tsn-config-uni
        module excelfore-interfaces
        module ieee1588-ptp
        module ieee802-dot1as-ptp
        module excelfore-gptp
        sil-bundle x4ucsilsa
        sil-edit2
        sil-get2
        sil-include tsn_uniconf/yangs/yang_db_access.h
        sil-include tsn_uniconf/yangs/yang_modules.h
        sil-sa
        unified true

  Short Name Mappings
    acceptable_frame = /interfaces/interface/bridge-port/acceptable-frame
    address = /interfaces/interface/bridge-port/address
    address_1 = /bridges/bridge/address
    address_2 = /bridges/bridge/component/address
    address_3 = /bridges/bridge/component/filtering-database/filtering-entry/address
    address_4 = /bridges/bridge/component/permanent-database/filtering-entry/address
    admin_point_to_point = /interfaces/interface/bridge-port/admin-point-to-point
    aging_time = /bridges/bridge/component/filtering-database/aging-time
    allocation_type = /bridges/bridge/component/bridge-vlan/vid-to-fid-allocation/allocation-type
    allocation_type_1 = /bridges/bridge/component/bridge-vlan/fid-to-vid-allocation/allocation-type
    available_traffic_class = /interfaces/interface/bridge-port/traffic-class/traffic-class-map/available-traffic-class
    bridge = /bridges/bridge
    bridge_mst = /bridges/bridge/component/bridge-mst
    bridge_port = /interfaces/interface/bridge-port
    bridge_port_1 = /bridges/bridge/component/bridge-port
    bridge_type = /bridges/bridge/bridge-type
    bridge_vlan = /bridges/bridge/component/bridge-vlan
    bridges = /bridges
    capabilities = /interfaces/interface/bridge-port/capabilities
    capabilities_1 = /bridges/bridge/component/capabilities
    component = /bridges/bridge/component
    component_name = /interfaces/interface/bridge-port/component-name
    components = /bridges/bridge/components
    configurable_pvid_tagging = /bridges/bridge/component/capabilities/configurable-pvid-tagging
    connection_identifier = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-filtering-entries/static-filtering-entries/connection-identifier
    connection_identifier_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-filtering-entries/static-filtering-entries/connection-identifier
    connection_identifier_2 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-filtering-entries/static-filtering-entries/connection-identifier
    control_element = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-filtering-entries/static-filtering-entries/control-element
    control_element_1 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries/control-element
    control_element_10 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-filtering-entries/static-filtering-entries/control-element
    control_element_11 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries/control-element
    control_element_12 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries/control-element
    control_element_13 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries/control-element
    control_element_14 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries/control-element
    control_element_2 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries/control-element
    control_element_3 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries/control-element
    control_element_4 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries/control-element
    control_element_5 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-filtering-entries/static-filtering-entries/control-element
    control_element_6 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries/control-element
    control_element_7 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries/control-element
    control_element_8 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries/control-element
    control_element_9 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries/control-element
    database_id = /bridges/bridge/component/filtering-database/filtering-entry/database-id
    database_id_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/database-id
    database_id_2 = /bridges/bridge/component/permanent-database/filtering-entry/database-id
    db_index = /bridges/bridge/component/bridge-vlan/protocol-group-database/db-index
    default_priority = /interfaces/interface/bridge-port/default-priority
    dei = /interfaces/interface/bridge-port/pcp-encoding-table/pcp-encoding-map/priority-map/dei
    delay_exceeded_discards = /interfaces/interface/bridge-port/statistics/delay-exceeded-discards
    discard_inbound = /interfaces/interface/bridge-port/statistics/discard-inbound
    discard_lack_of_buffers = /interfaces/interface/bridge-port/statistics/discard-lack-of-buffers
    discard_on_error = /interfaces/interface/bridge-port/statistics/discard-on-error
    discard_on_ingress_filtering = /interfaces/interface/bridge-port/statistics/discard-on-ingress-filtering
    discard_transit_delay_exceeded = /interfaces/interface/bridge-port/statistics/discard-transit-delay-exceeded
    drop_eligible = /interfaces/interface/bridge-port/pcp-decoding-table/pcp-decoding-map/priority-map/drop-eligible
    drop_encoding = /interfaces/interface/bridge-port/drop-encoding
    dsap_ssap_pairs = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format/llc-other/dsap-ssap-pairs
    dynamic_entries = /bridges/bridge/component/filtering-database/dynamic-entries
    dynamic_filtering_entries = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-filtering-entries
    dynamic_filtering_entries_1 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries
    dynamic_filtering_entries_2 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-filtering-entries
    dynamic_filtering_entries_3 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries
    dynamic_filtering_entries_4 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-filtering-entries
    dynamic_filtering_entries_5 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries
    dynamic_reservation_entries = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-reservation-entries
    dynamic_reservation_entries_1 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries
    dynamic_reservation_entries_2 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-reservation-entries
    dynamic_reservation_entries_3 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries
    dynamic_reservation_entries_4 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-reservation-entries
    dynamic_reservation_entries_5 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries
    dynamic_vlan_registration_entries = /bridges/bridge/component/filtering-database/dynamic-vlan-registration-entries
    dynamic_vlan_registration_entries_1 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-vlan-registration-entries
    dynamic_vlan_registration_entries_2 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries
    dynamic_vlan_registration_entries_3 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-vlan-registration-entries
    dynamic_vlan_registration_entries_4 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries
    dynamic_vlan_registration_entries_5 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-vlan-registration-entries
    dynamic_vlan_registration_entries_6 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries
    egress_ports = /bridges/bridge/component/bridge-vlan/vlan/egress-ports
    egress_vid_translations = /interfaces/interface/bridge-port/egress-vid-translations
    enable_egress_vid_translation_table = /interfaces/interface/bridge-port/enable-egress-vid-translation-table
    enable_ingress_filtering = /interfaces/interface/bridge-port/enable-ingress-filtering
    enable_restricted_vlan_registration = /interfaces/interface/bridge-port/enable-restricted-vlan-registration
    enable_vid_translation_table = /interfaces/interface/bridge-port/enable-vid-translation-table
    entry_type = /bridges/bridge/component/filtering-database/filtering-entry/entry-type
    entry_type_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/entry-type
    ethernet_rfc1042_snap8021H = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format/ethernet-rfc1042-snap8021H
    ethertype = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format/ethernet-rfc1042-snap8021H/ethertype
    extended_filtering = /bridges/bridge/component/capabilities/extended-filtering
    external = /interfaces/interface/bridge-port/external
    fid = /bridges/bridge/component/bridge-vlan/vid-to-fid-allocation/fid
    fid_1 = /bridges/bridge/component/bridge-vlan/fid-to-vid-allocation/fid
    fid_2 = /bridges/bridge/component/bridge-vlan/vid-to-fid/fid
    fid_3 = /bridges/bridge/component/bridge-mst/fid-to-mstid/fid
    fid_to_mstid = /bridges/bridge/component/bridge-mst/fid-to-mstid
    fid_to_mstid_allocation = /bridges/bridge/component/bridge-mst/fid-to-mstid-allocation
    fid_to_vid_allocation = /bridges/bridge/component/bridge-vlan/fid-to-vid-allocation
    fids = /bridges/bridge/component/bridge-mst/fid-to-mstid-allocation/fids
    filtering_database = /bridges/bridge/component/filtering-database
    filtering_entry = /bridges/bridge/component/filtering-database/filtering-entry
    filtering_entry_1 = /bridges/bridge/component/permanent-database/filtering-entry
    forward_outbound = /interfaces/interface/bridge-port/statistics/forward-outbound
    frame_format = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format
    frame_format_type = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format-type
    frame_rx = /interfaces/interface/bridge-port/statistics/frame-rx
    frame_tx = /interfaces/interface/bridge-port/statistics/frame-tx
    group_id = /interfaces/interface/bridge-port/protocol-group-vid-set/group-id
    group_id_1 = /bridges/bridge/component/bridge-vlan/protocol-group-database/group-id
    hybrid_capable = /bridges/bridge/component/capabilities/hybrid-capable
    id = /bridges/bridge/component/id
    ivl_capable = /bridges/bridge/component/capabilities/ivl-capable
    llc_address = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format/llc-other/dsap-ssap-pairs/llc-address
    llc_other = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format/llc-other
    local_vid = /interfaces/interface/bridge-port/vid-translations/local-vid
    local_vid_1 = /interfaces/interface/bridge-port/egress-vid-translations/local-vid
    local_vlan_capable = /bridges/bridge/component/capabilities/local-vlan-capable
    mac_address_registration_entries = /bridges/bridge/component/filtering-database/mac-address-registration-entries
    mac_address_registration_entries_1 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/mac-address-registration-entries
    mac_address_registration_entries_2 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries
    mac_address_registration_entries_3 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/mac-address-registration-entries
    mac_address_registration_entries_4 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries
    mac_address_registration_entries_5 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/mac-address-registration-entries
    mac_address_registration_entries_6 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries
    map_type = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type
    map_type_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type
    map_type_2 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type
    max_msti = /bridges/bridge/component/bridge-vlan/max-msti
    max_vid_set_entries = /interfaces/interface/bridge-port/max-vid-set-entries
    max_vids = /bridges/bridge/component/bridge-vlan/max-vids
    media_dependent_overhead = /interfaces/interface/bridge-port/media-dependent-overhead
    mstid = /bridges/bridge/component/bridge-mst/mstid
    mstid_1 = /bridges/bridge/component/bridge-mst/fid-to-mstid/mstid
    mstid_2 = /bridges/bridge/component/bridge-mst/fid-to-mstid-allocation/mstid
    mtu_exceeded_discards = /interfaces/interface/bridge-port/statistics/mtu-exceeded-discards
    name = /bridges/bridge/name
    name_1 = /bridges/bridge/component/name
    name_2 = /bridges/bridge/component/bridge-vlan/vlan/name
    num_traffic_class = /interfaces/interface/bridge-port/traffic-class/traffic-class-map/available-traffic-class/num-traffic-class
    octets_rx = /interfaces/interface/bridge-port/statistics/octets-rx
    octets_tx = /interfaces/interface/bridge-port/statistics/octets-tx
    oper_point_to_point = /interfaces/interface/bridge-port/oper-point-to-point
    override_default_pvid = /bridges/bridge/component/bridge-vlan/override-default-pvid
    pcp = /interfaces/interface/bridge-port/pcp-decoding-table/pcp-decoding-map/pcp
    pcp_1 = /interfaces/interface/bridge-port/pcp-encoding-table/pcp-encoding-map/pcp
    pcp_decoding_map = /interfaces/interface/bridge-port/pcp-decoding-table/pcp-decoding-map
    pcp_decoding_table = /interfaces/interface/bridge-port/pcp-decoding-table
    pcp_encoding_map = /interfaces/interface/bridge-port/pcp-encoding-table/pcp-encoding-map
    pcp_encoding_table = /interfaces/interface/bridge-port/pcp-encoding-table
    pcp_selection = /interfaces/interface/bridge-port/pcp-selection
    permanent_database = /bridges/bridge/component/permanent-database
    port_map = /bridges/bridge/component/filtering-database/filtering-entry/port-map
    port_map_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map
    port_map_2 = /bridges/bridge/component/permanent-database/filtering-entry/port-map
    port_number = /interfaces/interface/bridge-port/port-number
    port_ref = /bridges/bridge/component/filtering-database/filtering-entry/port-map/port-ref
    port_ref_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/port-ref
    port_ref_2 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/port-ref
    port_type = /interfaces/interface/bridge-port/port-type
    ports = /bridges/bridge/ports
    ports_1 = /bridges/bridge/component/ports
    priority = /interfaces/interface/bridge-port/pcp-decoding-table/pcp-decoding-map/priority-map/priority
    priority0 = /interfaces/interface/bridge-port/priority-regeneration/priority0
    priority0_1 = /interfaces/interface/bridge-port/service-access-priority/priority0
    priority1 = /interfaces/interface/bridge-port/priority-regeneration/priority1
    priority1_1 = /interfaces/interface/bridge-port/service-access-priority/priority1
    priority2 = /interfaces/interface/bridge-port/priority-regeneration/priority2
    priority2_1 = /interfaces/interface/bridge-port/service-access-priority/priority2
    priority3 = /interfaces/interface/bridge-port/priority-regeneration/priority3
    priority3_1 = /interfaces/interface/bridge-port/service-access-priority/priority3
    priority4 = /interfaces/interface/bridge-port/priority-regeneration/priority4
    priority4_1 = /interfaces/interface/bridge-port/service-access-priority/priority4
    priority5 = /interfaces/interface/bridge-port/priority-regeneration/priority5
    priority5_1 = /interfaces/interface/bridge-port/service-access-priority/priority5
    priority6 = /interfaces/interface/bridge-port/priority-regeneration/priority6
    priority6_1 = /interfaces/interface/bridge-port/service-access-priority/priority6
    priority7 = /interfaces/interface/bridge-port/priority-regeneration/priority7
    priority7_1 = /interfaces/interface/bridge-port/service-access-priority/priority7
    priority_1 = /interfaces/interface/bridge-port/pcp-encoding-table/pcp-encoding-map/priority-map/priority
    priority_2 = /interfaces/interface/bridge-port/traffic-class/traffic-class-map/priority
    priority_code_point = /interfaces/interface/bridge-port/pcp-decoding-table/pcp-decoding-map/priority-map/priority-code-point
    priority_code_point_1 = /interfaces/interface/bridge-port/pcp-encoding-table/pcp-encoding-map/priority-map/priority-code-point
    priority_map = /interfaces/interface/bridge-port/pcp-decoding-table/pcp-decoding-map/priority-map
    priority_map_1 = /interfaces/interface/bridge-port/pcp-encoding-table/pcp-encoding-map/priority-map
    priority_regeneration = /interfaces/interface/bridge-port/priority-regeneration
    protocol_based_vlan_classification = /interfaces/interface/bridge-port/protocol-based-vlan-classification
    protocol_group_database = /bridges/bridge/component/bridge-vlan/protocol-group-database
    protocol_group_vid_set = /interfaces/interface/bridge-port/protocol-group-vid-set
    protocol_id = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format/snap-other/protocol-id
    protocol_template = /bridges/bridge/component/bridge-vlan/protocol-template
    pvid = /interfaces/interface/bridge-port/pvid
    registrar_admin_control = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries/registrar-admin-control
    registrar_admin_control_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries/registrar-admin-control
    registrar_admin_control_2 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries/registrar-admin-control
    relay_vid = /interfaces/interface/bridge-port/vid-translations/relay-vid
    relay_vid_1 = /interfaces/interface/bridge-port/egress-vid-translations/relay-vid
    service_access_priority = /interfaces/interface/bridge-port/service-access-priority
    service_access_priority_selection = /interfaces/interface/bridge-port/service-access-priority-selection
    size = /bridges/bridge/component/filtering-database/size
    size_1 = /bridges/bridge/component/permanent-database/size
    snap_other = /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format/snap-other
    static_entries = /bridges/bridge/component/filtering-database/static-entries
    static_entries_1 = /bridges/bridge/component/permanent-database/static-entries
    static_entry_individual_port = /bridges/bridge/component/capabilities/static-entry-individual-port
    static_filtering_entries = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-filtering-entries
    static_filtering_entries_1 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-filtering-entries/static-filtering-entries
    static_filtering_entries_2 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-filtering-entries
    static_filtering_entries_3 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-filtering-entries/static-filtering-entries
    static_filtering_entries_4 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-filtering-entries
    static_filtering_entries_5 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-filtering-entries/static-filtering-entries
    static_vlan_registration_entries = /bridges/bridge/component/filtering-database/static-vlan-registration-entries
    static_vlan_registration_entries_1 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-vlan-registration-entries
    static_vlan_registration_entries_2 = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries
    static_vlan_registration_entries_3 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-vlan-registration-entries
    static_vlan_registration_entries_4 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries
    static_vlan_registration_entries_5 = /bridges/bridge/component/permanent-database/static-vlan-registration-entries
    static_vlan_registration_entries_6 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-vlan-registration-entries
    static_vlan_registration_entries_7 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries
    statistics = /interfaces/interface/bridge-port/statistics
    status = /bridges/bridge/component/filtering-database/filtering-entry/status
    status_1 = /bridges/bridge/component/permanent-database/filtering-entry/status
    svl_capable = /bridges/bridge/component/capabilities/svl-capable
    traffic_class = /interfaces/interface/bridge-port/traffic-class
    traffic_class_1 = /interfaces/interface/bridge-port/traffic-class/traffic-class-map/available-traffic-class/traffic-class
    traffic_class_2 = /interfaces/interface/bridge-port/transmission-selection-algorithm-table/transmission-selection-algorithm-map/traffic-class
    traffic_class_enabled = /bridges/bridge/component/traffic-class-enabled
    traffic_class_map = /interfaces/interface/bridge-port/traffic-class/traffic-class-map
    traffic_classes = /bridges/bridge/component/capabilities/traffic-classes
    transmission_selection_algorithm = /interfaces/interface/bridge-port/transmission-selection-algorithm-table/transmission-selection-algorithm-map/transmission-selection-algorithm
    transmission_selection_algorithm_map = /interfaces/interface/bridge-port/transmission-selection-algorithm-table/transmission-selection-algorithm-map
    transmission_selection_algorithm_table = /interfaces/interface/bridge-port/transmission-selection-algorithm-table
    type = /bridges/bridge/component/type
    type_capabilties = /interfaces/interface/bridge-port/type-capabilties
    untagged_ports = /bridges/bridge/component/bridge-vlan/vlan/untagged-ports
    up_time = /bridges/bridge/up-time
    use_dei = /interfaces/interface/bridge-port/use-dei
    version = /bridges/bridge/component/bridge-vlan/version
    vid = /interfaces/interface/bridge-port/protocol-group-vid-set/vid
    vid_1 = /bridges/bridge/component/bridge-vlan/vlan/vid
    vid_2 = /bridges/bridge/component/bridge-vlan/fid-to-vid-allocation/vid
    vid_3 = /bridges/bridge/component/bridge-vlan/vid-to-fid/vid
    vid_to_fid = /bridges/bridge/component/bridge-vlan/vid-to-fid
    vid_to_fid_allocation = /bridges/bridge/component/bridge-vlan/vid-to-fid-allocation
    vid_translations = /interfaces/interface/bridge-port/vid-translations
    vids = /bridges/bridge/component/filtering-database/filtering-entry/vids
    vids_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/vids
    vids_2 = /bridges/bridge/component/permanent-database/filtering-entry/vids
    vids_3 = /bridges/bridge/component/bridge-vlan/vid-to-fid-allocation/vids
    vlan = /bridges/bridge/component/bridge-vlan/vlan
    vlan_registration_entry = /bridges/bridge/component/filtering-database/vlan-registration-entry
    vlan_transmitted = /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries/vlan-transmitted
    vlan_transmitted_1 = /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries/vlan-transmitted
    vlan_transmitted_2 = /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries/vlan-transmitted
</pre>

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_action.h"
#include "agt_cb.h"
#include "agt_cfg.h"
#include "agt_rpc.h"
#include "agt_sil_lib.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "agt_val.h"
#include "cfg.h"
#include "dlq.h"
#include "getcb.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "obj.h"
#include "rpc.h"
#include "sil_sa.h"
#include "status.h"
#include "val.h"
#include "val_child.h"
#include "val_util.h"
#include "xml_val.h"

#include "tsn_uniconf/yangs/yang_db_access.h"
#include "tsn_uniconf/yangs/yang_modules.h"


/* SIL bundle: x4ucsilsa */
#include "y_ietf-interfaces.h"
#include "u_ietf-interfaces.h"
#include "y_ieee802-dot1q-bridge.h"
#include "u_ieee802-dot1q-bridge.h"
#include "y_ieee802-dot1q-tsn-config-uni.h"
#include "u_ieee802-dot1q-tsn-config-uni.h"
#include "y_excelfore-interfaces.h"
#include "u_excelfore-interfaces.h"
#include "y_ieee1588-ptp.h"
#include "u_ieee1588-ptp.h"
#include "y_ieee802-dot1as-ptp.h"
#include "u_ieee802-dot1as-ptp.h"
#include "y_excelfore-gptp.h"
#include "u_excelfore-gptp.h"


/**
 * @addtogroup yang-library YANG Library
 *
 * Collection of modules supported by the server.
 * Generated by yangdump-sdk.
 */



/**
 * @addtogroup silsa-x4ucsilsa-ieee802-dot1q-bridge Module ieee802-dot1q-bridge in Bundle x4ucsilsa
 * @ingroup silsa-x4ucsilsa
 *
 * @{
 *
 * YANG instrumentation library.
 * Generated by yangdump-sdk.
 */


/* module static variables */
static ncx_module_t *ieee802_dot1q_bridge_mod;
static obj_template_t *bridges_obj;
static val_value_t *bridges_val;

/**
 * @brief Initialize module static variables
 *
 * Called by server when module is loaded.
 */
static void y_dot1q_init_static_vars (void)
{
    ieee802_dot1q_bridge_mod = NULL;
    bridges_obj = NULL;
    bridges_val = NULL;

} /* y_dot1q_init_static_vars */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /interfaces/interface/bridge-port/priority-regeneration
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t priority_regeneration_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ietf-interfaces:name */
    const xmlChar *k_if_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter priority_regeneration_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_priority_regeneration_edit(scb, msg, cbtyp, editop, newval, curval,
        k_if_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* priority_regeneration_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /interfaces/interface/bridge-port/traffic-class
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t traffic_class_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ietf-interfaces:name */
    const xmlChar *k_if_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter traffic_class_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_traffic_class_edit(scb, msg, cbtyp, editop, newval, curval,
        k_if_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* traffic_class_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /interfaces/interface/bridge-port/transmission-selection-algorithm-table/transmission-selection-algorithm-map
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t transmission_selection_algorithm_map_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ietf-interfaces:name */
    const xmlChar *k_if_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* local key ieee802-dot1q-bridge:traffic-class */
    uint8 k_dot1q_traffic_class_2 =
        VAL_UINT8(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter transmission_selection_algorithm_map_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_transmission_selection_algorithm_map_edit(scb, msg, cbtyp, editop, newval, curval,
        k_if_name,
        k_dot1q_traffic_class_2);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* transmission_selection_algorithm_map_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /interfaces/interface/bridge-port/transmission-selection-algorithm-table
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t transmission_selection_algorithm_table_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ietf-interfaces:name */
    const xmlChar *k_if_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter transmission_selection_algorithm_table_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_transmission_selection_algorithm_table_edit(scb, msg, cbtyp, editop, newval, curval,
        k_if_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* transmission_selection_algorithm_table_edit */


/**
 * @brief Get database object callback for leaf address (getcb_fn2_t)\n
 * Path: leaf /interfaces/interface/bridge-port/address\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t address_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter address_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ietf-interfaces:name */
    const xmlChar *k_if_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_if_M_if,
        y_if_N_name,
        (uint32)3);
    if (keyval) {
        k_if_name = VAL_STRING(keyval);
    }

    return u_dot1q_address_get(
        get2cb,
        k_if_name);

} /* address_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /interfaces/interface/bridge-port
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t bridge_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ietf-interfaces:name */
    const xmlChar *k_if_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter bridge_port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_bridge_port_edit(scb, msg, cbtyp, editop, newval, curval,
        k_if_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* bridge_port_edit */


/**
 * @brief Get database object callback for leaf ports (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/ports\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t ports_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter ports_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    return u_dot1q_ports_get(
        get2cb,
        k_dot1q_name);

} /* ports_get */


/**
 * @brief Get database object callback for leaf up-time (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/up-time\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t up_time_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter up_time_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    return u_dot1q_up_time_get(
        get2cb,
        k_dot1q_name);

} /* up_time_get */


/**
 * @brief Get database object callback for leaf components (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/components\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t components_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter components_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    return u_dot1q_components_get(
        get2cb,
        k_dot1q_name);

} /* components_get */


/**
 * @brief Get database object callback for leaf ports (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/ports\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t ports_1_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter ports_1_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    return u_dot1q_ports_1_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1);

} /* ports_1_get */


/**
 * @brief Get database object callback for leaf-list bridge-port (getcb_fn2_t)\n
 * Path: leaf-list /bridges/bridge/component/bridge-port\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t bridge_port_1_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter bridge_port_1_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    return u_dot1q_bridge_port_1_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1);

} /* bridge_port_1_get */


/**
 * @brief Get database object callback for container capabilities (getcb_fn2_t)\n
 * Path: container /bridges/bridge/component/capabilities\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t capabilities_1_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter capabilities_1_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    return u_dot1q_capabilities_1_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1);

} /* capabilities_1_get */


/**
 * @brief Get database object callback for leaf size (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/filtering-database/size\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t size_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter size_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    return u_dot1q_size_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1);

} /* size_get */


/**
 * @brief Get database object callback for leaf static-entries (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/filtering-database/static-entries\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t static_entries_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter static_entries_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    return u_dot1q_static_entries_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1);

} /* static_entries_get */


/**
 * @brief Get database object callback for leaf dynamic-entries (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/filtering-database/dynamic-entries\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t dynamic_entries_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter dynamic_entries_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    return u_dot1q_dynamic_entries_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1);

} /* dynamic_entries_get */


/**
 * @brief Get database object callback for leaf static-vlan-registration-entries (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/filtering-database/static-vlan-registration-entries\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t static_vlan_registration_entries_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter static_vlan_registration_entries_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    return u_dot1q_static_vlan_registration_entries_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1);

} /* static_vlan_registration_entries_get */


/**
 * @brief Get database object callback for leaf dynamic-vlan-registration-entries (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/filtering-database/dynamic-vlan-registration-entries\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t dynamic_vlan_registration_entries_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter dynamic_vlan_registration_entries_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    return u_dot1q_dynamic_vlan_registration_entries_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1);

} /* dynamic_vlan_registration_entries_get */


#ifdef u_dot1q_F_extended_filtering_services

/**
 * @brief Get database object callback for leaf mac-address-registration-entries (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/filtering-database/mac-address-registration-entries\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t mac_address_registration_entries_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter mac_address_registration_entries_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    return u_dot1q_mac_address_registration_entries_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1);

} /* mac_address_registration_entries_get */

#endif /* u_dot1q_F_extended_filtering_services */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-filtering-entries/static-filtering-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t static_filtering_entries_1_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_3 =
        VAL_STRING(sil_sa_get_key(msg, 5));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref =
        VAL_UINT(sil_sa_get_key(msg, 6));

    if (LOGDEBUG) {
        log_debug("\nEnter static_filtering_entries_1_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_static_filtering_entries_1_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id,
        k_dot1q_vids,
        k_dot1q_address_3,
        k_dot1q_port_ref);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* static_filtering_entries_1_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t static_vlan_registration_entries_2_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_3 =
        VAL_STRING(sil_sa_get_key(msg, 5));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref =
        VAL_UINT(sil_sa_get_key(msg, 6));

    if (LOGDEBUG) {
        log_debug("\nEnter static_vlan_registration_entries_2_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_static_vlan_registration_entries_2_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id,
        k_dot1q_vids,
        k_dot1q_address_3,
        k_dot1q_port_ref);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* static_vlan_registration_entries_2_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t mac_address_registration_entries_2_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_3 =
        VAL_STRING(sil_sa_get_key(msg, 5));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref =
        VAL_UINT(sil_sa_get_key(msg, 6));

    if (LOGDEBUG) {
        log_debug("\nEnter mac_address_registration_entries_2_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_mac_address_registration_entries_2_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id,
        k_dot1q_vids,
        k_dot1q_address_3,
        k_dot1q_port_ref);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* mac_address_registration_entries_2_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t dynamic_vlan_registration_entries_2_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_3 =
        VAL_STRING(sil_sa_get_key(msg, 5));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref =
        VAL_UINT(sil_sa_get_key(msg, 6));

    if (LOGDEBUG) {
        log_debug("\nEnter dynamic_vlan_registration_entries_2_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_dynamic_vlan_registration_entries_2_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id,
        k_dot1q_vids,
        k_dot1q_address_3,
        k_dot1q_port_ref);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* dynamic_vlan_registration_entries_2_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t dynamic_reservation_entries_1_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_3 =
        VAL_STRING(sil_sa_get_key(msg, 5));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref =
        VAL_UINT(sil_sa_get_key(msg, 6));

    if (LOGDEBUG) {
        log_debug("\nEnter dynamic_reservation_entries_1_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_dynamic_reservation_entries_1_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id,
        k_dot1q_vids,
        k_dot1q_address_3,
        k_dot1q_port_ref);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* dynamic_reservation_entries_1_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/filtering-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t dynamic_filtering_entries_1_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_3 =
        VAL_STRING(sil_sa_get_key(msg, 5));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref =
        VAL_UINT(sil_sa_get_key(msg, 6));

    if (LOGDEBUG) {
        log_debug("\nEnter dynamic_filtering_entries_1_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_dynamic_filtering_entries_1_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id,
        k_dot1q_vids,
        k_dot1q_address_3,
        k_dot1q_port_ref);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* dynamic_filtering_entries_1_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/filtering-database/filtering-entry/port-map
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t port_map_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_3 =
        VAL_STRING(sil_sa_get_key(msg, 5));

    /* local key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref =
        VAL_UINT(sil_sa_get_key(msg, 6));

    if (LOGDEBUG) {
        log_debug("\nEnter port_map_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_port_map_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id,
        k_dot1q_vids,
        k_dot1q_address_3,
        k_dot1q_port_ref);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* port_map_edit */


/**
 * @brief Get database object callback for leaf status (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/filtering-database/filtering-entry/status\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t status_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter status_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_database_id,
        (uint32)6);
    if (keyval) {
        k_dot1q_database_id = VAL_UINT(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_vids,
        (uint32)6);
    if (keyval) {
        k_dot1q_vids = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_3 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_address,
        (uint32)6);
    if (keyval) {
        k_dot1q_address_3 = VAL_STRING(keyval);
    }

    return u_dot1q_status_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id,
        k_dot1q_vids,
        k_dot1q_address_3);

} /* status_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/filtering-database/filtering-entry
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t filtering_entry_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* local key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* local key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* local key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_3 =
        VAL_STRING(sil_sa_get_key(msg, 5));

    if (LOGDEBUG) {
        log_debug("\nEnter filtering_entry_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_filtering_entry_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id,
        k_dot1q_vids,
        k_dot1q_address_3);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* filtering_entry_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-filtering-entries/static-filtering-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t static_filtering_entries_3_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id_1 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_1 =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref_1 =
        VAL_UINT(sil_sa_get_key(msg, 5));

    if (LOGDEBUG) {
        log_debug("\nEnter static_filtering_entries_3_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_static_filtering_entries_3_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id_1,
        k_dot1q_vids_1,
        k_dot1q_port_ref_1);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* static_filtering_entries_3_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t static_vlan_registration_entries_4_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id_1 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_1 =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref_1 =
        VAL_UINT(sil_sa_get_key(msg, 5));

    if (LOGDEBUG) {
        log_debug("\nEnter static_vlan_registration_entries_4_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_static_vlan_registration_entries_4_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id_1,
        k_dot1q_vids_1,
        k_dot1q_port_ref_1);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* static_vlan_registration_entries_4_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t mac_address_registration_entries_4_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id_1 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_1 =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref_1 =
        VAL_UINT(sil_sa_get_key(msg, 5));

    if (LOGDEBUG) {
        log_debug("\nEnter mac_address_registration_entries_4_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_mac_address_registration_entries_4_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id_1,
        k_dot1q_vids_1,
        k_dot1q_port_ref_1);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* mac_address_registration_entries_4_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t dynamic_vlan_registration_entries_4_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id_1 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_1 =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref_1 =
        VAL_UINT(sil_sa_get_key(msg, 5));

    if (LOGDEBUG) {
        log_debug("\nEnter dynamic_vlan_registration_entries_4_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_dynamic_vlan_registration_entries_4_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id_1,
        k_dot1q_vids_1,
        k_dot1q_port_ref_1);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* dynamic_vlan_registration_entries_4_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t dynamic_reservation_entries_3_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id_1 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_1 =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref_1 =
        VAL_UINT(sil_sa_get_key(msg, 5));

    if (LOGDEBUG) {
        log_debug("\nEnter dynamic_reservation_entries_3_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_dynamic_reservation_entries_3_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id_1,
        k_dot1q_vids_1,
        k_dot1q_port_ref_1);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* dynamic_reservation_entries_3_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t dynamic_filtering_entries_3_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id_1 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_1 =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref_1 =
        VAL_UINT(sil_sa_get_key(msg, 5));

    if (LOGDEBUG) {
        log_debug("\nEnter dynamic_filtering_entries_3_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_dynamic_filtering_entries_3_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id_1,
        k_dot1q_vids_1,
        k_dot1q_port_ref_1);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* dynamic_filtering_entries_3_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/filtering-database/vlan-registration-entry/port-map
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t port_map_1_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id_1 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_1 =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* local key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref_1 =
        VAL_UINT(sil_sa_get_key(msg, 5));

    if (LOGDEBUG) {
        log_debug("\nEnter port_map_1_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_port_map_1_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id_1,
        k_dot1q_vids_1,
        k_dot1q_port_ref_1);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* port_map_1_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/filtering-database/vlan-registration-entry
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t vlan_registration_entry_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* local key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id_1 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* local key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_1 =
        VAL_STRING(sil_sa_get_key(msg, 4));

    if (LOGDEBUG) {
        log_debug("\nEnter vlan_registration_entry_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_vlan_registration_entry_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id_1,
        k_dot1q_vids_1);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* vlan_registration_entry_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/filtering-database
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t filtering_database_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter filtering_database_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_filtering_database_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* filtering_database_edit */


/**
 * @brief Get database object callback for leaf size (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/permanent-database/size\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t size_1_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter size_1_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    return u_dot1q_size_1_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1);

} /* size_1_get */


/**
 * @brief Get database object callback for leaf static-entries (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/permanent-database/static-entries\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t static_entries_1_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter static_entries_1_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    return u_dot1q_static_entries_1_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1);

} /* static_entries_1_get */


/**
 * @brief Get database object callback for leaf static-vlan-registration-entries (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/permanent-database/static-vlan-registration-entries\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t static_vlan_registration_entries_5_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter static_vlan_registration_entries_5_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    return u_dot1q_static_vlan_registration_entries_5_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1);

} /* static_vlan_registration_entries_5_get */


/**
 * @brief Get database object callback for leaf status (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/permanent-database/filtering-entry/status\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t status_1_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter status_1_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id_2 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_database_id,
        (uint32)6);
    if (keyval) {
        k_dot1q_database_id_2 = VAL_UINT(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_2 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_vids,
        (uint32)6);
    if (keyval) {
        k_dot1q_vids_2 = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_4 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_address,
        (uint32)6);
    if (keyval) {
        k_dot1q_address_4 = VAL_STRING(keyval);
    }

    return u_dot1q_status_1_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id_2,
        k_dot1q_vids_2,
        k_dot1q_address_4);

} /* status_1_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-filtering-entries/static-filtering-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t static_filtering_entries_5_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id_2 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_2 =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_4 =
        VAL_STRING(sil_sa_get_key(msg, 5));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref_2 =
        VAL_UINT(sil_sa_get_key(msg, 6));

    if (LOGDEBUG) {
        log_debug("\nEnter static_filtering_entries_5_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_static_filtering_entries_5_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id_2,
        k_dot1q_vids_2,
        k_dot1q_address_4,
        k_dot1q_port_ref_2);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* static_filtering_entries_5_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/static-vlan-registration-entries/static-vlan-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t static_vlan_registration_entries_7_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id_2 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_2 =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_4 =
        VAL_STRING(sil_sa_get_key(msg, 5));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref_2 =
        VAL_UINT(sil_sa_get_key(msg, 6));

    if (LOGDEBUG) {
        log_debug("\nEnter static_vlan_registration_entries_7_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_static_vlan_registration_entries_7_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id_2,
        k_dot1q_vids_2,
        k_dot1q_address_4,
        k_dot1q_port_ref_2);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* static_vlan_registration_entries_7_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/mac-address-registration-entries/mac-address-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t mac_address_registration_entries_6_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id_2 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_2 =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_4 =
        VAL_STRING(sil_sa_get_key(msg, 5));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref_2 =
        VAL_UINT(sil_sa_get_key(msg, 6));

    if (LOGDEBUG) {
        log_debug("\nEnter mac_address_registration_entries_6_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_mac_address_registration_entries_6_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id_2,
        k_dot1q_vids_2,
        k_dot1q_address_4,
        k_dot1q_port_ref_2);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* mac_address_registration_entries_6_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-vlan-registration-entries/dynamic-vlan-registration-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t dynamic_vlan_registration_entries_6_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id_2 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_2 =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_4 =
        VAL_STRING(sil_sa_get_key(msg, 5));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref_2 =
        VAL_UINT(sil_sa_get_key(msg, 6));

    if (LOGDEBUG) {
        log_debug("\nEnter dynamic_vlan_registration_entries_6_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_dynamic_vlan_registration_entries_6_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id_2,
        k_dot1q_vids_2,
        k_dot1q_address_4,
        k_dot1q_port_ref_2);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* dynamic_vlan_registration_entries_6_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-reservation-entries/dynamic-reservation-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t dynamic_reservation_entries_5_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id_2 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_2 =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_4 =
        VAL_STRING(sil_sa_get_key(msg, 5));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref_2 =
        VAL_UINT(sil_sa_get_key(msg, 6));

    if (LOGDEBUG) {
        log_debug("\nEnter dynamic_reservation_entries_5_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_dynamic_reservation_entries_5_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id_2,
        k_dot1q_vids_2,
        k_dot1q_address_4,
        k_dot1q_port_ref_2);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* dynamic_reservation_entries_5_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/permanent-database/filtering-entry/port-map/map-type/dynamic-filtering-entries/dynamic-filtering-entries
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t dynamic_filtering_entries_5_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id_2 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_2 =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_4 =
        VAL_STRING(sil_sa_get_key(msg, 5));

    /* ancestor key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref_2 =
        VAL_UINT(sil_sa_get_key(msg, 6));

    if (LOGDEBUG) {
        log_debug("\nEnter dynamic_filtering_entries_5_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_dynamic_filtering_entries_5_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id_2,
        k_dot1q_vids_2,
        k_dot1q_address_4,
        k_dot1q_port_ref_2);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* dynamic_filtering_entries_5_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/permanent-database/filtering-entry/port-map
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t port_map_2_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id_2 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_2 =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* ancestor key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_4 =
        VAL_STRING(sil_sa_get_key(msg, 5));

    /* local key ieee802-dot1q-bridge:port-ref */
    uint32 k_dot1q_port_ref_2 =
        VAL_UINT(sil_sa_get_key(msg, 6));

    if (LOGDEBUG) {
        log_debug("\nEnter port_map_2_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_port_map_2_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id_2,
        k_dot1q_vids_2,
        k_dot1q_address_4,
        k_dot1q_port_ref_2);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* port_map_2_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/permanent-database/filtering-entry
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t filtering_entry_1_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* local key ieee802-dot1q-bridge:database-id */
    uint32 k_dot1q_database_id_2 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    /* local key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_2 =
        VAL_STRING(sil_sa_get_key(msg, 4));

    /* local key ieee802-dot1q-bridge:address */
    const xmlChar *k_dot1q_address_4 =
        VAL_STRING(sil_sa_get_key(msg, 5));

    if (LOGDEBUG) {
        log_debug("\nEnter filtering_entry_1_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_filtering_entry_1_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_database_id_2,
        k_dot1q_vids_2,
        k_dot1q_address_4);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* filtering_entry_1_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/permanent-database
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t permanent_database_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter permanent_database_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_permanent_database_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* permanent_database_edit */


/**
 * @brief Get database object callback for leaf version (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/bridge-vlan/version\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t version_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter version_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    return u_dot1q_version_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1);

} /* version_get */


/**
 * @brief Get database object callback for leaf max-vids (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/bridge-vlan/max-vids\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t max_vids_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter max_vids_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    return u_dot1q_max_vids_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1);

} /* max_vids_get */


/**
 * @brief Get database object callback for leaf override-default-pvid (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/bridge-vlan/override-default-pvid\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t override_default_pvid_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter override_default_pvid_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    return u_dot1q_override_default_pvid_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1);

} /* override_default_pvid_get */


#ifdef u_dot1q_F_port_and_protocol_based_vlan

/**
 * @brief Get database object callback for leaf protocol-template (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/bridge-vlan/protocol-template\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t protocol_template_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter protocol_template_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    return u_dot1q_protocol_template_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1);

} /* protocol_template_get */

#endif /* u_dot1q_F_port_and_protocol_based_vlan */


/**
 * @brief Get database object callback for leaf max-msti (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/bridge-vlan/max-msti\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t max_msti_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter max_msti_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    return u_dot1q_max_msti_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1);

} /* max_msti_get */


/**
 * @brief Get database object callback for leaf-list untagged-ports (getcb_fn2_t)\n
 * Path: leaf-list /bridges/bridge/component/bridge-vlan/vlan/untagged-ports\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t untagged_ports_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter untagged_ports_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:vid */
    uint32 k_dot1q_vid_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_vid,
        (uint32)6);
    if (keyval) {
        k_dot1q_vid_1 = VAL_UINT(keyval);
    }

    return u_dot1q_untagged_ports_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_vid_1);

} /* untagged_ports_get */


/**
 * @brief Get database object callback for leaf-list egress-ports (getcb_fn2_t)\n
 * Path: leaf-list /bridges/bridge/component/bridge-vlan/vlan/egress-ports\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t egress_ports_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter egress_ports_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:vid */
    uint32 k_dot1q_vid_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_vid,
        (uint32)6);
    if (keyval) {
        k_dot1q_vid_1 = VAL_UINT(keyval);
    }

    return u_dot1q_egress_ports_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_vid_1);

} /* egress_ports_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/bridge-vlan/vlan
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t vlan_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* local key ieee802-dot1q-bridge:vid */
    uint32 k_dot1q_vid_1 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    if (LOGDEBUG) {
        log_debug("\nEnter vlan_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_vlan_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_vid_1);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* vlan_edit */


#ifdef u_dot1q_F_port_and_protocol_based_vlan

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/bridge-vlan/protocol-group-database/frame-format/llc-other/dsap-ssap-pairs
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t dsap_ssap_pairs_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* ancestor key ieee802-dot1q-bridge:db-index */
    uint16 k_dot1q_db_index =
        VAL_UINT16(sil_sa_get_key(msg, 3));

    if (LOGDEBUG) {
        log_debug("\nEnter dsap_ssap_pairs_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_dsap_ssap_pairs_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_db_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* dsap_ssap_pairs_edit */

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/bridge-vlan/protocol-group-database
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t protocol_group_database_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* local key ieee802-dot1q-bridge:db-index */
    uint16 k_dot1q_db_index =
        VAL_UINT16(sil_sa_get_key(msg, 3));

    if (LOGDEBUG) {
        log_debug("\nEnter protocol_group_database_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_protocol_group_database_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_db_index);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* protocol_group_database_edit */
#endif /* u_dot1q_F_port_and_protocol_based_vlan */


/**
 * @brief Get database object callback for leaf fid (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/bridge-vlan/vid-to-fid-allocation/fid\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t fid_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter fid_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_3 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_vids,
        (uint32)6);
    if (keyval) {
        k_dot1q_vids_3 = VAL_STRING(keyval);
    }

    return u_dot1q_fid_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_vids_3);

} /* fid_get */


/**
 * @brief Get database object callback for leaf allocation-type (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/bridge-vlan/vid-to-fid-allocation/allocation-type\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t allocation_type_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter allocation_type_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_3 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_vids,
        (uint32)6);
    if (keyval) {
        k_dot1q_vids_3 = VAL_STRING(keyval);
    }

    return u_dot1q_allocation_type_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_vids_3);

} /* allocation_type_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/bridge-vlan/vid-to-fid-allocation
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t vid_to_fid_allocation_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* local key ieee802-dot1q-bridge:vids */
    const xmlChar *k_dot1q_vids_3 =
        VAL_STRING(sil_sa_get_key(msg, 3));

    if (LOGDEBUG) {
        log_debug("\nEnter vid_to_fid_allocation_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_vid_to_fid_allocation_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_vids_3);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* vid_to_fid_allocation_edit */


/**
 * @brief Get database object callback for leaf allocation-type (getcb_fn2_t)\n
 * Path: leaf /bridges/bridge/component/bridge-vlan/fid-to-vid-allocation/allocation-type\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t allocation_type_1_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter allocation_type_1_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:fid */
    uint32 k_dot1q_fid_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_fid,
        (uint32)6);
    if (keyval) {
        k_dot1q_fid_1 = VAL_UINT(keyval);
    }

    return u_dot1q_allocation_type_1_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_fid_1);

} /* allocation_type_1_get */


/**
 * @brief Get database object callback for leaf-list vid (getcb_fn2_t)\n
 * Path: leaf-list /bridges/bridge/component/bridge-vlan/fid-to-vid-allocation/vid\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param scb session control block making the request.
 * @param msg message in progress for this retrieval request.
 * @param get2cb GET2 control block for the callback.
 * @return return status of the callback.
 */
static status_t vid_2_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    if (LOGDEBUG) {
        log_debug("\nEnter vid_2_get");
    }

    (void)scb;
    (void)msg;

    val_value_t *keyval = NULL;

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)3);
    if (keyval) {
        k_dot1q_name = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_name,
        (uint32)4);
    if (keyval) {
        k_dot1q_name_1 = VAL_STRING(keyval);
    }

    /* ancestor key ieee802-dot1q-bridge:fid */
    uint32 k_dot1q_fid_1 = 0;
    keyval = getcb_find_key_lvl(get2cb,
        y_dot1q_M_dot1q,
        y_dot1q_N_fid,
        (uint32)6);
    if (keyval) {
        k_dot1q_fid_1 = VAL_UINT(keyval);
    }

    return u_dot1q_vid_2_get(
        get2cb,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_fid_1);

} /* vid_2_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/bridge-vlan/fid-to-vid-allocation
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t fid_to_vid_allocation_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* local key ieee802-dot1q-bridge:fid */
    uint32 k_dot1q_fid_1 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    if (LOGDEBUG) {
        log_debug("\nEnter fid_to_vid_allocation_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_fid_to_vid_allocation_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_fid_1);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* fid_to_vid_allocation_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/bridge-vlan/vid-to-fid
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t vid_to_fid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* local key ieee802-dot1q-bridge:vid */
    uint32 k_dot1q_vid_3 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    if (LOGDEBUG) {
        log_debug("\nEnter vid_to_fid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_vid_to_fid_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_vid_3);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* vid_to_fid_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/bridge-vlan
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t bridge_vlan_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter bridge_vlan_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_bridge_vlan_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* bridge_vlan_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/bridge-mst/fid-to-mstid
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t fid_to_mstid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* local key ieee802-dot1q-bridge:fid */
    uint32 k_dot1q_fid_3 =
        VAL_UINT(sil_sa_get_key(msg, 3));

    if (LOGDEBUG) {
        log_debug("\nEnter fid_to_mstid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_fid_to_mstid_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_fid_3);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* fid_to_mstid_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component/bridge-mst/fid-to-mstid-allocation
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t fid_to_mstid_allocation_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    /* local key ieee802-dot1q-bridge:fids */
    const xmlChar *k_dot1q_fids =
        VAL_STRING(sil_sa_get_key(msg, 3));

    if (LOGDEBUG) {
        log_debug("\nEnter fid_to_mstid_allocation_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_fid_to_mstid_allocation_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1,
        k_dot1q_fids);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* fid_to_mstid_allocation_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges/bridge/component/bridge-mst
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t bridge_mst_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter bridge_mst_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_bridge_mst_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* bridge_mst_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge/component
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t component_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* local key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name_1 =
        VAL_STRING(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter component_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_component_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name,
        k_dot1q_name_1);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* component_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /bridges/bridge
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t bridge_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* local key ieee802-dot1q-bridge:name */
    const xmlChar *k_dot1q_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter bridge_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_bridge_edit(scb, msg, cbtyp, editop, newval, curval,
        k_dot1q_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* bridge_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /bridges
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
static status_t bridges_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    if (LOGDEBUG) {
        log_debug("\nEnter bridges_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_dot1q_bridges_edit(scb, msg, cbtyp, editop, newval, curval);

    if (res == NO_ERR && cbtyp == AGT_CB_COMMIT) {
        res = agt_check_cache(&bridges_val, newval, curval, editop);
    }


    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* bridges_edit */


/**
 * @brief Phase 1: Initialize the ieee802-dot1q-bridge server instrumentation library.
 *
 * Called by server when module is loaded.
 *
 * @param modname requested module name to load
 * @param revision requested revision date of the module to load.
 * This may be NULL if the module has no revision statements.
 * @return return status. An error will cause the module load to fail.
 */
status_t y_ieee802_dot1q_bridge_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter y_ieee802_dot1q_bridge_init");
    }


    y_dot1q_init_static_vars();

    /* change if custom handling done */
    if (xml_strcmp(modname, y_dot1q_M_dot1q)) {
        return ERR_NCX_UNKNOWN_MODULE;
    }

    if (revision && xml_strcmp(revision, y_dot1q_R_dot1q)) {
        return ERR_NCX_WRONG_VERSION;
    }

    /* Feature: ieee802-dot1q-bridge:ingress-filtering */
    res = ncx_set_feature_enable(
        y_dot1q_M_dot1q,
        (const xmlChar *)"ingress-filtering",
#ifdef u_dot1q_F_ingress_filtering
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee802-dot1q-bridge:extended-filtering-services */
    res = ncx_set_feature_enable(
        y_dot1q_M_dot1q,
        (const xmlChar *)"extended-filtering-services",
#ifdef u_dot1q_F_extended_filtering_services
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee802-dot1q-bridge:port-and-protocol-based-vlan */
    res = ncx_set_feature_enable(
        y_dot1q_M_dot1q,
        (const xmlChar *)"port-and-protocol-based-vlan",
#ifdef u_dot1q_F_port_and_protocol_based_vlan
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee802-dot1q-bridge:flow-filtering */
    res = ncx_set_feature_enable(
        y_dot1q_M_dot1q,
        (const xmlChar *)"flow-filtering",
#ifdef u_dot1q_F_flow_filtering
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee802-dot1q-bridge:simple-bridge-port */
    res = ncx_set_feature_enable(
        y_dot1q_M_dot1q,
        (const xmlChar *)"simple-bridge-port",
#ifdef u_dot1q_F_simple_bridge_port
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }

    /* Feature: ieee802-dot1q-bridge:flexible-bridge-port */
    res = ncx_set_feature_enable(
        y_dot1q_M_dot1q,
        (const xmlChar *)"flexible-bridge-port",
#ifdef u_dot1q_F_flexible_bridge_port
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }


    res = ncxmod_load_module(
        y_dot1q_M_dot1q,
        y_dot1q_R_dot1q,
        agt_get_savedevQ(),
        &ieee802_dot1q_bridge_mod);
    if (res != NO_ERR) {
        return res;
    }

    bridges_obj = ncx_find_object(
        ieee802_dot1q_bridge_mod,
        y_dot1q_N_bridges);
    if (bridges_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/if:interfaces/if:interface/dot1q:bridge-port",
        y_dot1q_R_dot1q,
        bridge_port_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/if:interfaces/if:interface/dot1q:bridge-port/dot1q:priority-regeneration",
        y_dot1q_R_dot1q,
        priority_regeneration_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/if:interfaces/if:interface/dot1q:bridge-port/dot1q:traffic-class",
        y_dot1q_R_dot1q,
        traffic_class_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/if:interfaces/if:interface/dot1q:bridge-port/dot1q:transmission-selection-algorithm-table",
        y_dot1q_R_dot1q,
        transmission_selection_algorithm_table_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/if:interfaces/if:interface/dot1q:bridge-port/dot1q:transmission-selection-algorithm-table/dot1q:transmission-selection-algorithm-map",
        y_dot1q_R_dot1q,
        transmission_selection_algorithm_map_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/if:interfaces/if:interface/dot1q:bridge-port/dot1q:address",
        y_dot1q_R_dot1q,
        address_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges",
        y_dot1q_R_dot1q,
        bridges_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge",
        y_dot1q_R_dot1q,
        bridge_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:ports",
        y_dot1q_R_dot1q,
        ports_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:up-time",
        y_dot1q_R_dot1q,
        up_time_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:components",
        y_dot1q_R_dot1q,
        components_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component",
        y_dot1q_R_dot1q,
        component_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:ports",
        y_dot1q_R_dot1q,
        ports_1_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-port",
        y_dot1q_R_dot1q,
        bridge_port_1_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:capabilities",
        y_dot1q_R_dot1q,
        capabilities_1_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database",
        y_dot1q_R_dot1q,
        filtering_database_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:size",
        y_dot1q_R_dot1q,
        size_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:static-entries",
        y_dot1q_R_dot1q,
        static_entries_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:dynamic-entries",
        y_dot1q_R_dot1q,
        dynamic_entries_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:static-vlan-registration-entries",
        y_dot1q_R_dot1q,
        static_vlan_registration_entries_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:dynamic-vlan-registration-entries",
        y_dot1q_R_dot1q,
        dynamic_vlan_registration_entries_get);
    if (res != NO_ERR) {
        return res;
    }


#ifdef u_dot1q_F_extended_filtering_services
    if (ncx_feature_enabled_str(
        y_dot1q_M_dot1q,
        y_dot1q_R_dot1q,
        (const xmlChar *)"extended-filtering-services")) {
        res = agt_cb_register_get_callback(
            y_dot1q_M_dot1q,
            (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:mac-address-registration-entries",
            y_dot1q_R_dot1q,
            mac_address_registration_entries_get);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_dot1q_F_extended_filtering_services */
#endif /* u_dot1q_F_extended_filtering_services */

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry",
        y_dot1q_R_dot1q,
        filtering_entry_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map",
        y_dot1q_R_dot1q,
        port_map_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:static-filtering-entries/dot1q:static-filtering-entries",
        y_dot1q_R_dot1q,
        static_filtering_entries_1_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:static-vlan-registration-entries/dot1q:static-vlan-registration-entries",
        y_dot1q_R_dot1q,
        static_vlan_registration_entries_2_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:mac-address-registration-entries/dot1q:mac-address-registration-entries",
        y_dot1q_R_dot1q,
        mac_address_registration_entries_2_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-vlan-registration-entries/dot1q:dynamic-vlan-registration-entries",
        y_dot1q_R_dot1q,
        dynamic_vlan_registration_entries_2_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-reservation-entries/dot1q:dynamic-reservation-entries",
        y_dot1q_R_dot1q,
        dynamic_reservation_entries_1_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-filtering-entries/dot1q:dynamic-filtering-entries",
        y_dot1q_R_dot1q,
        dynamic_filtering_entries_1_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:status",
        y_dot1q_R_dot1q,
        status_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry",
        y_dot1q_R_dot1q,
        vlan_registration_entry_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map",
        y_dot1q_R_dot1q,
        port_map_1_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:map-type/dot1q:static-filtering-entries/dot1q:static-filtering-entries",
        y_dot1q_R_dot1q,
        static_filtering_entries_3_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:map-type/dot1q:static-vlan-registration-entries/dot1q:static-vlan-registration-entries",
        y_dot1q_R_dot1q,
        static_vlan_registration_entries_4_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:map-type/dot1q:mac-address-registration-entries/dot1q:mac-address-registration-entries",
        y_dot1q_R_dot1q,
        mac_address_registration_entries_4_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-vlan-registration-entries/dot1q:dynamic-vlan-registration-entries",
        y_dot1q_R_dot1q,
        dynamic_vlan_registration_entries_4_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-reservation-entries/dot1q:dynamic-reservation-entries",
        y_dot1q_R_dot1q,
        dynamic_reservation_entries_3_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-filtering-entries/dot1q:dynamic-filtering-entries",
        y_dot1q_R_dot1q,
        dynamic_filtering_entries_3_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database",
        y_dot1q_R_dot1q,
        permanent_database_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:size",
        y_dot1q_R_dot1q,
        size_1_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:static-entries",
        y_dot1q_R_dot1q,
        static_entries_1_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:static-vlan-registration-entries",
        y_dot1q_R_dot1q,
        static_vlan_registration_entries_5_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry",
        y_dot1q_R_dot1q,
        filtering_entry_1_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:status",
        y_dot1q_R_dot1q,
        status_1_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map",
        y_dot1q_R_dot1q,
        port_map_2_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:static-filtering-entries/dot1q:static-filtering-entries",
        y_dot1q_R_dot1q,
        static_filtering_entries_5_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:static-vlan-registration-entries/dot1q:static-vlan-registration-entries",
        y_dot1q_R_dot1q,
        static_vlan_registration_entries_7_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:mac-address-registration-entries/dot1q:mac-address-registration-entries",
        y_dot1q_R_dot1q,
        mac_address_registration_entries_6_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-vlan-registration-entries/dot1q:dynamic-vlan-registration-entries",
        y_dot1q_R_dot1q,
        dynamic_vlan_registration_entries_6_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-reservation-entries/dot1q:dynamic-reservation-entries",
        y_dot1q_R_dot1q,
        dynamic_reservation_entries_5_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-filtering-entries/dot1q:dynamic-filtering-entries",
        y_dot1q_R_dot1q,
        dynamic_filtering_entries_5_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan",
        y_dot1q_R_dot1q,
        bridge_vlan_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:version",
        y_dot1q_R_dot1q,
        version_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:max-vids",
        y_dot1q_R_dot1q,
        max_vids_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:override-default-pvid",
        y_dot1q_R_dot1q,
        override_default_pvid_get);
    if (res != NO_ERR) {
        return res;
    }


#ifdef u_dot1q_F_port_and_protocol_based_vlan
    if (ncx_feature_enabled_str(
        y_dot1q_M_dot1q,
        y_dot1q_R_dot1q,
        (const xmlChar *)"port-and-protocol-based-vlan")) {
        res = agt_cb_register_get_callback(
            y_dot1q_M_dot1q,
            (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:protocol-template",
            y_dot1q_R_dot1q,
            protocol_template_get);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_dot1q_F_port_and_protocol_based_vlan */
#endif /* u_dot1q_F_port_and_protocol_based_vlan */

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:max-msti",
        y_dot1q_R_dot1q,
        max_msti_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:vlan",
        y_dot1q_R_dot1q,
        vlan_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:vlan/dot1q:untagged-ports",
        y_dot1q_R_dot1q,
        untagged_ports_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:vlan/dot1q:egress-ports",
        y_dot1q_R_dot1q,
        egress_ports_get);
    if (res != NO_ERR) {
        return res;
    }


#ifdef u_dot1q_F_port_and_protocol_based_vlan
    if (ncx_feature_enabled_str(
        y_dot1q_M_dot1q,
        y_dot1q_R_dot1q,
        (const xmlChar *)"port-and-protocol-based-vlan")) {
        res = agt_cb_register_edit2_callback(
            y_dot1q_M_dot1q,
            (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:protocol-group-database",
            y_dot1q_R_dot1q,
            protocol_group_database_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_edit2_callback(
            y_dot1q_M_dot1q,
            (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:protocol-group-database/dot1q:frame-format/dot1q:llc-other/dot1q:dsap-ssap-pairs",
            y_dot1q_R_dot1q,
            dsap_ssap_pairs_edit);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_dot1q_F_port_and_protocol_based_vlan */
#endif /* u_dot1q_F_port_and_protocol_based_vlan */

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:vid-to-fid-allocation",
        y_dot1q_R_dot1q,
        vid_to_fid_allocation_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:vid-to-fid-allocation/dot1q:fid",
        y_dot1q_R_dot1q,
        fid_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:vid-to-fid-allocation/dot1q:allocation-type",
        y_dot1q_R_dot1q,
        allocation_type_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:fid-to-vid-allocation",
        y_dot1q_R_dot1q,
        fid_to_vid_allocation_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:fid-to-vid-allocation/dot1q:allocation-type",
        y_dot1q_R_dot1q,
        allocation_type_1_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:fid-to-vid-allocation/dot1q:vid",
        y_dot1q_R_dot1q,
        vid_2_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:vid-to-fid",
        y_dot1q_R_dot1q,
        vid_to_fid_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-mst",
        y_dot1q_R_dot1q,
        bridge_mst_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-mst/dot1q:fid-to-mstid",
        y_dot1q_R_dot1q,
        fid_to_mstid_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_edit2_callback(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-mst/dot1q:fid-to-mstid-allocation",
        y_dot1q_R_dot1q,
        fid_to_mstid_allocation_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = u_ieee802_dot1q_bridge_init(modname, revision);
    return res;

} /* y_ieee802_dot1q_bridge_init */


/**
 * @brief Phase 2: Initialize the ieee802-dot1q-bridge server instrumentation library.
 *
 * SIL init phase 2: non-config data structures.
 * Called after running config is loaded.
 *
 * @return return status. An error will cause the
 * server initialization to fail.
 */
status_t y_ieee802_dot1q_bridge_init2 (void)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter y_ieee802_dot1q_bridge_init2");
    }


    res = u_ieee802_dot1q_bridge_init2();

    return res;

} /* y_ieee802_dot1q_bridge_init2 */


/**
 * @brief Cleanup the ieee802-dot1q-bridge server instrumentation library.
 *
 * Called by server when module is unloaded.
 *
 */
void y_ieee802_dot1q_bridge_cleanup (void)
{

    if (LOGDEBUG) {
        log_debug("\nEnter y_ieee802_dot1q_bridge_cleanup");
    }


    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/if:interfaces/if:interface/dot1q:bridge-port");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/if:interfaces/if:interface/dot1q:bridge-port/dot1q:priority-regeneration");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/if:interfaces/if:interface/dot1q:bridge-port/dot1q:traffic-class");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/if:interfaces/if:interface/dot1q:bridge-port/dot1q:transmission-selection-algorithm-table");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/if:interfaces/if:interface/dot1q:bridge-port/dot1q:transmission-selection-algorithm-table/dot1q:transmission-selection-algorithm-map");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:capabilities");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:static-filtering-entries/dot1q:static-filtering-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:static-vlan-registration-entries/dot1q:static-vlan-registration-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:mac-address-registration-entries/dot1q:mac-address-registration-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-vlan-registration-entries/dot1q:dynamic-vlan-registration-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-reservation-entries/dot1q:dynamic-reservation-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-filtering-entries/dot1q:dynamic-filtering-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:map-type/dot1q:static-filtering-entries/dot1q:static-filtering-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:map-type/dot1q:static-vlan-registration-entries/dot1q:static-vlan-registration-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:map-type/dot1q:mac-address-registration-entries/dot1q:mac-address-registration-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-vlan-registration-entries/dot1q:dynamic-vlan-registration-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-reservation-entries/dot1q:dynamic-reservation-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:filtering-database/dot1q:vlan-registration-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-filtering-entries/dot1q:dynamic-filtering-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:static-filtering-entries/dot1q:static-filtering-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:static-vlan-registration-entries/dot1q:static-vlan-registration-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:mac-address-registration-entries/dot1q:mac-address-registration-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-vlan-registration-entries/dot1q:dynamic-vlan-registration-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-reservation-entries/dot1q:dynamic-reservation-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:permanent-database/dot1q:filtering-entry/dot1q:port-map/dot1q:map-type/dot1q:dynamic-filtering-entries/dot1q:dynamic-filtering-entries");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:vlan");


#ifdef u_dot1q_F_port_and_protocol_based_vlan
    if (ncx_feature_enabled_str(
        y_dot1q_M_dot1q,
        y_dot1q_R_dot1q,
        (const xmlChar *)"port-and-protocol-based-vlan")) {
        agt_cb_unregister_callbacks(
            y_dot1q_M_dot1q,
            (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:protocol-group-database");

        agt_cb_unregister_callbacks(
            y_dot1q_M_dot1q,
            (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:protocol-group-database/dot1q:frame-format/dot1q:llc-other/dot1q:dsap-ssap-pairs");
    } /* u_dot1q_F_port_and_protocol_based_vlan */
#endif /* u_dot1q_F_port_and_protocol_based_vlan */

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:vid-to-fid-allocation");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:fid-to-vid-allocation");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-vlan/dot1q:vid-to-fid");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-mst");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-mst/dot1q:fid-to-mstid");

    agt_cb_unregister_callbacks(
        y_dot1q_M_dot1q,
        (const xmlChar *)"/dot1q:bridges/dot1q:bridge/dot1q:component/dot1q:bridge-mst/dot1q:fid-to-mstid-allocation");

    u_ieee802_dot1q_bridge_cleanup();

} /* y_ieee802_dot1q_bridge_cleanup */


 /** @} */

/* END SIL-SA y_ieee802-dot1q-bridge.c */
