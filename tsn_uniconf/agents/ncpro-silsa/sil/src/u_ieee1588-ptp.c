/*
 * Copyright (c) 2023 Texas Instruments Incorporated
 * Copyright (c) 2023 Excelfore Corporation (https://excelfore.com)
 *
 * All rights reserved not granted herein.
 * Limited License.
 *
 * Texas Instruments Incorporated grants a world-wide, royalty-free,
 * non-exclusive license under copyrights and patents it now or hereafter
 * owns or controls to make, have made, use, import, offer to sell and sell ("Utilize")
 * this software subject to the terms herein. With respect to the foregoing patent
 * license, such license is granted solely to the extent that any such patent is necessary
 * to Utilize the software alone. The patent license shall not apply to any combinations which
 * include this software, other than combinations with devices manufactured by or for TI ("TI Devices").
 * No hardware patent is licensed hereunder.
 *
 * Redistributions must preserve existing copyright notices and reproduce this license (including the
 * above copyright notice and the disclaimer and (if applicable) source code license limitations below)
 * in the documentation and/or other materials provided with the distribution
 *
 * Redistribution and use in binary form, without modification, are permitted provided that the following
 * conditions are met:
 *
 * * No reverse engineering, decompilation, or disassembly of this software is permitted with respect to any
 * software provided in binary form.
 * * any redistribution and use are licensed by TI for use only with TI Devices.
 * * Nothing shall obligate TI to provide you with source code for the software licensed and provided to you in object code.
 *
 * If software source code is provided to you, modification and redistribution of the source code are permitted
 * provided that the following conditions are met:
 *
 * * any redistribution and use of the source code, including any resulting derivative works, are licensed by
 * TI for use only with TI Devices.
 * * any redistribution and use of any object code compiled from the source code and any resulting derivative
 * works, are licensed by TI for use only with TI Devices.
 *
 * Neither the name of Texas Instruments Incorporated nor the names of its suppliers may be used to endorse or
 * promote products derived from this software without specific prior written permission.
 *
 * DISCLAIMER.
 *
 * THIS SOFTWARE IS PROVIDED BY TI AND TI"S LICENSORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TI AND TI"S LICENSORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * Copyright (c) 2008 - 2012, Andy Bierman, All Rights Reserved.
 * Copyright (c) 2012 - 2022, YumaWorks, Inc., All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

/**
 * @file u_ieee1588-ptp.c
 * @brief User SIL-SA module for module ieee1588-ptp
 *

*** Generated by yangdump-sdk 21.10-12

<pre>

    User SIL-SA module
    bundle x4ucsilsa
    module ieee1588-ptp
    revision 2022-08-30
    prefix ptp
    namespace urn:ieee:std:1588:yang:ieee1588-ptp
    organization IEEE 1588 Working Group
    Created: 2023-03-29T06:45:58Z

Online Developer Manual:
https://www.yumaworks.com/pub/21.10/dev/yumapro-dev-manual.html

    CLI parameters:
        defnames true
        deviation excelfore-interfaces
        deviation excelfore-gptp
        format uc
        indent 4
        module ietf-interfaces
        module ieee802-dot1q-bridge
        module ieee802-dot1q-tsn-config-uni
        module excelfore-interfaces
        module ieee1588-ptp
        module ieee802-dot1as-ptp
        module excelfore-gptp
        sil-bundle x4ucsilsa
        sil-edit2
        sil-get2
        sil-include tsn_uniconf/yangs/yang_db_access.h
        sil-include tsn_uniconf/yangs/yang_modules.h
        sil-sa
        unified true

  Short Name Mappings
    acceptable_master_ds = /ptp/instances/instance/acceptable-master-ds
    acceptable_master_port_ds = /ptp/instances/instance/ports/port/acceptable-master-port-ds
    acceptable_port_identity = /ptp/instances/instance/acceptable-master-ds/list/acceptable-port-identity
    address_field = /ptp/instances/instance/parent-ds/protocol-address/address-field
    address_field_1 = /ptp/instances/instance/grandmaster-cluster-ds/port-address/address-field
    address_field_2 = /ptp/instances/instance/ports/port/description-port-ds/protocol-address/address-field
    address_field_3 = /ptp/instances/instance/ports/port/unicast-discovery-port-ds/port-address/address-field
    address_length = /ptp/instances/instance/parent-ds/protocol-address/address-length
    address_length_1 = /ptp/instances/instance/grandmaster-cluster-ds/port-address/address-length
    address_length_2 = /ptp/instances/instance/ports/port/description-port-ds/protocol-address/address-length
    address_length_3 = /ptp/instances/instance/ports/port/unicast-discovery-port-ds/port-address/address-length
    alternate_master_port_ds = /ptp/instances/instance/ports/port/alternate-master-port-ds
    alternate_priority1 = /ptp/instances/instance/acceptable-master-ds/list/alternate-priority1
    alternate_timescale_ds = /ptp/instances/instance/alternate-timescale-ds
    announce_foreign_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/announce-foreign-rx
    announce_foreign_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/announce-foreign-rx
    announce_receipt_timeout = /ptp/instances/instance/ports/port/port-ds/announce-receipt-timeout
    announce_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/announce-rx
    announce_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/announce-rx
    announce_tx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/announce-tx
    announce_tx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/announce-tx
    asymmetry_correction_port_ds = /ptp/instances/instance/ports/port/asymmetry-correction-port-ds
    asymmetry_correction_port_ds_1 = /ptp/common-services/cmlds/ports/port/asymmetry-correction-port-ds
    average_master_slave_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/average-master-slave-delay
    average_mean_link_delay = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay/average-mean-link-delay
    average_mean_link_delay_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list-peer-delay/average-mean-link-delay
    average_mean_path_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/average-mean-path-delay
    average_offset_from_master = /ptp/instances/instance/performance-monitoring-ds/record-list/average-offset-from-master
    average_slave_master_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/average-slave-master-delay
    clock_accuracy = /ptp/instances/instance/default-ds/clock-quality/clock-accuracy
    clock_accuracy_1 = /ptp/instances/instance/parent-ds/grandmaster-clock-quality/clock-accuracy
    clock_class = /ptp/instances/instance/default-ds/clock-quality/clock-class
    clock_class_1 = /ptp/instances/instance/parent-ds/grandmaster-clock-quality/clock-class
    clock_identity = /ptp/instances/instance/default-ds/clock-identity
    clock_identity_1 = /ptp/instances/instance/parent-ds/parent-port-identity/clock-identity
    clock_identity_2 = /ptp/instances/instance/acceptable-master-ds/list/acceptable-port-identity/clock-identity
    clock_identity_3 = /ptp/instances/instance/ports/port/port-ds/port-identity/clock-identity
    clock_identity_4 = /ptp/transparent-clock-default-ds/clock-identity
    clock_identity_5 = /ptp/transparent-clock-ports/port/port-ds/port-identity/clock-identity
    clock_identity_6 = /ptp/common-services/cmlds/default-ds/clock-identity
    clock_identity_7 = /ptp/common-services/cmlds/ports/port/link-port-ds/port-identity/clock-identity
    clock_quality = /ptp/instances/instance/default-ds/clock-quality
    cmlds = /ptp/common-services/cmlds
    cmlds_link_port_port_number = /ptp/instances/instance/ports/port/common-services-port-ds/cmlds-link-port-port-number
    common_services = /ptp/common-services
    common_services_port_ds = /ptp/instances/instance/ports/port/common-services-port-ds
    communication_cap_port_ds = /ptp/instances/instance/ports/port/communication-cap-port-ds
    congruent_is_required = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/congruent-is-required
    constant_asymmetry = /ptp/instances/instance/ports/port/asymmetry-correction-port-ds/constant-asymmetry
    constant_asymmetry_1 = /ptp/common-services/cmlds/ports/port/asymmetry-correction-port-ds/constant-asymmetry
    current_ds = /ptp/instances/instance/current-ds
    current_offset = /ptp/instances/instance/alternate-timescale-ds/list/current-offset
    current_time = /ptp/instances/instance/default-ds/current-time
    current_utc_offset = /ptp/instances/instance/time-properties-ds/current-utc-offset
    current_utc_offset_valid = /ptp/instances/instance/time-properties-ds/current-utc-offset-valid
    default_ds = /ptp/instances/instance/default-ds
    default_ds_1 = /ptp/common-services/cmlds/default-ds
    delay_asymmetry = /ptp/instances/instance/ports/port/port-ds/delay-asymmetry
    delay_asymmetry_1 = /ptp/common-services/cmlds/ports/port/link-port-ds/delay-asymmetry
    delay_mechanism = /ptp/instances/instance/ports/port/port-ds/delay-mechanism
    delay_mechanism_1 = /ptp/transparent-clock-default-ds/delay-mechanism
    delay_req_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/delay-req-rx
    delay_req_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/delay-req-rx
    delay_req_tx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/delay-req-tx
    delay_req_tx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/delay-req-tx
    delay_resp = /ptp/instances/instance/ports/port/communication-cap-port-ds/delay-resp
    delay_resp_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/delay-resp-rx
    delay_resp_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/delay-resp-rx
    delay_resp_tx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/delay-resp-tx
    delay_resp_tx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/delay-resp-tx
    description = /ptp/instances/instance/fault-log-ds/fault-record-list/description
    description_ds = /ptp/instances/instance/description-ds
    description_port_ds = /ptp/instances/instance/ports/port/description-port-ds
    desired_state = /ptp/instances/instance/ports/port/external-port-config-port-ds/desired-state
    display_name = /ptp/instances/instance/alternate-timescale-ds/list/display-name
    domain_number = /ptp/instances/instance/default-ds/domain-number
    domain_number_1 = /ptp/common-services/cmlds/ports/port/link-port-ds/domain-number
    egress_latency = /ptp/instances/instance/ports/port/timestamp-correction-port-ds/egress-latency
    egress_latency_1 = /ptp/common-services/cmlds/ports/port/timestamp-correction-port-ds/egress-latency
    enable = /ptp/instances/instance/path-trace-ds/enable
    enable_1 = /ptp/instances/instance/alternate-timescale-ds/list/enable
    enable_2 = /ptp/instances/instance/holdover-upgrade-ds/enable
    enable_3 = /ptp/instances/instance/performance-monitoring-ds/enable
    enable_4 = /ptp/instances/instance/enhanced-metrics-ds/enable
    enable_5 = /ptp/instances/instance/ports/port/asymmetry-correction-port-ds/enable
    enable_6 = /ptp/instances/instance/ports/port/unicast-negotiation-port-ds/enable
    enable_7 = /ptp/instances/instance/ports/port/acceptable-master-port-ds/enable
    enable_8 = /ptp/instances/instance/ports/port/slave-monitoring-port-ds/enable
    enable_9 = /ptp/common-services/cmlds/ports/port/asymmetry-correction-port-ds/enable
    enabled = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/enabled
    enhanced_metrics_ds = /ptp/instances/instance/enhanced-metrics-ds
    events_per_rx_sync_computed_tlv = /ptp/instances/instance/ports/port/slave-monitoring-port-ds/events-per-rx-sync-computed-tlv
    events_per_rx_sync_timing_tlv = /ptp/instances/instance/ports/port/slave-monitoring-port-ds/events-per-rx-sync-timing-tlv
    events_per_tx_timestamps_tlv = /ptp/instances/instance/ports/port/slave-monitoring-port-ds/events-per-tx-timestamps-tlv
    external_port_config_enable = /ptp/instances/instance/default-ds/external-port-config-enable
    external_port_config_port_ds = /ptp/instances/instance/ports/port/external-port-config-port-ds
    fault_log_ds = /ptp/instances/instance/fault-log-ds
    fault_record_list = /ptp/instances/instance/fault-log-ds/fault-record-list
    faulty_flag = /ptp/transparent-clock-ports/port/port-ds/faulty-flag
    follow_up_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/follow-up-rx
    follow_up_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/follow-up-rx
    follow_up_tx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/follow-up-tx
    follow_up_tx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/follow-up-tx
    frequency_offset_tx = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx
    frequency_offset_tx_timestamp = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx-timestamp
    frequency_offset_tx_valid = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx-valid
    frequency_traceable = /ptp/instances/instance/time-properties-ds/frequency-traceable
    grandmaster_clock_quality = /ptp/instances/instance/parent-ds/grandmaster-clock-quality
    grandmaster_cluster_ds = /ptp/instances/instance/grandmaster-cluster-ds
    grandmaster_identity = /ptp/instances/instance/parent-ds/grandmaster-identity
    grandmaster_priority1 = /ptp/instances/instance/parent-ds/grandmaster-priority1
    grandmaster_priority2 = /ptp/instances/instance/parent-ds/grandmaster-priority2
    holdover_upgrade_ds = /ptp/instances/instance/holdover-upgrade-ds
    index = /ptp/instances/instance/grandmaster-cluster-ds/port-address/index
    index_1 = /ptp/instances/instance/acceptable-master-ds/list/index
    index_2 = /ptp/instances/instance/performance-monitoring-ds/record-list/index
    index_3 = /ptp/instances/instance/ports/port/unicast-discovery-port-ds/port-address/index
    index_4 = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay/index
    index_5 = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/index
    index_6 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list-peer-delay/index
    index_7 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/index
    ingress_latency = /ptp/instances/instance/ports/port/timestamp-correction-port-ds/ingress-latency
    ingress_latency_1 = /ptp/common-services/cmlds/ports/port/timestamp-correction-port-ds/ingress-latency
    input = /ptp/instances/instance/fault-log-ds/reset/input
    instance = /ptp/instances/instance
    instance_enable = /ptp/instances/instance/default-ds/instance-enable
    instance_index = /ptp/instances/instance/instance-index
    instance_type = /ptp/instances/instance/default-ds/instance-type
    instances = /ptp/instances
    is_congruent = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/is-congruent
    is_rx_coherent = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/is-rx-coherent
    is_tx_coherent = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/is-tx-coherent
    jump_seconds = /ptp/instances/instance/alternate-timescale-ds/list/jump-seconds
    key_field = /ptp/instances/instance/alternate-timescale-ds/list/key-field
    l1_sync_basic_port_ds = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds
    l1_sync_opt_params_port_ds = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds
    l1sync_receipt_timeout = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/l1sync-receipt-timeout
    l1sync_state = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/l1sync-state
    leap59 = /ptp/instances/instance/time-properties-ds/leap59
    leap61 = /ptp/instances/instance/time-properties-ds/leap61
    link_alive = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/link-alive
    link_port_ds = /ptp/common-services/cmlds/ports/port/link-port-ds
    list = /ptp/instances/instance/path-trace-ds/list
    list_1 = /ptp/instances/instance/alternate-timescale-ds/list
    list_2 = /ptp/instances/instance/acceptable-master-ds/list
    log_alt_multicast_sync_interval = /ptp/instances/instance/ports/port/alternate-master-port-ds/log-alt-multicast-sync-interval
    log_announce_interval = /ptp/instances/instance/ports/port/port-ds/log-announce-interval
    log_l1sync_interval = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/log-l1sync-interval
    log_min_delay_req_interval = /ptp/instances/instance/ports/port/port-ds/log-min-delay-req-interval
    log_min_pdelay_req_interval = /ptp/instances/instance/ports/port/port-ds/log-min-pdelay-req-interval
    log_min_pdelay_req_interval_1 = /ptp/transparent-clock-ports/port/port-ds/log-min-pdelay-req-interval
    log_min_pdelay_req_interval_2 = /ptp/common-services/cmlds/ports/port/link-port-ds/log-min-pdelay-req-interval
    log_query_interval = /ptp/instances/instance/grandmaster-cluster-ds/log-query-interval
    log_query_interval_1 = /ptp/instances/instance/ports/port/unicast-discovery-port-ds/log-query-interval
    log_sync_interval = /ptp/instances/instance/ports/port/port-ds/log-sync-interval
    manufacturer_identity = /ptp/instances/instance/description-ds/manufacturer-identity
    master_only = /ptp/instances/instance/ports/port/port-ds/master-only
    max_key = /ptp/instances/instance/alternate-timescale-ds/max-key
    max_mean_link_delay = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay/max-mean-link-delay
    max_mean_link_delay_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list-peer-delay/max-mean-link-delay
    max_steps_removed = /ptp/instances/instance/default-ds/max-steps-removed
    max_table_size = /ptp/instances/instance/grandmaster-cluster-ds/max-table-size
    max_table_size_1 = /ptp/instances/instance/acceptable-master-ds/max-table-size
    max_table_size_2 = /ptp/instances/instance/ports/port/unicast-discovery-port-ds/max-table-size
    maximum_master_slave_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/maximum-master-slave-delay
    maximum_mean_path_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/maximum-mean-path-delay
    maximum_offset_from_master = /ptp/instances/instance/performance-monitoring-ds/record-list/maximum-offset-from-master
    maximum_slave_master_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/maximum-slave-master-delay
    mean_delay = /ptp/instances/instance/current-ds/mean-delay
    mean_link_delay = /ptp/instances/instance/ports/port/port-ds/mean-link-delay
    mean_link_delay_1 = /ptp/common-services/cmlds/ports/port/link-port-ds/mean-link-delay
    mean_path_delay = /ptp/instances/instance/current-ds/mean-path-delay
    measurement_valid = /ptp/instances/instance/performance-monitoring-ds/record-list/measurement-valid
    min_mean_link_delay = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay/min-mean-link-delay
    min_mean_link_delay_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list-peer-delay/min-mean-link-delay
    minimum_master_slave_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/minimum-master-slave-delay
    minimum_mean_path_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/minimum-mean-path-delay
    minimum_offset_from_master = /ptp/instances/instance/performance-monitoring-ds/record-list/minimum-offset-from-master
    minimum_slave_master_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/minimum-slave-master-delay
    minor_version_number = /ptp/instances/instance/ports/port/port-ds/minor-version-number
    minor_version_number_1 = /ptp/common-services/cmlds/ports/port/link-port-ds/minor-version-number
    multicast_capable = /ptp/instances/instance/ports/port/communication-cap-port-ds/sync/multicast-capable
    multicast_capable_1 = /ptp/instances/instance/ports/port/communication-cap-port-ds/delay-resp/multicast-capable
    name = /ptp/instances/instance/fault-log-ds/fault-record-list/name
    nanoseconds_field = /ptp/instances/instance/default-ds/current-time/nanoseconds-field
    nanoseconds_field_1 = /ptp/instances/instance/fault-log-ds/fault-record-list/time/nanoseconds-field
    nanoseconds_field_2 = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx-timestamp/nanoseconds-field
    nanoseconds_field_3 = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx-timestamp/nanoseconds-field
    network_protocol = /ptp/instances/instance/parent-ds/protocol-address/network-protocol
    network_protocol_1 = /ptp/instances/instance/grandmaster-cluster-ds/port-address/network-protocol
    network_protocol_2 = /ptp/instances/instance/ports/port/description-port-ds/protocol-address/network-protocol
    network_protocol_3 = /ptp/instances/instance/ports/port/unicast-discovery-port-ds/port-address/network-protocol
    number_link_ports = /ptp/common-services/cmlds/default-ds/number-link-ports
    number_of_alt_masters = /ptp/instances/instance/ports/port/alternate-master-port-ds/number-of-alt-masters
    number_of_fault_records = /ptp/instances/instance/fault-log-ds/number-of-fault-records
    number_ports = /ptp/instances/instance/default-ds/number-ports
    number_ports_1 = /ptp/transparent-clock-default-ds/number-ports
    observed_parent_clock_phase_change_rate = /ptp/instances/instance/parent-ds/observed-parent-clock-phase-change-rate
    observed_parent_offset_scaled_log_variance = /ptp/instances/instance/parent-ds/observed-parent-offset-scaled-log-variance
    offset_from_master = /ptp/instances/instance/current-ds/offset-from-master
    offset_scaled_log_variance = /ptp/instances/instance/default-ds/clock-quality/offset-scaled-log-variance
    offset_scaled_log_variance_1 = /ptp/instances/instance/parent-ds/grandmaster-clock-quality/offset-scaled-log-variance
    opt_params_enabled = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/opt-params-enabled
    output = /ptp/instances/instance/fault-log-ds/reset/output
    parent_ds = /ptp/instances/instance/parent-ds
    parent_port_identity = /ptp/instances/instance/parent-ds/parent-port-identity
    parent_stats = /ptp/instances/instance/parent-ds/parent-stats
    path_trace_ds = /ptp/instances/instance/path-trace-ds
    pdelay_req_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/pdelay-req-rx
    pdelay_req_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/pdelay-req-rx
    pdelay_req_tx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/pdelay-req-tx
    pdelay_req_tx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/pdelay-req-tx
    pdelay_resp_follow_up_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/pdelay-resp-follow-up-rx
    pdelay_resp_follow_up_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/pdelay-resp-follow-up-rx
    pdelay_resp_follow_up_tx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/pdelay-resp-follow-up-tx
    pdelay_resp_follow_up_tx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/pdelay-resp-follow-up-tx
    pdelay_resp_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/pdelay-resp-rx
    pdelay_resp_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/pdelay-resp-rx
    pdelay_resp_tx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/pdelay-resp-tx
    pdelay_resp_tx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/pdelay-resp-tx
    peer_congruent_is_required = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-congruent-is-required
    peer_is_congruent = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-is-congruent
    peer_is_rx_coherent = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-is-rx-coherent
    peer_is_tx_coherent = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-is-tx-coherent
    peer_mean_path_delay = /ptp/instances/instance/ports/port/port-ds/peer-mean-path-delay
    peer_mean_path_delay_1 = /ptp/transparent-clock-ports/port/port-ds/peer-mean-path-delay
    peer_rx_coherent_is_required = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-rx-coherent-is-required
    peer_tx_coherent_is_required = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-tx-coherent-is-required
    performance_monitoring_ds = /ptp/instances/instance/performance-monitoring-ds
    performance_monitoring_port_ds = /ptp/instances/instance/ports/port/performance-monitoring-port-ds
    performance_monitoring_port_ds_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds
    period_complete = /ptp/instances/instance/performance-monitoring-ds/record-list/period-complete
    phase_offset_tx = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx
    phase_offset_tx_timestamp = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx-timestamp
    phase_offset_tx_valid = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx-valid
    pm_time = /ptp/instances/instance/performance-monitoring-ds/record-list/pm-time
    pm_time_1 = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay/pm-time
    pm_time_2 = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/pm-time
    pm_time_3 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list-peer-delay/pm-time
    pm_time_4 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/pm-time
    port = /ptp/instances/instance/ports/port
    port_1 = /ptp/transparent-clock-ports/port
    port_2 = /ptp/common-services/cmlds/ports/port
    port_address = /ptp/instances/instance/grandmaster-cluster-ds/port-address
    port_address_1 = /ptp/instances/instance/ports/port/unicast-discovery-port-ds/port-address
    port_ds = /ptp/instances/instance/ports/port/port-ds
    port_ds_1 = /ptp/transparent-clock-ports/port/port-ds
    port_enable = /ptp/instances/instance/ports/port/port-ds/port-enable
    port_identity = /ptp/instances/instance/ports/port/port-ds/port-identity
    port_identity_1 = /ptp/transparent-clock-ports/port/port-ds/port-identity
    port_identity_2 = /ptp/common-services/cmlds/ports/port/link-port-ds/port-identity
    port_index = /ptp/instances/instance/ports/port/port-index
    port_index_1 = /ptp/transparent-clock-ports/port/port-index
    port_index_2 = /ptp/common-services/cmlds/ports/port/port-index
    port_number = /ptp/instances/instance/parent-ds/parent-port-identity/port-number
    port_number_1 = /ptp/instances/instance/acceptable-master-ds/list/acceptable-port-identity/port-number
    port_number_2 = /ptp/instances/instance/ports/port/port-ds/port-identity/port-number
    port_number_3 = /ptp/transparent-clock-ports/port/port-ds/port-identity/port-number
    port_number_4 = /ptp/common-services/cmlds/ports/port/link-port-ds/port-identity/port-number
    port_state = /ptp/instances/instance/ports/port/port-ds/port-state
    ports = /ptp/instances/instance/ports
    ports_1 = /ptp/common-services/cmlds/ports
    primary_domain = /ptp/transparent-clock-default-ds/primary-domain
    priority1 = /ptp/instances/instance/default-ds/priority1
    priority2 = /ptp/instances/instance/default-ds/priority2
    product_description = /ptp/instances/instance/description-ds/product-description
    product_revision = /ptp/instances/instance/description-ds/product-revision
    profile_identifier = /ptp/instances/instance/ports/port/description-port-ds/profile-identifier
    protocol_address = /ptp/instances/instance/parent-ds/protocol-address
    protocol_address_1 = /ptp/instances/instance/ports/port/description-port-ds/protocol-address
    ptp = /ptp
    ptp_timescale = /ptp/instances/instance/time-properties-ds/ptp-timescale
    record_list = /ptp/instances/instance/performance-monitoring-ds/record-list
    record_list_1 = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list
    record_list_2 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list
    record_list_peer_delay = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay
    record_list_peer_delay_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list-peer-delay
    reset = /ptp/instances/instance/fault-log-ds/reset
    rx_coherent_is_required = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/rx-coherent-is-required
    rx_sync_computed_tlv_message_m = /ptp/instances/instance/ports/port/slave-monitoring-port-ds/rx-sync-computed-tlv-message-m
    rx_sync_timing_tlv_message_m = /ptp/instances/instance/ports/port/slave-monitoring-port-ds/rx-sync-timing-tlv-message-m
    scaled_delay_coefficient = /ptp/instances/instance/ports/port/asymmetry-correction-port-ds/scaled-delay-coefficient
    scaled_delay_coefficient_1 = /ptp/common-services/cmlds/ports/port/asymmetry-correction-port-ds/scaled-delay-coefficient
    scaled_neighbor_rate_ratio = /ptp/common-services/cmlds/ports/port/link-port-ds/scaled-neighbor-rate-ratio
    sdo_id = /ptp/instances/instance/default-ds/sdo-id
    seconds_field = /ptp/instances/instance/default-ds/current-time/seconds-field
    seconds_field_1 = /ptp/instances/instance/fault-log-ds/fault-record-list/time/seconds-field
    seconds_field_2 = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx-timestamp/seconds-field
    seconds_field_3 = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx-timestamp/seconds-field
    service_measurement_valid = /ptp/common-services/cmlds/ports/port/link-port-ds/service-measurement-valid
    severity = /ptp/instances/instance/fault-log-ds/fault-record-list/severity
    slave_monitoring_port_ds = /ptp/instances/instance/ports/port/slave-monitoring-port-ds
    slave_only = /ptp/instances/instance/default-ds/slave-only
    stddev_master_slave_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/stddev-master-slave-delay
    stddev_mean_link_delay = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay/stddev-mean-link-delay
    stddev_mean_link_delay_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list-peer-delay/stddev-mean-link-delay
    stddev_mean_path_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/stddev-mean-path-delay
    stddev_offset_from_master = /ptp/instances/instance/performance-monitoring-ds/record-list/stddev-offset-from-master
    stddev_slave_master_delay = /ptp/instances/instance/performance-monitoring-ds/record-list/stddev-slave-master-delay
    steps_removed = /ptp/instances/instance/current-ds/steps-removed
    sync = /ptp/instances/instance/ports/port/communication-cap-port-ds/sync
    sync_rx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/sync-rx
    sync_rx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/sync-rx
    sync_tx = /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list/sync-tx
    sync_tx_1 = /ptp/common-services/cmlds/ports/port/performance-monitoring-port-ds/record-list/sync-tx
    synchronization_uncertain = /ptp/instances/instance/current-ds/synchronization-uncertain
    synchronization_uncertain_1 = /ptp/instances/instance/parent-ds/synchronization-uncertain
    time = /ptp/instances/instance/fault-log-ds/fault-record-list/time
    time_of_next_jump = /ptp/instances/instance/alternate-timescale-ds/list/time-of-next-jump
    time_properties_ds = /ptp/instances/instance/time-properties-ds
    time_source = /ptp/instances/instance/time-properties-ds/time-source
    time_traceable = /ptp/instances/instance/time-properties-ds/time-traceable
    timestamp_correction_port_ds = /ptp/instances/instance/ports/port/timestamp-correction-port-ds
    timestamp_correction_port_ds_1 = /ptp/common-services/cmlds/ports/port/timestamp-correction-port-ds
    timestamps_corrected_tx = /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/timestamps-corrected-tx
    transparent_clock_default_ds = /ptp/transparent-clock-default-ds
    transparent_clock_ports = /ptp/transparent-clock-ports
    two_step_flag = /ptp/instances/instance/default-ds/two-step-flag
    tx_alt_multicast_sync = /ptp/instances/instance/ports/port/alternate-master-port-ds/tx-alt-multicast-sync
    tx_coherent_is_required = /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/tx-coherent-is-required
    tx_event_type = /ptp/instances/instance/ports/port/slave-monitoring-port-ds/tx-event-type
    tx_timestamps_tlv_message_m = /ptp/instances/instance/ports/port/slave-monitoring-port-ds/tx-timestamps-tlv-message-m
    underlying_interface = /ptp/instances/instance/ports/port/underlying-interface
    underlying_interface_1 = /ptp/transparent-clock-ports/port/underlying-interface
    underlying_interface_2 = /ptp/common-services/cmlds/ports/port/underlying-interface
    unicast_capable = /ptp/instances/instance/ports/port/communication-cap-port-ds/sync/unicast-capable
    unicast_capable_1 = /ptp/instances/instance/ports/port/communication-cap-port-ds/delay-resp/unicast-capable
    unicast_discovery_port_ds = /ptp/instances/instance/ports/port/unicast-discovery-port-ds
    unicast_negotiation_capable = /ptp/instances/instance/ports/port/communication-cap-port-ds/sync/unicast-negotiation-capable
    unicast_negotiation_capable_1 = /ptp/instances/instance/ports/port/communication-cap-port-ds/delay-resp/unicast-negotiation-capable
    unicast_negotiation_port_ds = /ptp/instances/instance/ports/port/unicast-negotiation-port-ds
    unicast_negotiation_required = /ptp/instances/instance/ports/port/communication-cap-port-ds/sync/unicast-negotiation-required
    unicast_negotiation_required_1 = /ptp/instances/instance/ports/port/communication-cap-port-ds/delay-resp/unicast-negotiation-required
    user_description = /ptp/instances/instance/description-ds/user-description
    value = /ptp/instances/instance/fault-log-ds/fault-record-list/value
    version_number = /ptp/instances/instance/ports/port/port-ds/version-number
    version_number_1 = /ptp/common-services/cmlds/ports/port/link-port-ds/version-number
</pre>

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_action.h"
#include "agt_cb.h"
#include "agt_cfg.h"
#include "agt_rpc.h"
#include "agt_sil_lib.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "agt_val.h"
#include "cfg.h"
#include "dlq.h"
#include "getcb.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "obj.h"
#include "rpc.h"
#include "sil_sa.h"
#include "status.h"
#include "val.h"
#include "val_child.h"
#include "val_util.h"
#include "xml_val.h"

#include "tsn_uniconf/yangs/yang_db_access.h"
#include "tsn_uniconf/yangs/yang_modules.h"


/* SIL bundle: x4ucsilsa */
#include "y_ietf-interfaces.h"
#include "u_ietf-interfaces.h"
#include "y_ieee802-dot1q-bridge.h"
#include "u_ieee802-dot1q-bridge.h"
#include "y_ieee802-dot1q-tsn-config-uni.h"
#include "u_ieee802-dot1q-tsn-config-uni.h"
#include "y_excelfore-interfaces.h"
#include "u_excelfore-interfaces.h"
#include "y_ieee1588-ptp.h"
#include "u_ieee1588-ptp.h"
#include "y_ieee802-dot1as-ptp.h"
#include "u_ieee802-dot1as-ptp.h"
#include "y_excelfore-gptp.h"
#include "u_excelfore-gptp.h"


/**
 * @addtogroup yang-library YANG Library
 *
 * Collection of modules supported by the server.
 * Generated by yangdump-sdk.
 */



/**
 * @addtogroup silsa-x4ucsilsa-ieee1588-ptp Module ieee1588-ptp in Bundle x4ucsilsa
 * @ingroup silsa-x4ucsilsa
 *
 * @{
 *
 * YANG instrumentation library.
 * Generated by yangdump-sdk.
 */



/* put your static variables here */


/**
 * @brief Get database object callback for leaf clock-identity (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/default-ds/clock-identity\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_clock_identity_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_clock_identity_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_clock_identity = 0;

    /* add clock_identity to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_clock_identity,
        v_clock_identity,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_clock_identity_get */



/**
 * @brief Get database object callback for leaf number-ports (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/default-ds/number-ports\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_number_ports_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_number_ports_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint16 v_number_ports = 0;

    /* add number_ports to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_number_ports,
        v_number_ports,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_number_ports_get */



/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/default-ds/clock-quality
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
status_t u_ptp_clock_quality_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_clock_quality_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_clock_class)) {
                /* leaf clock-class (identityref) */

            } else if (!xml_strcmp(name, y_ptp_N_clock_accuracy)) {
                /* leaf clock-accuracy (identityref) */

            } else if (!xml_strcmp(name, y_ptp_N_offset_scaled_log_variance)) {
                /* leaf offset-scaled-log-variance (uint16) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_clock_quality_edit */


/**
 * @brief Get database object callback for leaf domain-number (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/default-ds/domain-number\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_domain_number_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_domain_number_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint8 v_domain_number = 0;

    /* add domain_number to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_domain_number,
        v_domain_number,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_domain_number_get */



/**
 * @brief Get database object callback for leaf sdo-id (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/default-ds/sdo-id\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_sdo_id_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_sdo_id_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint16 v_sdo_id = 0;

    /* add sdo_id to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_sdo_id,
        v_sdo_id,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_sdo_id_get */



/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/default-ds/current-time
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
status_t u_ptp_current_time_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_current_time_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_seconds_field)) {
                /* leaf seconds-field (uint64) */

            } else if (!xml_strcmp(name, y_ptp_N_nanoseconds_field)) {
                /* leaf nanoseconds-field (uint32) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_current_time_edit */


/**
 * @brief Get database object callback for leaf max-steps-removed (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/default-ds/max-steps-removed\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_max_steps_removed_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_max_steps_removed_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint8 v_max_steps_removed = 0;

    /* add max_steps_removed to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_max_steps_removed,
        v_max_steps_removed,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_max_steps_removed_get */



/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/default-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
status_t u_ptp_default_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_default_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_priority1)) {
                /* leaf priority1 (uint8) */

            } else if (!xml_strcmp(name, y_ptp_N_priority2)) {
                /* leaf priority2 (uint8) */

            } else if (!xml_strcmp(name, y_ptp_N_slave_only)) {
                /* leaf slave-only (boolean) */

            } else if (!xml_strcmp(name, y_ptp_N_external_port_config_enable)) {
                /* leaf external-port-config-enable (boolean) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_default_ds_edit */


/**
 * @brief Get database object callback for container current-ds (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/current-ds\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_current_ds_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_current_ds_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed
     */
    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_ptp_N_steps_removed)) {
            /* leaf steps-removed (uint16) */

        } else if (!xml_strcmp(name, y_ptp_N_offset_from_master)) {
            /* leaf offset-from-master (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_mean_delay)) {
            /* leaf mean-delay (int64) */

        } else if (!xml_strcmp(name, y_dot1as_ptp_N_last_gm_phase_change)) {
            /* leaf last-gm-phase-change (string) */

        } else if (!xml_strcmp(name, y_dot1as_ptp_N_last_gm_freq_change)) {
            /* leaf last-gm-freq-change (string) */

        } else if (!xml_strcmp(name, y_dot1as_ptp_N_gm_timebase_indicator)) {
            /* leaf gm-timebase-indicator (uint16) */

        } else if (!xml_strcmp(name, y_dot1as_ptp_N_time_of_last_freq_change)) {
            /* leaf time-of-last-freq-change (uint32) */

        }
    }

    return res;

} /* u_ptp_current_ds_get */



/**
 * @brief Get database object callback for container parent-port-identity (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/parent-ds/parent-port-identity\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_parent_port_identity_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_parent_port_identity_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed
     */
    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_ptp_N_clock_identity)) {
            /* leaf clock-identity (string) */

        } else if (!xml_strcmp(name, y_ptp_N_port_number)) {
            /* leaf port-number (uint16) */

        }
    }

    return res;

} /* u_ptp_parent_port_identity_get */



/**
 * @brief Get database object callback for container grandmaster-clock-quality (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/parent-ds/grandmaster-clock-quality\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_grandmaster_clock_quality_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_grandmaster_clock_quality_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed
     */
    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_ptp_N_clock_class)) {
            /* leaf clock-class (identityref) */

        } else if (!xml_strcmp(name, y_ptp_N_clock_accuracy)) {
            /* leaf clock-accuracy (identityref) */

        } else if (!xml_strcmp(name, y_ptp_N_offset_scaled_log_variance)) {
            /* leaf offset-scaled-log-variance (uint16) */

        }
    }

    return res;

} /* u_ptp_grandmaster_clock_quality_get */



/**
 * @brief Get database object callback for container protocol-address (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/parent-ds/protocol-address\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_protocol_address_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_protocol_address_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed
     */
    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_ptp_N_network_protocol)) {
            /* leaf network-protocol (identityref) */

        } else if (!xml_strcmp(name, y_ptp_N_address_length)) {
            /* leaf address-length (uint16) */

        } else if (!xml_strcmp(name, y_ptp_N_address_field)) {
            /* leaf address-field (string) */

        }
    }

    return res;

} /* u_ptp_protocol_address_get */



/**
 * @brief Get database object callback for container parent-ds (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/parent-ds\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_parent_ds_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_parent_ds_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed
     */
    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_ptp_N_grandmaster_identity)) {
            /* leaf grandmaster-identity (string) */

        } else if (!xml_strcmp(name, y_ptp_N_grandmaster_priority1)) {
            /* leaf grandmaster-priority1 (uint8) */

        } else if (!xml_strcmp(name, y_ptp_N_grandmaster_priority2)) {
            /* leaf grandmaster-priority2 (uint8) */

        }
    }

    return res;

} /* u_ptp_parent_ds_get */



/**
 * @brief Get database object callback for container time-properties-ds (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/time-properties-ds\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_time_properties_ds_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_time_properties_ds_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed
     */
    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_ptp_N_current_utc_offset)) {
            /* leaf current-utc-offset (int16) */

        } else if (!xml_strcmp(name, y_ptp_N_current_utc_offset_valid)) {
            /* leaf current-utc-offset-valid (boolean) */

        } else if (!xml_strcmp(name, y_ptp_N_leap59)) {
            /* leaf leap59 (boolean) */

        } else if (!xml_strcmp(name, y_ptp_N_leap61)) {
            /* leaf leap61 (boolean) */

        } else if (!xml_strcmp(name, y_ptp_N_time_traceable)) {
            /* leaf time-traceable (boolean) */

        } else if (!xml_strcmp(name, y_ptp_N_frequency_traceable)) {
            /* leaf frequency-traceable (boolean) */

        } else if (!xml_strcmp(name, y_ptp_N_ptp_timescale)) {
            /* leaf ptp-timescale (boolean) */

        } else if (!xml_strcmp(name, y_ptp_N_time_source)) {
            /* leaf time-source (identityref) */

        }
    }

    return res;

} /* u_ptp_time_properties_ds_get */



#ifdef u_ptp_F_fault_log

/**
 * @brief Get database object callback for container time (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/fault-log-ds/fault-record-list/time\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_time_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_time_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed
     */
    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_ptp_N_seconds_field)) {
            /* leaf seconds-field (uint64) */

        } else if (!xml_strcmp(name, y_ptp_N_nanoseconds_field)) {
            /* leaf nanoseconds-field (uint32) */

        }
    }

    return res;

} /* u_ptp_time_get */



/**
 * @brief Get database object callback for list fault-record-list (getcb_fn2_t)\n
 * Path: list /ptp/instances/instance/fault-log-ds/fault-record-list\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_fault_record_list_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_fault_record_list_get");
    }

    boolean getnext = FALSE;

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        getnext = TRUE;
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    uint32 max_entries = GETCB_GET2_MAX_ENTRIES(get2cb);
    (void)max_entries;  // REMOVE THIS LINE IF max_entries USED

    /* This list has no keys defined; return entry somehow
     * no need to call getcb_add_return_key */

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* For GETNEXT, set the more_data flag to TRUE */
    boolean more_data = FALSE;

    /**** SET more_data FLAG ****/

    GETCB_GET2_MORE_DATA(get2cb) = more_data;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_ptp_N_severity)) {
            /* leaf severity (enumeration) */

        } else if (!xml_strcmp(name, y_ptp_N_name)) {
            /* leaf name (string) */

        } else if (!xml_strcmp(name, y_ptp_N_value)) {
            /* leaf value (string) */

        } else if (!xml_strcmp(name, y_ptp_N_description)) {
            /* leaf description (string) */

        }
    }

    return res;

} /* u_ptp_fault_record_list_get */



/**
 * @brief YANG 1.1 action validate callback. (agt_action_cb_t)\n
 * Path: /ptp/instances/instance/fault-log-ds/reset
 *
 * @param scb session invoking the "<action>" RPC
 * @param msg message in progress for this "<rpc>" request
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @param actionval the nested 'action-method-name' node that was parsed
 * within the topval subtree, in the RPC "<action>" request.
 * This is used to help derive the list keys.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
status_t u_reset_action_val (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode,
    val_value_t *actionval,
    uint32 k_ptp_instance_index)
{
    status_t res = NO_ERR;
    val_value_t *errorval = NULL;

    if (LOGDEBUG) {
        log_debug("\nEnter u_reset_action_val for action <reset>");
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* u_reset_action_val */


/**
 * @brief YANG 1.1 action invoke callback. (agt_action_cb_t)\n
 * Path: /ptp/instances/instance/fault-log-ds/reset
 *
 * @param scb session invoking the "<action>" RPC
 * @param msg message in progress for this "<rpc>" request
 * @param methnode XML node for the operation, which can be used
 * in error reporting (or ignored).
 * @param actionval the nested 'action-method-name' node that was parsed
 * within the topval subtree, in the RPC "<action>" request.
 * This is used to help derive the list keys.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 *  - An error in validate phase will cancel invoke phase
 *  - An rpc-error will be added if an error is returned and
 * the msg error Q is empty
 */
status_t u_reset_action_inv (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode,
    val_value_t *actionval,
    uint32 k_ptp_instance_index)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_reset_action_inv for action <reset>");
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if msg is used */
    (void)msg;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */

    /* No output nodes expected */

    return res;

} /* u_reset_action_inv */


/**
 * @brief Get database object callback for container fault-log-ds (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/fault-log-ds\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_fault_log_ds_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_fault_log_ds_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed
     */
    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_ptp_N_number_of_fault_records)) {
            /* leaf number-of-fault-records (uint16) */

        }
    }

    return res;

} /* u_ptp_fault_log_ds_get */


#endif /* u_ptp_F_fault_log */


#ifdef u_ptp_F_path_trace

/**
 * @brief Get database object callback for leaf-list list (getcb_fn2_t)\n
 * Path: leaf-list /ptp/instances/instance/path-trace-ds/list\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_list_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_list_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get all the instances of this leaf-list and add a val_value_t
     * for each one with the getcb_add_return_val function
     */

    return res;

} /* u_ptp_list_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/path-trace-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
status_t u_ptp_path_trace_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_path_trace_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_enable)) {
                /* leaf enable (boolean) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_path_trace_ds_edit */
#endif /* u_ptp_F_path_trace */


#ifdef u_ptp_F_alternate_timescale

/**
 * @brief Get database object callback for leaf max-key (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/alternate-timescale-ds/max-key\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_max_key_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_max_key_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint8 v_max_key = 0;

    /* add max_key to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_max_key,
        v_max_key,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_max_key_get */



/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance/alternate-timescale-ds/list
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_key_field Local key leaf 'key-field' in list 'list'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:alternate-timescale-ds/ptp:list/ptp:key-field
 * @return return status for the phase.
 */
status_t u_ptp_list_1_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint8 k_ptp_key_field)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_list_1_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_enable)) {
                /* leaf enable (boolean) */

            } else if (!xml_strcmp(name, y_ptp_N_current_offset)) {
                /* leaf current-offset (int32) */

            } else if (!xml_strcmp(name, y_ptp_N_jump_seconds)) {
                /* leaf jump-seconds (int32) */

            } else if (!xml_strcmp(name, y_ptp_N_time_of_next_jump)) {
                /* leaf time-of-next-jump (uint64) */

            } else if (!xml_strcmp(name, y_ptp_N_display_name)) {
                /* leaf display-name (string) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_list_1_edit */

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/alternate-timescale-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
status_t u_ptp_alternate_timescale_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_alternate_timescale_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_alternate_timescale_ds_edit */
#endif /* u_ptp_F_alternate_timescale */


#ifdef u_ptp_F_holdover_upgrade
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/holdover-upgrade-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
status_t u_ptp_holdover_upgrade_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_holdover_upgrade_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_enable)) {
                /* leaf enable (boolean) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_holdover_upgrade_ds_edit */
#endif /* u_ptp_F_holdover_upgrade */


#ifdef u_ptp_F_grandmaster_cluster

/**
 * @brief Get database object callback for leaf max-table-size (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/grandmaster-cluster-ds/max-table-size\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_max_table_size_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_max_table_size_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint8 v_max_table_size = 0;

    /* add max_table_size to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_max_table_size,
        v_max_table_size,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_max_table_size_get */



/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance/grandmaster-cluster-ds/port-address
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_index Local key leaf 'index' in list 'port-address'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:grandmaster-cluster-ds/ptp:port-address/ptp:index
 * @return return status for the phase.
 */
status_t u_ptp_port_address_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_port_address_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_network_protocol)) {
                /* leaf network-protocol (identityref) */

            } else if (!xml_strcmp(name, y_ptp_N_address_length)) {
                /* leaf address-length (uint16) */

            } else if (!xml_strcmp(name, y_ptp_N_address_field)) {
                /* leaf address-field (string) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_port_address_edit */

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/grandmaster-cluster-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
status_t u_ptp_grandmaster_cluster_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_grandmaster_cluster_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_log_query_interval)) {
                /* leaf log-query-interval (int8) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_grandmaster_cluster_ds_edit */
#endif /* u_ptp_F_grandmaster_cluster */


#ifdef u_ptp_F_acceptable_master

/**
 * @brief Get database object callback for leaf max-table-size (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/acceptable-master-ds/max-table-size\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status of the callback.
 */
status_t u_ptp_max_table_size_1_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_max_table_size_1_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint16 v_max_table_size = 0;

    /* add max_table_size to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_max_table_size,
        v_max_table_size,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_max_table_size_1_get */



/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/acceptable-master-ds/list/acceptable-port-identity
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_index_1 Ancestor key leaf 'index' in list 'list'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:acceptable-master-ds/ptp:list/ptp:index
 * @return return status for the phase.
 */
status_t u_ptp_acceptable_port_identity_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint8 k_ptp_index_1)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_acceptable_port_identity_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_clock_identity)) {
                /* leaf clock-identity (string) */

            } else if (!xml_strcmp(name, y_ptp_N_port_number)) {
                /* leaf port-number (uint16) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_acceptable_port_identity_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance/acceptable-master-ds/list
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_index_1 Local key leaf 'index' in list 'list'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:acceptable-master-ds/ptp:list/ptp:index
 * @return return status for the phase.
 */
status_t u_ptp_list_2_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint8 k_ptp_index_1)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_list_2_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_alternate_priority1)) {
                /* leaf alternate-priority1 (uint8) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_list_2_edit */

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/acceptable-master-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
status_t u_ptp_acceptable_master_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_acceptable_master_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_acceptable_master_ds_edit */
#endif /* u_ptp_F_acceptable_master */


#ifdef u_ptp_F_performance_monitoring

/**
 * @brief Get database object callback for list record-list (getcb_fn2_t)\n
 * Path: list /ptp/instances/instance/performance-monitoring-ds/record-list\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_index_2 Local key leaf 'index' in list 'record-list'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:performance-monitoring-ds/ptp:record-list/ptp:index
 * @param index_fixed TRUE if this key is fixed in a getnext request.
 * @param index_present TRUE if this key is present and 'k_ptp_index_2' is valid.\n
 * FALSE to get first in a getnext request.
 * @return return status of the callback.
 */
status_t u_ptp_record_list_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_index_2,
    boolean index_fixed,
    boolean index_present)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_record_list_get");
    }

    boolean getnext = FALSE;

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        getnext = TRUE;
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    uint32 max_entries = GETCB_GET2_MAX_ENTRIES(get2cb);
    (void)max_entries;  // REMOVE THIS LINE IF max_entries USED


    /* For GET, find the entry that matches the key values
     * For GETNEXT, find the entry that matches the next key value
     * If the 'present' flag is false then return first key instance
     * If the 'fixed' flag is true then no GETNEXT advance for the key
     * Create a new return key val_value_t, then getcb_add_return_key
     */

    /***** ADD RETURN KEYS AND REMOVE THIS COMMENT ****/

    if (GETCB_GET2_FIRST_RETURN_KEY(get2cb) == NULL) {
        return ERR_NCX_NO_INSTANCE;
    }

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* For GETNEXT, set the more_data flag to TRUE */
    boolean more_data = FALSE;

    /**** SET more_data FLAG ****/

    GETCB_GET2_MORE_DATA(get2cb) = more_data;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_ptp_N_measurement_valid)) {
            /* leaf measurement-valid (boolean) */

        } else if (!xml_strcmp(name, y_ptp_N_period_complete)) {
            /* leaf period-complete (boolean) */

        } else if (!xml_strcmp(name, y_ptp_N_pm_time)) {
            /* leaf pm-time (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_average_master_slave_delay)) {
            /* leaf average-master-slave-delay (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_minimum_master_slave_delay)) {
            /* leaf minimum-master-slave-delay (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_maximum_master_slave_delay)) {
            /* leaf maximum-master-slave-delay (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_stddev_master_slave_delay)) {
            /* leaf stddev-master-slave-delay (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_average_slave_master_delay)) {
            /* leaf average-slave-master-delay (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_minimum_slave_master_delay)) {
            /* leaf minimum-slave-master-delay (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_maximum_slave_master_delay)) {
            /* leaf maximum-slave-master-delay (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_stddev_slave_master_delay)) {
            /* leaf stddev-slave-master-delay (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_average_mean_path_delay)) {
            /* leaf average-mean-path-delay (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_minimum_mean_path_delay)) {
            /* leaf minimum-mean-path-delay (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_maximum_mean_path_delay)) {
            /* leaf maximum-mean-path-delay (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_stddev_mean_path_delay)) {
            /* leaf stddev-mean-path-delay (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_average_offset_from_master)) {
            /* leaf average-offset-from-master (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_minimum_offset_from_master)) {
            /* leaf minimum-offset-from-master (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_maximum_offset_from_master)) {
            /* leaf maximum-offset-from-master (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_stddev_offset_from_master)) {
            /* leaf stddev-offset-from-master (int64) */

        }
    }

    return res;

} /* u_ptp_record_list_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/performance-monitoring-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
status_t u_ptp_performance_monitoring_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_performance_monitoring_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_enable)) {
                /* leaf enable (boolean) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_performance_monitoring_ds_edit */
#endif /* u_ptp_F_performance_monitoring */


#ifdef u_ptp_F_enhanced_metrics
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/enhanced-metrics-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
status_t u_ptp_enhanced_metrics_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_enhanced_metrics_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_enable)) {
                /* leaf enable (boolean) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_enhanced_metrics_ds_edit */
#endif /* u_ptp_F_enhanced_metrics */


/**
 * @brief Get database object callback for container port-identity (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/ports/port/port-ds/port-identity\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_port_identity_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_port_identity_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed
     */
    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_ptp_N_clock_identity)) {
            /* leaf clock-identity (string) */

        } else if (!xml_strcmp(name, y_ptp_N_port_number)) {
            /* leaf port-number (uint16) */

        }
    }

    return res;

} /* u_ptp_port_identity_get */



/**
 * @brief Get database object callback for leaf mean-link-delay (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/mean-link-delay\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_mean_link_delay_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_mean_link_delay_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    int64 v_mean_link_delay = 0;

    /* add mean_link_delay to get2cb return_valQ */
    val_value_t *return_val = agt_make_int64_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_mean_link_delay,
        v_mean_link_delay,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_mean_link_delay_get */



/**
 * @brief Get database object callback for leaf log-sync-interval (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/log-sync-interval\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_log_sync_interval_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_log_sync_interval_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    int8 v_log_sync_interval = 0;

    /* add log_sync_interval to get2cb return_valQ */
    val_value_t *return_val = agt_make_int_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_log_sync_interval,
        v_log_sync_interval,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_log_sync_interval_get */



/**
 * @brief Get database object callback for leaf delay-mechanism (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/delay-mechanism\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_delay_mechanism_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_delay_mechanism_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_delay_mechanism = 0;

    /* add delay_mechanism to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_delay_mechanism,
        v_delay_mechanism,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_delay_mechanism_get */



/**
 * @brief Get database object callback for leaf version-number (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/version-number\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_version_number_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_version_number_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint8 v_version_number = 0;

    /* add version_number to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_version_number,
        v_version_number,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_version_number_get */



/**
 * @brief Get database object callback for leaf minor-version-number (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/minor-version-number\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_minor_version_number_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_minor_version_number_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint8 v_minor_version_number = 0;

    /* add minor_version_number to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_minor_version_number,
        v_minor_version_number,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_minor_version_number_get */



/**
 * @brief Get database object callback for leaf delay-asymmetry (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/port-ds/delay-asymmetry\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_delay_asymmetry_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_delay_asymmetry_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    int64 v_delay_asymmetry = 0;

    /* add delay_asymmetry to get2cb return_valQ */
    val_value_t *return_val = agt_make_int64_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_delay_asymmetry,
        v_delay_asymmetry,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_delay_asymmetry_get */



/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
status_t u_ptp_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_log_min_delay_req_interval)) {
                /* leaf log-min-delay-req-interval (int8) */

            } else if (!xml_strcmp(name, y_ptp_N_log_announce_interval)) {
                /* leaf log-announce-interval (int8) */

            } else if (!xml_strcmp(name, y_ptp_N_announce_receipt_timeout)) {
                /* leaf announce-receipt-timeout (uint8) */

            } else if (!xml_strcmp(name, y_ptp_N_log_min_pdelay_req_interval)) {
                /* leaf log-min-pdelay-req-interval (int8) */

            } else if (!xml_strcmp(name, y_ptp_N_port_enable)) {
                /* leaf port-enable (boolean) */

            } else if (!xml_strcmp(name, y_dot1as_ptp_N_mean_link_delay_thresh)) {
                /* leaf mean-link-delay-thresh (int64) */

            } else if (!xml_strcmp(name, y_dot1as_ptp_N_initial_log_announce_interval)) {
                /* leaf initial-log-announce-interval (int8) */

            } else if (!xml_strcmp(name, y_dot1as_ptp_N_initial_log_sync_interval)) {
                /* leaf initial-log-sync-interval (int8) */

            } else if (!xml_strcmp(name, y_dot1as_ptp_N_sync_receipt_timeout)) {
                /* leaf sync-receipt-timeout (uint8) */

            } else if (!xml_strcmp(name, y_dot1as_ptp_N_initial_log_pdelay_req_interval)) {
                /* leaf initial-log-pdelay-req-interval (int8) */

            } else if (!xml_strcmp(name, y_dot1as_ptp_N_mgt_log_pdelay_req_interval)) {
                /* leaf mgt-log-pdelay-req-interval (int8) */

            } else if (!xml_strcmp(name, y_dot1as_ptp_N_allowed_lost_responses)) {
                /* leaf allowed-lost-responses (uint8) */

            } else if (!xml_strcmp(name, y_dot1as_ptp_N_allowed_faults)) {
                /* leaf allowed-faults (uint8) */

            } else if (!xml_strcmp(name, y_dot1as_ptp_N_gptp_cap_receipt_timeout)) {
                /* leaf gptp-cap-receipt-timeout (uint8) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_port_ds_edit */


#ifdef u_ptp_F_timestamp_correction
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/timestamp-correction-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
status_t u_ptp_timestamp_correction_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_timestamp_correction_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_egress_latency)) {
                /* leaf egress-latency (int64) */

            } else if (!xml_strcmp(name, y_ptp_N_ingress_latency)) {
                /* leaf ingress-latency (int64) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_timestamp_correction_port_ds_edit */
#endif /* u_ptp_F_timestamp_correction */


#ifdef u_ptp_F_asymmetry_correction
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/asymmetry-correction-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
status_t u_ptp_asymmetry_correction_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_asymmetry_correction_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_constant_asymmetry)) {
                /* leaf constant-asymmetry (int64) */

            } else if (!xml_strcmp(name, y_ptp_N_scaled_delay_coefficient)) {
                /* leaf scaled-delay-coefficient (int64) */

            } else if (!xml_strcmp(name, y_ptp_N_enable)) {
                /* leaf enable (boolean) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_asymmetry_correction_port_ds_edit */
#endif /* u_ptp_F_asymmetry_correction */


#ifdef u_ptp_F_unicast_negotiation
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/unicast-negotiation-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
status_t u_ptp_unicast_negotiation_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_unicast_negotiation_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_enable)) {
                /* leaf enable (boolean) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_unicast_negotiation_port_ds_edit */
#endif /* u_ptp_F_unicast_negotiation */


#ifdef u_ptp_F_alternate_master
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/alternate-master-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
status_t u_ptp_alternate_master_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_alternate_master_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_number_of_alt_masters)) {
                /* leaf number-of-alt-masters (uint8) */

            } else if (!xml_strcmp(name, y_ptp_N_tx_alt_multicast_sync)) {
                /* leaf tx-alt-multicast-sync (boolean) */

            } else if (!xml_strcmp(name, y_ptp_N_log_alt_multicast_sync_interval)) {
                /* leaf log-alt-multicast-sync-interval (int8) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_alternate_master_port_ds_edit */
#endif /* u_ptp_F_alternate_master */


#ifdef u_ptp_F_unicast_discovery

/**
 * @brief Get database object callback for leaf max-table-size (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/unicast-discovery-port-ds/max-table-size\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_max_table_size_2_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_max_table_size_2_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint16 v_max_table_size = 0;

    /* add max_table_size to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_max_table_size,
        v_max_table_size,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_max_table_size_2_get */



/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance/ports/port/unicast-discovery-port-ds/port-address
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @param k_ptp_index_3 Local key leaf 'index' in list 'port-address'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:unicast-discovery-port-ds/ptp:port-address/ptp:index
 * @return return status for the phase.
 */
status_t u_ptp_port_address_1_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index,
    uint16 k_ptp_index_3)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_port_address_1_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_network_protocol)) {
                /* leaf network-protocol (identityref) */

            } else if (!xml_strcmp(name, y_ptp_N_address_length)) {
                /* leaf address-length (uint16) */

            } else if (!xml_strcmp(name, y_ptp_N_address_field)) {
                /* leaf address-field (string) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_port_address_1_edit */

/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/unicast-discovery-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
status_t u_ptp_unicast_discovery_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_unicast_discovery_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_log_query_interval)) {
                /* leaf log-query-interval (int8) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_unicast_discovery_port_ds_edit */
#endif /* u_ptp_F_unicast_discovery */


#ifdef u_ptp_F_acceptable_master
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/acceptable-master-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
status_t u_ptp_acceptable_master_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_acceptable_master_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_enable)) {
                /* leaf enable (boolean) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_acceptable_master_port_ds_edit */
#endif /* u_ptp_F_acceptable_master */


#ifdef u_ptp_F_l1_sync

/**
 * @brief Get database object callback for leaf link-alive (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/link-alive\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_link_alive_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_link_alive_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    boolean v_link_alive = 0;

    /* add link_alive to get2cb return_valQ */
    val_value_t *return_val = agt_make_boolean_leaf(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_link_alive,
        v_link_alive,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_link_alive_get */



/**
 * @brief Get database object callback for leaf is-tx-coherent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/is-tx-coherent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_is_tx_coherent_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_is_tx_coherent_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    boolean v_is_tx_coherent = 0;

    /* add is_tx_coherent to get2cb return_valQ */
    val_value_t *return_val = agt_make_boolean_leaf(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_is_tx_coherent,
        v_is_tx_coherent,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_is_tx_coherent_get */



/**
 * @brief Get database object callback for leaf is-rx-coherent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/is-rx-coherent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_is_rx_coherent_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_is_rx_coherent_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    boolean v_is_rx_coherent = 0;

    /* add is_rx_coherent to get2cb return_valQ */
    val_value_t *return_val = agt_make_boolean_leaf(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_is_rx_coherent,
        v_is_rx_coherent,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_is_rx_coherent_get */



/**
 * @brief Get database object callback for leaf is-congruent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/is-congruent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_is_congruent_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_is_congruent_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    boolean v_is_congruent = 0;

    /* add is_congruent to get2cb return_valQ */
    val_value_t *return_val = agt_make_boolean_leaf(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_is_congruent,
        v_is_congruent,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_is_congruent_get */



/**
 * @brief Get database object callback for leaf l1sync-state (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/l1sync-state\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_l1sync_state_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_l1sync_state_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_l1sync_state = 0;

    /* add l1sync_state to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_l1sync_state,
        v_l1sync_state,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_l1sync_state_get */



/**
 * @brief Get database object callback for leaf peer-tx-coherent-is-required (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-tx-coherent-is-required\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_peer_tx_coherent_is_required_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_peer_tx_coherent_is_required_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    boolean v_peer_tx_coherent_is_required = 0;

    /* add peer_tx_coherent_is_required to get2cb return_valQ */
    val_value_t *return_val = agt_make_boolean_leaf(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_peer_tx_coherent_is_required,
        v_peer_tx_coherent_is_required,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_peer_tx_coherent_is_required_get */



/**
 * @brief Get database object callback for leaf peer-rx-coherent-is-required (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-rx-coherent-is-required\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_peer_rx_coherent_is_required_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_peer_rx_coherent_is_required_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    boolean v_peer_rx_coherent_is_required = 0;

    /* add peer_rx_coherent_is_required to get2cb return_valQ */
    val_value_t *return_val = agt_make_boolean_leaf(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_peer_rx_coherent_is_required,
        v_peer_rx_coherent_is_required,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_peer_rx_coherent_is_required_get */



/**
 * @brief Get database object callback for leaf peer-congruent-is-required (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-congruent-is-required\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_peer_congruent_is_required_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_peer_congruent_is_required_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    boolean v_peer_congruent_is_required = 0;

    /* add peer_congruent_is_required to get2cb return_valQ */
    val_value_t *return_val = agt_make_boolean_leaf(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_peer_congruent_is_required,
        v_peer_congruent_is_required,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_peer_congruent_is_required_get */



/**
 * @brief Get database object callback for leaf peer-is-tx-coherent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-is-tx-coherent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_peer_is_tx_coherent_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_peer_is_tx_coherent_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    boolean v_peer_is_tx_coherent = 0;

    /* add peer_is_tx_coherent to get2cb return_valQ */
    val_value_t *return_val = agt_make_boolean_leaf(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_peer_is_tx_coherent,
        v_peer_is_tx_coherent,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_peer_is_tx_coherent_get */



/**
 * @brief Get database object callback for leaf peer-is-rx-coherent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-is-rx-coherent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_peer_is_rx_coherent_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_peer_is_rx_coherent_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    boolean v_peer_is_rx_coherent = 0;

    /* add peer_is_rx_coherent to get2cb return_valQ */
    val_value_t *return_val = agt_make_boolean_leaf(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_peer_is_rx_coherent,
        v_peer_is_rx_coherent,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_peer_is_rx_coherent_get */



/**
 * @brief Get database object callback for leaf peer-is-congruent (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-basic-port-ds/peer-is-congruent\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_peer_is_congruent_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_peer_is_congruent_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    boolean v_peer_is_congruent = 0;

    /* add peer_is_congruent to get2cb return_valQ */
    val_value_t *return_val = agt_make_boolean_leaf(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_peer_is_congruent,
        v_peer_is_congruent,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_peer_is_congruent_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/l1-sync-basic-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
status_t u_ptp_l1_sync_basic_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_l1_sync_basic_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_enabled)) {
                /* leaf enabled (boolean) */

            } else if (!xml_strcmp(name, y_ptp_N_tx_coherent_is_required)) {
                /* leaf tx-coherent-is-required (boolean) */

            } else if (!xml_strcmp(name, y_ptp_N_rx_coherent_is_required)) {
                /* leaf rx-coherent-is-required (boolean) */

            } else if (!xml_strcmp(name, y_ptp_N_congruent_is_required)) {
                /* leaf congruent-is-required (boolean) */

            } else if (!xml_strcmp(name, y_ptp_N_opt_params_enabled)) {
                /* leaf opt-params-enabled (boolean) */

            } else if (!xml_strcmp(name, y_ptp_N_log_l1sync_interval)) {
                /* leaf log-l1sync-interval (int8) */

            } else if (!xml_strcmp(name, y_ptp_N_l1sync_receipt_timeout)) {
                /* leaf l1sync-receipt-timeout (uint8) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_l1_sync_basic_port_ds_edit */
#endif /* u_ptp_F_l1_sync */


#ifdef u_ptp_F_l1_sync

/**
 * @brief Get database object callback for leaf phase-offset-tx-valid (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx-valid\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_phase_offset_tx_valid_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_phase_offset_tx_valid_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    boolean v_phase_offset_tx_valid = 0;

    /* add phase_offset_tx_valid to get2cb return_valQ */
    val_value_t *return_val = agt_make_boolean_leaf(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_phase_offset_tx_valid,
        v_phase_offset_tx_valid,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_phase_offset_tx_valid_get */



/**
 * @brief Get database object callback for leaf phase-offset-tx (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_phase_offset_tx_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_phase_offset_tx_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    int64 v_phase_offset_tx = 0;

    /* add phase_offset_tx to get2cb return_valQ */
    val_value_t *return_val = agt_make_int64_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_phase_offset_tx,
        v_phase_offset_tx,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_phase_offset_tx_get */



/**
 * @brief Get database object callback for container phase-offset-tx-timestamp (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/phase-offset-tx-timestamp\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_phase_offset_tx_timestamp_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_phase_offset_tx_timestamp_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed
     */
    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_ptp_N_seconds_field)) {
            /* leaf seconds-field (uint64) */

        } else if (!xml_strcmp(name, y_ptp_N_nanoseconds_field)) {
            /* leaf nanoseconds-field (uint32) */

        }
    }

    return res;

} /* u_ptp_phase_offset_tx_timestamp_get */



/**
 * @brief Get database object callback for leaf frequency-offset-tx-valid (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx-valid\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_frequency_offset_tx_valid_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_frequency_offset_tx_valid_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    boolean v_frequency_offset_tx_valid = 0;

    /* add frequency_offset_tx_valid to get2cb return_valQ */
    val_value_t *return_val = agt_make_boolean_leaf(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_frequency_offset_tx_valid,
        v_frequency_offset_tx_valid,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_frequency_offset_tx_valid_get */



/**
 * @brief Get database object callback for leaf frequency-offset-tx (getcb_fn2_t)\n
 * Path: leaf /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_frequency_offset_tx_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_frequency_offset_tx_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system
     * CHANGE node_exists TO TRUE WHEN VALUE CODE FILLED IN */
    boolean node_exists = FALSE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    int64 v_frequency_offset_tx = 0;

    /* add frequency_offset_tx to get2cb return_valQ */
    val_value_t *return_val = agt_make_int64_leaf2(
        obj,
        y_ptp_M_ptp,
        y_ptp_N_frequency_offset_tx,
        v_frequency_offset_tx,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ptp_frequency_offset_tx_get */



/**
 * @brief Get database object callback for container frequency-offset-tx-timestamp (getcb_fn2_t)\n
 * Path: container /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds/frequency-offset-tx-timestamp\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status of the callback.
 */
status_t u_ptp_frequency_offset_tx_timestamp_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_frequency_offset_tx_timestamp_get");
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed
     */
    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_ptp_N_seconds_field)) {
            /* leaf seconds-field (uint64) */

        } else if (!xml_strcmp(name, y_ptp_N_nanoseconds_field)) {
            /* leaf nanoseconds-field (uint32) */

        }
    }

    return res;

} /* u_ptp_frequency_offset_tx_timestamp_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/l1-sync-opt-params-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
status_t u_ptp_l1_sync_opt_params_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_l1_sync_opt_params_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_timestamps_corrected_tx)) {
                /* leaf timestamps-corrected-tx (boolean) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_l1_sync_opt_params_port_ds_edit */
#endif /* u_ptp_F_l1_sync */


#ifdef u_ptp_F_performance_monitoring

/**
 * @brief Get database object callback for list record-list-peer-delay (getcb_fn2_t)\n
 * Path: list /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list-peer-delay\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @param k_ptp_index_4 Local key leaf 'index' in list 'record-list-peer-delay'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:performance-monitoring-port-ds/ptp:record-list-peer-delay/ptp:index
 * @param index_fixed TRUE if this key is fixed in a getnext request.
 * @param index_present TRUE if this key is present and 'k_ptp_index_4' is valid.\n
 * FALSE to get first in a getnext request.
 * @return return status of the callback.
 */
status_t u_ptp_record_list_peer_delay_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index,
    uint16 k_ptp_index_4,
    boolean index_fixed,
    boolean index_present)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_record_list_peer_delay_get");
    }

    boolean getnext = FALSE;

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        getnext = TRUE;
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    uint32 max_entries = GETCB_GET2_MAX_ENTRIES(get2cb);
    (void)max_entries;  // REMOVE THIS LINE IF max_entries USED


    /* For GET, find the entry that matches the key values
     * For GETNEXT, find the entry that matches the next key value
     * If the 'present' flag is false then return first key instance
     * If the 'fixed' flag is true then no GETNEXT advance for the key
     * Create a new return key val_value_t, then getcb_add_return_key
     */

    /***** ADD RETURN KEYS AND REMOVE THIS COMMENT ****/

    if (GETCB_GET2_FIRST_RETURN_KEY(get2cb) == NULL) {
        return ERR_NCX_NO_INSTANCE;
    }

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* For GETNEXT, set the more_data flag to TRUE */
    boolean more_data = FALSE;

    /**** SET more_data FLAG ****/

    GETCB_GET2_MORE_DATA(get2cb) = more_data;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_ptp_N_pm_time)) {
            /* leaf pm-time (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_average_mean_link_delay)) {
            /* leaf average-mean-link-delay (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_min_mean_link_delay)) {
            /* leaf min-mean-link-delay (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_max_mean_link_delay)) {
            /* leaf max-mean-link-delay (int64) */

        } else if (!xml_strcmp(name, y_ptp_N_stddev_mean_link_delay)) {
            /* leaf stddev-mean-link-delay (int64) */

        }
    }

    return res;

} /* u_ptp_record_list_peer_delay_get */



/**
 * @brief Get database object callback for list record-list (getcb_fn2_t)\n
 * Path: list /ptp/instances/instance/ports/port/performance-monitoring-port-ds/record-list\n
 *
 * Fill in 'get2cb' response fields.
 *
 * @param get2cb GET2 control block for the callback.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @param k_ptp_index_5 Local key leaf 'index' in list 'record-list'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:performance-monitoring-port-ds/ptp:record-list/ptp:index
 * @param index_fixed TRUE if this key is fixed in a getnext request.
 * @param index_present TRUE if this key is present and 'k_ptp_index_5' is valid.\n
 * FALSE to get first in a getnext request.
 * @return return status of the callback.
 */
status_t u_ptp_record_list_1_get (
    getcb_get2_t *get2cb,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index,
    uint16 k_ptp_index_5,
    boolean index_fixed,
    boolean index_present)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_record_list_1_get");
    }

    boolean getnext = FALSE;

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        getnext = TRUE;
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    uint32 max_entries = GETCB_GET2_MAX_ENTRIES(get2cb);
    (void)max_entries;  // REMOVE THIS LINE IF max_entries USED


    /* For GET, find the entry that matches the key values
     * For GETNEXT, find the entry that matches the next key value
     * If the 'present' flag is false then return first key instance
     * If the 'fixed' flag is true then no GETNEXT advance for the key
     * Create a new return key val_value_t, then getcb_add_return_key
     */

    /***** ADD RETURN KEYS AND REMOVE THIS COMMENT ****/

    if (GETCB_GET2_FIRST_RETURN_KEY(get2cb) == NULL) {
        return ERR_NCX_NO_INSTANCE;
    }

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* For GETNEXT, set the more_data flag to TRUE */
    boolean more_data = FALSE;

    /**** SET more_data FLAG ****/

    GETCB_GET2_MORE_DATA(get2cb) = more_data;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_ptp_N_pm_time)) {
            /* leaf pm-time (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_announce_tx)) {
            /* leaf announce-tx (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_announce_rx)) {
            /* leaf announce-rx (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_announce_foreign_rx)) {
            /* leaf announce-foreign-rx (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_sync_tx)) {
            /* leaf sync-tx (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_sync_rx)) {
            /* leaf sync-rx (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_follow_up_tx)) {
            /* leaf follow-up-tx (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_follow_up_rx)) {
            /* leaf follow-up-rx (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_delay_req_tx)) {
            /* leaf delay-req-tx (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_delay_req_rx)) {
            /* leaf delay-req-rx (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_delay_resp_tx)) {
            /* leaf delay-resp-tx (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_delay_resp_rx)) {
            /* leaf delay-resp-rx (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_pdelay_req_tx)) {
            /* leaf pdelay-req-tx (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_pdelay_req_rx)) {
            /* leaf pdelay-req-rx (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_pdelay_resp_tx)) {
            /* leaf pdelay-resp-tx (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_pdelay_resp_rx)) {
            /* leaf pdelay-resp-rx (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_pdelay_resp_follow_up_tx)) {
            /* leaf pdelay-resp-follow-up-tx (uint32) */

        } else if (!xml_strcmp(name, y_ptp_N_pdelay_resp_follow_up_rx)) {
            /* leaf pdelay-resp-follow-up-rx (uint32) */

        }
    }

    return res;

} /* u_ptp_record_list_1_get */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/performance-monitoring-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
status_t u_ptp_performance_monitoring_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_performance_monitoring_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_performance_monitoring_port_ds_edit */
#endif /* u_ptp_F_performance_monitoring */


#ifdef u_ptp_F_external_port_config
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/external-port-config-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
status_t u_ptp_external_port_config_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_external_port_config_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_desired_state)) {
                /* leaf desired-state (enumeration) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_external_port_config_port_ds_edit */
#endif /* u_ptp_F_external_port_config */


#ifdef u_ptp_F_slave_monitoring
/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports/port/slave-monitoring-port-ds
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Ancestor key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
status_t u_ptp_slave_monitoring_port_ds_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_slave_monitoring_port_ds_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_enable)) {
                /* leaf enable (bits) */

            } else if (!xml_strcmp(name, y_ptp_N_events_per_rx_sync_timing_tlv)) {
                /* leaf events-per-rx-sync-timing-tlv (uint8) */

            } else if (!xml_strcmp(name, y_ptp_N_events_per_rx_sync_computed_tlv)) {
                /* leaf events-per-rx-sync-computed-tlv (uint8) */

            } else if (!xml_strcmp(name, y_ptp_N_events_per_tx_timestamps_tlv)) {
                /* leaf events-per-tx-timestamps-tlv (uint8) */

            } else if (!xml_strcmp(name, y_ptp_N_tx_event_type)) {
                /* leaf tx-event-type (uint8) */

            } else if (!xml_strcmp(name, y_ptp_N_rx_sync_timing_tlv_message_m)) {
                /* leaf rx-sync-timing-tlv-message-m (uint8) */

            } else if (!xml_strcmp(name, y_ptp_N_rx_sync_computed_tlv_message_m)) {
                /* leaf rx-sync-computed-tlv-message-m (uint8) */

            } else if (!xml_strcmp(name, y_ptp_N_tx_timestamps_tlv_message_m)) {
                /* leaf tx-timestamps-tlv-message-m (uint8) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_slave_monitoring_port_ds_edit */
#endif /* u_ptp_F_slave_monitoring */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance/ports/port
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @param k_ptp_port_index Local key leaf 'port-index' in list 'port'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:ports/ptp:port/ptp:port-index
 * @return return status for the phase.
 */
status_t u_ptp_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index,
    uint16 k_ptp_port_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_ptp_N_underlying_interface)) {
                /* leaf underlying-interface (leafref) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_port_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances/instance/ports
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Ancestor key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
status_t u_ptp_ports_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_ports_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_ports_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: list /ptp/instances/instance
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @param k_ptp_instance_index Local key leaf 'instance-index' in list 'instance'\n
 * Path: /ptp:ptp/ptp:instances/ptp:instance/ptp:instance-index
 * @return return status for the phase.
 */
status_t u_ptp_instance_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint32 k_ptp_instance_index)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_instance_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_instance_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp/instances
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
status_t u_ptp_instances_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_instances_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_instances_edit */


/**
 * @brief Edit database object callback (agt_cb_fn_t)\n
 * Path: container /ptp
 *
 * @param scb session control block making the request
 * @param msg message in progress for this edit request
 * @param cbtyp callback type for this callback
 * @param editop the parent edit-config operation type,
 * which is also used for all other callbacks
 * that operate on objects.
 * @param newval container object holding the proposed changes
 * to apply to the current config, depending on
 * the editop value. Will not be NULL.
 * @param curval current container values from the "<running>"
 * or "<candidate>" configuration, if any. Could be NULL
 * for create and other operations.
 * @return return status for the phase.
 */
status_t u_ptp_ptp_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    (void)scb;  /* remove if scb used */
    (void)msg;  /* remove if msg used */
    (void)newval;  /* remove if newval used */
    (void)curval;  /* remove if curval used */

    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ptp_ptp_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    if (editop == OP_EDITOP_MERGE) {
        /* the edit is not really on this node; need to get
         * each child_undo record to get the real edited nodes */
        sil_sa_child_edit_t *child_edit  = sil_sa_first_child_edit(msg);

        while (child_edit) {
            op_editop_t child_editop = OP_EDITOP_NONE;
            val_value_t *child_newval = NULL;
            val_value_t *child_curval = NULL;

            sil_sa_child_edit_fields(child_edit,
                &child_editop,
                &child_newval,
                &child_curval);

            if (LOGDEBUG2) {
                log_debug2("\nchild edit %s", op_editop_name(child_editop));
                if (child_newval) {
                    log_debug2_append("\nnew");
                    val_dump_value(child_newval, 0, DBG2);
                }
                if (child_curval) {
                    log_debug2_append("\ncur");
                    val_dump_value(child_curval, 0, DBG2);
                }
            }

            obj_template_t *chobj = (child_newval) ?
                VAL_OBJ(child_newval) : VAL_OBJ(child_curval);
            const xmlChar *name = obj_get_name(chobj);

            /**** process child edits here ****/

            if (!xml_strcmp(name, y_xl4gptp_N_instance_domain_map)) {
                /* leaf-list instance-domain-map (string) */

            }

            child_edit = sil_sa_next_child_edit(child_edit);
        }
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        /* USE SET_ERROR FOR PROGRAMMING BUGS ONLY */
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ptp_ptp_edit */


/**
 * @brief Phase 1: Initialize the ieee1588-ptp server instrumentation library.
 *
 * Called by server when module is loaded.
 *
 * @param modname requested module name to load
 * @param revision requested revision date of the module to load.
 * This may be NULL if the module has no revision statements.
 * @return return status. An error will cause the module load to fail.
 */
status_t u_ieee1588_ptp_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ieee1588_ptp_init");
    }

    ncx_module_t *ieee1588_ptp_mod = NULL;

    ieee1588_ptp_mod = ncx_find_module(modname, revision);
    if (ieee1588_ptp_mod == NULL) {
        return ERR_NCX_OPERATION_FAILED;
    }

    /* put your module initialization code here */

    return res;

} /* u_ieee1588_ptp_init */


/**
 * @brief Phase 2: Initialize the ieee1588-ptp server instrumentation library.
 *
 * SIL init phase 2: non-config data structures.
 * Called after running config is loaded.
 *
 * @return return status. An error will cause the
 * server initialization to fail.
 */
status_t u_ieee1588_ptp_init2 (void)
{
    status_t res = NO_ERR;

    if (LOGDEBUG) {
        log_debug("\nEnter u_ieee1588_ptp_init2");
    }


    /* put your init2 code here */

    return res;

} /* u_ieee1588_ptp_init2 */


/**
 * @brief Cleanup the ieee1588-ptp server instrumentation library.
 *
 * Called by server when module is unloaded.
 *
 */
void u_ieee1588_ptp_cleanup (void)
{

    if (LOGDEBUG) {
        log_debug("\nEnter u_ieee1588_ptp_cleanup");
    }


    /* put your cleanup code here */

} /* u_ieee1588_ptp_cleanup */


 /** @} */

/* END SIL-SA u_ieee1588-ptp.c */
